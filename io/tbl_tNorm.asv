function tblOut = tbl_tNorm(tbl, varargin)
% TBL_TNORM Normalizes vector columns in a table based on a baseline window.
%
%   tblOut = TBL_TNORM(tbl, ...) normalizes numeric variables in 'tbl' using
%   statistics (mean, std, min, max) calculated from a specified window
%   ('winNorm'). The function calculates the center (C) and scale (S)
%   parameters from the window and applies them to the entire vector using
%   MATLAB's normalize function: (x - C) / S.
%
%   You can pass additional arguments supported by NORMALIZE (e.g., 'Type')
%   as unmatched key-value pairs.
%
%   INPUTS:
%       tbl         - (table) Input table.
%
%   OPTIONAL KEY-VALUE PAIRS:
%       'varsInc'   - (cell/char) Variables to include. Default: All numeric.
%       'varsGrp'   - (cell/char) Variables to group by. Stats are calculated
%                     per group (pooled) but applied to individual rows.
%       'winNorm'   - (1x2 double) [Start End] indices for the baseline window.
%                     Stats are calculated from this window. Default: Full vector.
%       'Method'    - (char) Normalization method {'percentage'}:
%                     'percentage' : x / mean(win)     (C=0, S=mu)
%                     'zscore'     : (x - mu)/sigma    (C=mu, S=sigma)
%                     'center'     : x - mu            (C=mu, S=1)
%                     'scale'      : x / sigma         (C=0, S=sigma)
%                     'range'      : (x - min)/range   (C=min, S=max-min)
%
%   EXAMPLE:
%       % Normalize 'LFP' column to baseline (indices 1-100) as percentage:
%       tbl = tbl_tNorm(tbl, 'varsInc', 'LFP', 'winNorm', [1, 100], 'Method', 'percentage');
%
%       % Z-score 'FR' by 'Genotype' group using baseline stats:
%       tbl = tbl_tNorm(tbl, 'varsInc', 'FR', 'varsGrp', 'Genotype', ...
%                       'winNorm', [1, 500], 'Method', 'zscore');
%
%   See also: NORMALIZE

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
p.KeepUnmatched = true;
addRequired(p, 'tbl', @istable);
addParameter(p, 'varsInc', [], @(x) iscell(x) || ischar(x) || isstring(x) || isempty(x));
addParameter(p, 'varsGrp', [], @(x) iscell(x) || ischar(x) || isstring(x) || isempty(x));
addParameter(p, 'winNorm', [], @(x) isnumeric(x) && (isempty(x) || numel(x)==2));
addParameter(p, 'Method', 'percentage', @(x) ischar(x) || isstring(x));

parse(p, tbl, varargin{:});

varsInc = p.Results.varsInc;
varsGrp = p.Results.varsGrp;
winNorm = p.Results.winNorm;
method  = p.Results.Method;

% Pass unmatched arguments to normalize
unmatched = p.Unmatched;
normArgs = reshape([fieldnames(unmatched), struct2cell(unmatched)]', 1, []);

% Standardize cell arrays
if ischar(varsInc) || isstring(varsInc), varsInc = cellstr(varsInc); end
if ischar(varsGrp) || isstring(varsGrp), varsGrp = cellstr(varsGrp); end


%% ========================================================================
%  INITIALIZATION
%  ========================================================================

tblOut = tbl;
tblVars = tbl.Properties.VariableNames;

% 1. Determine Variables
if isempty(varsInc)
    processVars = tblVars;
else
    % Only keep variables that exist in the table
    processVars = varsInc(ismember(varsInc, tblVars));
    if length(processVars) < length(varsInc)
        warning('Some requested variables were not found in the table.');
    end
end

% 2. Filter Numeric Variables Only
isNum = cellfun(@(x) isnumeric(tblOut.(x)), processVars);
processVars = processVars(isNum);

% 3. Window Check
wS = 1; wE = inf;
if ~isempty(winNorm)
    wS = max(1, winNorm(1));
    wE = winNorm(2);
end


%% ========================================================================
%  PRE-CALCULATE GROUPS
%  ========================================================================

if ~isempty(varsGrp)
    uGrps = unique(tblOut(:, varsGrp), 'rows');
    nGrps = height(uGrps);
    idxGrps = cell(nGrps, 1);

    for iGrp = 1:nGrps
        uRow = uGrps(iGrp, :);

        % Initialize index filter
        idxGrp = true(height(tblOut), 1);

        % Filter matching rows (Works for numeric, string, categorical)
        for iVar = 1:length(varsGrp)
            v = varsGrp{iVar};
            idxGrp = idxGrp & (tblOut.(v) == uRow.(v));
        end
        idxGrps{iGrp} = idxGrp;
    end
else
    idxGrps = {};
end


%% ========================================================================
%  TRANSFORM
%  ========================================================================

for iVar = 1:length(processVars)
    varName = processVars{iVar};
    varData = tblOut.(varName);

    % Clamp window end to data size
    wE = min(size(varData, 2), wE);

    % ---------------------------------------
    % Case 1: Row-wise Normalization
    % ---------------------------------------
    if isempty(idxGrps)

        % Extract Window Data for Stats
        winMat = varData(:, wS:wE);

        % Calculate Params (Row-wise -> Dim 2)
        [C, S] = getNormParams(winMat, method, 2);

        % Apply Normalize
        varData = normalize(varData, 2, 'center', C, 'scale', S, normArgs{:});

        % ---------------------------------------
        % Case 2: Group-wise Normalization
        % ---------------------------------------
    else
        for iGrp = 1:length(idxGrps)
            idx = idxGrps{iGrp};
            grpData = varData(idx, :);

            % Extract Pooled Window Data
            subMat = grpData(:, wS:wE);

            % Calculate Params (Pooled -> Dim 1/Vector)
            [C, S] = getNormParams(subMat(:), method, 1);

            % Apply Normalize to Group Rows (using scalar/pooled stats)
            varData(idx, :) = normalize(grpData, 2, 'center', C, 'scale', S, normArgs{:});
        end
    end

    tblOut.(varName) = varData;
end

end

%% ========================================================================
%  HELPER FUNCTION
%  ========================================================================

function [C, S] = getNormParams(vals, method, dim)
% Calculates Center (C) and Scale (S) parameters based on the method.
% 'vals' is the data window used for statistics. 'dim' specifies operation.

% Ignore NaNs for statistics
switch lower(method)
    case 'percentage'
        mu = mean(vals, dim, 'omitnan');
        C = 0;
        S = mu;

    case 'zscore'
        mu = mean(vals, dim, 'omitnan');
        sig = std(vals, 0, dim, 'omitnan');
        C = mu;
        S = sig;

    case 'center'
        mu = mean(vals, dim, 'omitnan');
        C = mu;
        S = 1;

    case 'scale'
        sig = std(vals, 0, dim, 'omitnan');
        C = 0;
        S = sig;

    case 'range'
        mn = min(vals, [], dim, 'omitnan');
        mx = max(vals, [], dim, 'omitnan');
        C = mn;
        S = mx - mn;

    otherwise
        % Default to zscore-like behavior if unknown
        mu = mean(vals, dim, 'omitnan');
        sig = std(vals, 0, dim, 'omitnan');
        C = mu;
        S = sig;
end

% Prevent division by zero
S(S == 0) = eps;

end
