function tblOut = tbl_transform(tbl, varargin)
% TBL_TRANSFORM Applies log transformations, z-scoring, and normalization to table columns.
%
% SUMMARY:
% This function transforms table columns to improve their distributional
% properties for statistical analysis. It applies log transformation to
% highly skewed variables, z-scoring to standardise variables for
% regression analysis, and normalization relative to reference categories.
%
% INPUT (Required):
%   tbl         - Input table to be transformed.
%
% INPUT (Optional Key-Value Pairs):
%   varsExc     - Cell array of variable names to exclude from transformations {[]}.
%   varsInc     - Cell array of variable names to include in transformations {[]}.
%                  If provided, only these variables will be transformed (overrides varsExc).
%   flgZ        - Logical flag to apply z-scoring {true}.
%   flgLog      - Logical flag to apply log transformation to skewed variables {true}.
%   flgNorm     - Logical flag to apply normalization relative to reference category {false}.
%   skewThr     - Skewness threshold for log transformation {2}.
%   varsGrp     - Cell array of categorical variable names defining groups for
%                  separate transformation {[]}. If provided, transformations are
%                  applied separately within each group combination.
%   varNorm     - String. The name of the categorical variable whose reference
%                  category mean will be used for normalization (required if flgNorm=true).
%
% OUTPUT:
%   tblOut      - Transformed table with the same structure as input.
%
% EXAMPLE:
%   tblOut = tbl_transform(tbl, 'varsExc', {'UnitID', 'Group'}, 'flgZ', true);
%   tblOut = tbl_transform(tbl, 'varsGrp', {'Group', 'State'}, 'flgZ', true);
%   tblOut = tbl_transform(tbl, 'flgNorm', true, 'varNorm', 'Day', 'varsGrp', {'Group', 'State'});
%
% DEPENDENCIES:
%   None
%
%   See also: LME_ANALYSE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ARGUMENT PARSING & INITIALIZATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p = inputParser;
addRequired(p, 'tbl', @istable);
addParameter(p, 'varsExc', [], @(x) iscell(x) || isempty(x));
addParameter(p, 'varsInc', [], @(x) iscell(x) || isempty(x));
addParameter(p, 'varsGrp', [], @(x) iscell(x) || isempty(x));
addParameter(p, 'varNorm', '', @ischar);
addParameter(p, 'flgZ', false, @islogical);
addParameter(p, 'flgLog', false, @islogical);
addParameter(p, 'flgNorm', false, @islogical);
addParameter(p, 'skewThr', 2, @(x) isnumeric(x) && isscalar(x) && x > 0);
addParameter(p, 'flg0', false, @islogical);
addParameter(p, 'verbose', false, @islogical);

parse(p, tbl, varargin{:});

varsExc = p.Results.varsExc;
varsInc = p.Results.varsInc;
varsGrp = p.Results.varsGrp;
varNorm = p.Results.varNorm;
flgZ = p.Results.flgZ;
flgLog = p.Results.flgLog;
flgNorm = p.Results.flgNorm;
skewThr = p.Results.skewThr;
flg0 = p.Results.flg0;
verbose = p.Results.verbose;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INITIALIZE VARIABLES & VALIDATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Get all variable names from the table
tblVars = tbl.Properties.VariableNames;
tblOut = tbl;

% Determine which variables to process
if ~isempty(varsInc)
    % Include only specified variables (takes precedence over varsExc)
    processVars = varsInc;
elseif ~isempty(varsExc)
    % Exclude specified variables
    excludeIdx = ismember(tblVars, varsExc);
    processVars = tblVars(~excludeIdx);
else
    % Process all variables
    processVars = tblVars;
end

% Filter to only numeric variables
numericIdx = cellfun(@(x) isnumeric(tbl.(x)), processVars);
processVars = processVars(numericIdx);

% Validation for Grouping and Normalization variables
if ~isempty(varsGrp)
    % Ensure varsGrp is cellstr
    if isstring(varsGrp)
        varsGrp = cellstr(varsGrp);
    end

    if ismember(varNorm, varsGrp)
        error('varNorm "%s" cannot be included in varsGrp', varNorm);
    end
end

% Warning for redundant transformations
if flgNorm && flgZ
    warning('Z-scoring will overwrite the scale set by normalization.');
end

% Get reference category (assuming first category is reference)
catRef = [];
if flgNorm
    if isempty(varNorm)
        error('flgNorm is true but varNorm is not specified.');
    end
    catRef = categories(tblOut.(varNorm));
    catRef = catRef{1};
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GROUP INDICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Check if group-based transformation is requested
if ~isempty(varsGrp)
    % Find unique combinations of grouping variables
    uGrps = unique(tblOut(:, varsGrp), 'rows');

    % Find all group indices in advance and store in cell array
    idxGrps = cell(height(uGrps), 1);
    for iGrp = 1:height(uGrps)
        uRow = uGrps(iGrp, :);

        % Find rows matching the current unique group combination
        idxGrp = true(height(tblOut), 1);
        for iVar = 1:length(varsGrp)
            idxGrp = idxGrp & (tblOut.(varsGrp{iVar}) == uRow.(varsGrp{iVar}));
        end
        idxGrps{iGrp} = idxGrp;
    end
else
    % Single group (all data)
    idxGrps = {true(height(tblOut), 1)};
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPLY TRANSFORMATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for iVar = 1:length(processVars)
    varName = processVars{iVar};
    varData = tblOut.(varName);

    % ---------------------------------------
    % 1. Global Analysis (Log & Offset)
    % ---------------------------------------
    % Decisions for log transformation and offset must be made GLOBALLY
    % to ensure the variable remains consistent across groups.

    doLog = false;
    offsetVal = 0;

    if flgLog
        % Check skewness on the pooled data (ignoring NaNs)
        % Only consider positive skewness for log transform
        varDataClean = varData(~isnan(varData));
        if ~isempty(varDataClean)
            s = skewness(varDataClean);
            if s > skewThr 
                doLog = true;
            end
        end
    end
    
    % Assert non-zero (for positive variables) if explicitly asked, or if
    % log transform is needed
    if flg0 || flgLog
        % Calculate offset if zeros exist and we need to log or explicitly asked
        if any(varData == 0) && all(varData >= 0)
            c = min(varData(varData > 0)) / 2;
            varData = varData + c;
            if verbose
                fprintf('[%s] Adding Offset %.4f\n', varName, offsetVal);
            end
        end



    end

    if verbose
        if doLog, fprintf('[%s] Applying Log10 (Skew=%.2f)\n', varName, s); end
        if offsetVal > 0, fprintf('[%s] Adding Offset %.4f\n', varName, offsetVal); end
    end

    % Apply Global Transformations
    if offsetVal > 0
        varData = varData + offsetVal;
    end

    if doLog
        varData = log10(varData);
    end

    % Write back global changes before group-wise operations
    tblOut.(varName) = varData;

    % ---------------------------------------
    % 2. Group-wise Operations (Norm & Z)
    % ---------------------------------------

    for iGrp = 1:length(idxGrps)
        idxGrp = idxGrps{iGrp};
        varData = tblOut.(varName)(idxGrp);

        % Normalize relative to reference category
        if flgNorm
            % Find rows within this group that match the reference category of varNorm
            idxRef = tblOut.(varNorm) == catRef;
            idxRefGroup = idxGrp & idxRef;

            % Calculate the mean for the reference category within this group
            refMean = mean(tblOut.(varName)(idxRefGroup), 'all', 'omitnan');
            
            % Check for issues with reference mean
            if refMean == 0
                refMean = eps; % Avoid division by zero, result will be large
            end
            if isnan(refMean)
                warning('[%s] Group %d RefMean is NaN. Skipping norm.\n', ...
                    varName, iGrp);
                continue
            end
            
            % For values above reference, we want them to be >100%
            % For values below reference, we want them to be <100%
            varDiff = (varData - refMean) / abs(refMean);
            aboveRef = varData > refMean;
            normData = 100 + (aboveRef .* abs(varDiff) - ~aboveRef .* abs(varDiff)) * 100;

            % Update varData with normalized values
            varData = normData;
        end

        % Apply Z-scoring
        if flgZ
            varData = (varData - mean(varData, 'omitnan')) ./ std(varData, 'omitnan');
        end

        % Update the table column for this group
        tblOut.(varName)(idxGrp) = varData;
    end
end

end     % EOF

