function [hFig, tblRes] = lme_pr(mdl, vars, varargin)
% LME_PR Plots Partial Residuals (Added Variable Plot) for LME models.
%
%   [HFIG, TBLRES] = LME_PR(MDL, VARS, ...)
%
%   ASSUMPTIONS:
%       - VARS contains 1 or 2 variable names.
%       - If 2 variables are provided, the 2nd is assumed to be Categorical (Grouping).
%
%   INPUTS:
%       mdl         - (Required) Fitted LME object.
%       vars        - (Required) Cell array of 1 or 2 variable names.
%       varargin    - (Optional) 'hAx', 'clr', 'transParams', 'verbose'.
%
%   OUTPUTS:
%       hFig        - Figure handle.
%       tblRes      - Table with data and residuals.
%
%   See also: LME_ANALYSE, LME_FIT, TBL_TRANS

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'mdl');
addRequired(p, 'vars', @(x) ischar(x) || iscell(x));
addParameter(p, 'hAx', [], @(x) isempty(x) || isgraphics(x));
addParameter(p, 'clr', [], @(x) isempty(x) || isnumeric(x));
addParameter(p, 'transParams', [], @(x) isempty(x) || isstruct(x));
addParameter(p, 'verbose', true, @islogical);
parse(p, mdl, vars, varargin{:});

hAx         = p.Results.hAx;
clr         = p.Results.clr;
transParams = p.Results.transParams;
verbose     = p.Results.verbose;

%% ========================================================================
%  PREPARATION
%  ========================================================================

% Ensure vars is cell
if ischar(vars), vars = {vars}; end

% Identify Variables (Assumption: Var1=X, Var2=Group)
varX = vars{1};
if length(vars) == 2
    varGrp = vars{2};
else
    varGrp = [];
end

% Data & Groups
tblMdl = mdl.Variables;
if ~isempty(varGrp)
    [grpIds, grpNames] = findgroups(tblMdl.(varGrp));
    nGrps = length(grpNames);
else
    grpIds = ones(height(tblMdl), 1);
    grpNames = {'All'};
    nGrps = 1;
end

% Graphic Handles
if isempty(hAx)
    hFig = figure('Color', 'w', 'Name', 'Partial Residuals');
    hAx = axes('Parent', hFig);
else
    hFig = ancestor(hAx, 'figure');
end
hold(hAx, 'on');

% Colors
if isempty(clr)
    cfg = mcu_cfg();
    if nGrps == 2
        clr = cfg.clr.grp;
    else
        clr = lines(nGrps);
    end
end

%% ========================================================================
%  FIT REDUCED MODEL
%  ========================================================================

if verbose, fprintf('[LME_PR] Fitting reduced model...\n'); end

% Remove variables from formula
redFrml = char(mdl.Formula);
for iVar = 1:length(vars)
    redFrml = lme_frml2rmv(redFrml, vars{iVar});
end

% Fit & Residuals
dist = 'Normal';
if isa(mdl, 'GeneralizedLinearMixedModel')
    dist = mdl.Distribution;
end
mdlRed = lme_fit(tblMdl, redFrml, 'dist', dist);
tblMdl.Resid = residuals(mdlRed, 'ResidualType', 'Raw');

%% ========================================================================
%  FIT TREND LINES
%  ========================================================================
%  We fit y ~ x in the TRANSFORMED space, then back-transform the grid.

trends = struct();

for iVar = 1:nGrps
    grpIdx = (grpIds == iVar);
    xData = tblMdl.(varX)(grpIdx);
    yData = tblMdl.Resid(grpIdx);

    % Fit (only if numeric)
    lm = fitlm(xData, yData);

    % Predict on Grid (Transformed Space)
    xGrid = linspace(min(xData), max(xData), 100)';
    yGrid = predict(lm, xGrid);

    trends(iVar).xGrid = xGrid;
    trends(iVar).yGrid = yGrid;
end

%% ========================================================================
%  BACK TRANFORM
%  ========================================================================

if ~isempty(transParams)
    if verbose, fprintf('[LME_PR] Back-transforming...\n'); end

    % Data Points
    tblRes = tbl_trans(tblMdl, 'template', transParams, 'flgInv', true);

    % Trend Lines (Only X needs back-transform)
    if isfield(transParams.varsTrans, varX)
        for iVar = 1:nGrps
            tmpTbl = table(trends(iVar).xGrid, 'VariableNames', {varX});
            tmpTbl = tbl_trans(tmpTbl, 'template', transParams, 'varsInc', {varX}, 'flgInv', true);
            trends(iVar).xGrid = tmpTbl.(varX);
        end
    end
else
    tblRes = tblMdl;
end

%% ========================================================================
%  PLOT
%  ========================================================================

for iVar = 1:nGrps
    grpIdx = (grpIds == iVar);
    xData = tblRes.(varX)(grpIdx);
    yData = tblRes.Resid(grpIdx); 

    % Scatter
    if isnumeric(xData)
        scatter(hAx, xData, yData, 20, clr(iVar,:), 'filled', 'MarkerFaceAlpha', 0.4, ...
            'HandleVisibility', 'off');

        % Trend Line
        plot(hAx, trends(iVar).xGrid, trends(iVar).yGrid, '-', 'Color', clr(iVar,:), ...
            'LineWidth', 2, 'DisplayName', string(grpNames(iVar)));
    else
        % Categorical Jitter? Or just points.
        % If categorical, xData is categorical array.
        % We can just plot means usually, but scatter is nice.
        % Let's keep it simple as requested.

        % Mean Line
        plot(hAx, trends(iVar).xGrid, trends(iVar).yGrid, 'o-', 'Color', clr(iVar,:), ...
            'LineWidth', 2, 'MarkerFaceColor', 'w', 'DisplayName', string(grpNames(iVar)));
    end
end

% Decoration
xlabel(hAx, varX, 'Interpreter', 'none');
ylabel(hAx, sprintf('Residuals (%s | Reduced)', mdl.ResponseName), 'Interpreter', 'none');
grid(hAx, 'on');
title(hAx, 'Partial Residuals');

if nGrps > 1
    legend(hAx, 'Location', 'best', 'Interpreter', 'none');
end

% Log Scale check
if ~isempty(transParams) && isfield(transParams.varsTrans, varX) ...
        && isfield(transParams.varsTrans.(varX), 'logBase') ...
        && ~isempty(transParams.varsTrans.(varX).logBase)
    set(hAx, 'XScale', 'log');
end

end
