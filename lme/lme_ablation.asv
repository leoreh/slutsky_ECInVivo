function abl = lme_ablation(tbl, frml, varargin)
% LME_ABLATION Performs feature ablation analysis on a LME/GLME model.
%
%   RES = LME_ABLATION(TBL, FRML, ...)
%   Performs repeated cross-validation to rank feature importance by
%   iteratively removing predictors from the model formula and measuring the
%   drop in performance.
%
%   MODES:
%       - Classification (Binomial): Uses Balanced Accuracy & AUC.
%       - Regression (Continuous): Uses RMSE & R-Squared.
%
%   INPUTS:
%       tbl         - (table) Raw data table.
%       frml        - (char) Full model formula.
%       varargin    - (param/value) Optional parameters:
%                     'dist'    : Distribution (default auto-select).
%                     'nFolds'  : Number of CV folds (default 5).
%                     'nReps'   : Number of CV repetitions (default 5).
%                     'flgPlot' : Plot results (default true).
%                     'flgBkTrans : Back transform response before calculating metrics (default true).
%
%   OUTPUTS:
%       abl         - (struct) Results structure. Fields depend on Mode.
%
%   DEPENDENCIES:
%       lme_fit, lme_frml2vars, cvpartition.

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'tbl', @istable);
addRequired(p, 'frml', @ischar);
addParameter(p, 'dist', '', @ischar);
addParameter(p, 'nReps', 5, @isnumeric);
addParameter(p, 'flgPlot', true, @islogical);
addParameter(p, 'flgBkTrans', false, @islogical);
parse(p, tbl, frml, varargin{:});

dist = p.Results.dist;
nReps = p.Results.nReps;
flgPlot = p.Results.flgPlot;
flgBkTrans = p.Results.flgBkTrans;


%% ========================================================================
%  PREPARATION
%  ========================================================================

% Run LME_ANALYSE to prepare data and select distribution
fprintf('[LME_ABLATION] Running initial analysis to prepare data...\n');
[~, ~, lmeInfo, tblLme] = lme_analyse(tbl, frml, 'dist', dist);
abl.vif = lmeInfo.vif;

% Determine Mode
dist = lmeInfo.distSelected;
flgClass = strcmpi(dist, 'Binomial');
fprintf('[LME_ABLATION] Mode: %s (Dist: %s)\n', ...
    ij(flgClass, 'Classification', 'Regression'), dist);

% Extract variables
[varsFxd, varRsp, ~, varsIntr] = lme_frml2vars(frml);
vars = [{'None'}, varsFxd, varsIntr];


%% ========================================================================
%  PARTITIONING
%  ========================================================================

fprintf('[LME_ABLATION] Generating partitions...\n');
matTrn = get_partitions(tblLme, nReps, flgClass);

nTotal = size(matTrn, 2);
nCols  = length(vars);


%% ========================================================================
%  INITIALIZE STORAGE
%  ========================================================================

% Common
rocData = cell(nCols, 1);
xGrid   = linspace(0, 1, 100);

if flgClass
    % Classification Metrics
    matBACC = nan(nTotal, nCols);
    matAUC  = nan(nTotal, nCols);
    for iVar = 1:nCols
        rocData{iVar} = nan(nTotal, length(xGrid));
    end
else
    % Regression Metrics & Pooling
    rmse = nan(nTotal, nCols);
    r2   = nan(nTotal, nCols);
    sse  = nan(nTotal, nCols);
    sst  = nan(nTotal, nCols);
    foldSz    = nan(nTotal, 1);
end


%% ========================================================================
%  ABLATION LOOP
%  ========================================================================

fprintf('Starting Ablation (%d Iterations)...\n', nTotal);

for iRep = 1 : nTotal

    % Data Split
    trainIdx = matTrn(:, iRep);
    testIdx  = ~trainIdx;

    for iVar = 1 : nCols
        varRmv = vars{iVar};
        currFrml = lme_frml2rmv(frml, varRmv);

        % Train & Test
        [mdl, ~, infoTrn, tblTrn] = lme_analyse(tbl(trainIdx, :), currFrml, ...
            'dist', dist, 'verbose', false);

        % Prepare Test Data (Exact same transforms as Training)
        % tbl is raw input (original units). tblTrn is the transformed
        % data actually used by the model.
        tblTst = tbl(testIdx, :);
        tblTst = tbl_trans(tblTst, 'template', infoTrn.transParams);
        yTrue = tblTst.(varRsp);
        yPred = predict(mdl, tblTst);

        % Metrics
        if flgClass
            % --- CLASSIFICATION ---
            % Clean NaNs if fit failed
            if any(isnan(yPred))
                matBACC(iRep, iVar) = NaN;
                matAUC(iRep, iVar) = NaN;
                continue;
            end

            [x, y, T, aucCurr] = perfcurve(yTrue, yPred, 1);

            % Youden's Index for Optimal Threshold
            [~, idxJ] = max(y - x);
            optThresh = T(idxJ);
            yBin = double(yPred >= optThresh);

            % Balanced Accuracy
            sens = sum(yTrue==1 & yBin==1) / sum(yTrue==1);
            spec = sum(yTrue==0 & yBin==0) / sum(yTrue==0);

            matBACC(iRep, iVar) = mean([sens, spec]);
            matAUC(iRep, iVar)  = aucCurr;

            % Store ROC Interpolation
            [uX, idxUni] = unique(x);
            rocData{iVar}(iRep, :) = interp1(uX, y(idxUni), xGrid, ...
                'linear', 'extrap');

        else
            % --- REGRESSION ---

            % Null Model (Training Mean) for SST
            yTrn = tblTrn.(varRsp);

            % Back-transform if requested.
            if flgBkTrans
                pVar = infoTrn.transParams.varsTrans.(varRsp);
                if ~isempty(pVar) && ~isempty(pVar.logBase)

                    % yTrue and yTrn can be "naivey" re-transformed since they
                    % are exact values, not statistical estimates
                    c = pVar.offset;
                    yTrue = exp(yTrue) - c;
                    yTrn = exp(yTrn) - c;

                    % yPred is re-transformed using parametric or
                    % aparemtric correction. Since mdl.residuals is
                    % generated on conditional predictions, is do not
                    % contained random variance and thus we reclaculte
                    % residuals
                    yPred_trn = predict(mdl, tblTrn, 'Conditional', false);
                    yTrue_trn = tblTrn.(varRsp);
                    resMarg = yTrue_trn - yPred_trn;

                    % Parametric Correction (Log-Normal Assumption)
                    % correctionFct = exp(var(resMarg, 'omitnan') / 2);

                    % Aparemtric Correction (Duan's Smearing Estimator)
                    correctionFct = mean(exp(resMarg), 'omitnan');

                    % Adjusted Prediction
                    yPred = exp(yPred) .* correctionFct - c;

                end
            end

            muTrn = mean(yTrn, 'omitnan');

            % Sums
            sse(iRep, iVar) = sum((yTrue - yPred).^2, 'omitnan');
            sst(iRep, iVar) = sum((yTrue - muTrn).^2, 'omitnan');

            % Fold-wise RMSE
            rmse(iRep, iVar) = sqrt(mean((yTrue - yPred).^2, 'omitnan'));

            if iVar == 1
                foldSz(iRep) = sum(~isnan(yTrue));
            end
        end
    end

    % Dots
    if mod(iRep, 2) == 0, fprintf('.'); end
end
fprintf('\n');


%% ========================================================================
%  ORGANIZE
%  ========================================================================

abl.vars = vars;
abl.flgBkTrans = flgBkTrans;

if flgClass
    % --- CLASSIFICATION RESULTS ---
    abl.bacc = matBACC;
    abl.auc  = matAUC;
    abl.roc  = rocData;

    % Importance (% Drop)
    muBACC = mean(matBACC, 1, 'omitnan');
    muAUC  = mean(matAUC, 1, 'omitnan');

    abl.impBACC = (muBACC(1) - muBACC(2:end)) ./ muBACC(1) * 100;
    abl.impAUC  = (muAUC(1)  - muAUC(2:end))  ./ muAUC(1)  * 100;

else
    % --- REGRESSION RESULTS ---
    abl.rmse = rmse;
    abl.r2   = r2;
    abl.sse  = sse;
    abl.sst  = sst;
    abl.foldSz = foldSz;

    % Pooled Metrics
    sumSSE = sum(sse, 1, 'omitnan');
    sumSST = sum(sst, 1, 'omitnan');
    sumN   = sum(foldSz, 'omitnan');

    abl.pRMSE = sqrt(sumSSE ./ sumN);
    abl.pR2   = 1 - (sumSSE ./ sumSST);

    % Importance
    % RMSE (% Increase)
    abl.dRMSE = (abl.pRMSE(2:end) - abl.pRMSE(1)) ./ abl.pRMSE(1) * 100;

    % R2 (Difference)
    abl.dR2 = abl.pR2(1) - abl.pR2(2:end);

end


%% ========================================================================
%  PLOT
%  ========================================================================

if flgPlot
    if flgClass
        plot_ablationClass(abl);
    else
        plot_ablationReg(abl);
    end
end

end         % EOF



%% ========================================================================
%  HELPER: PLOT REGRESSION
%  ========================================================================
function plot_ablationReg(abl)

varsFxd = abl.vars(2:end);
nVars = length(varsFxd);

hFIg = figure('Color', 'w', 'Name', 'Ablation (Regression)', ...
    'Position', [100 100 1600 400]);
hTl = tiledlayout(1, 3, 'TileSpacing', 'compact', 'Padding', 'compact');

% Importance RMSE
nexttile;
bar(abl.dRMSE, 'FaceColor', 'k', 'FaceAlpha', 0.5);
xticks(1:nVars); xticklabels(varsFxd);
ylabel('% \Delta RMSE (%)');
title('Pooled RMSE');
grid on;

% Importance R2 (Raw Values + Baseline)
nexttile;
bar(abl.pR2, 'FaceColor', 'b', 'FaceAlpha', 0.5);
hold on;
yline(abl.pR2(1), 'k--', 'LineWidth', 1.5, 'Alpha', 0.6);

xticks(1:length(abl.vars)); xticklabels(abl.vars);
ylabel('R^2 (Pooled)');
title('Pooled R^2');
grid on;

% RMSE Distribution
nexttile;

foldSz = abl.foldSz;
nCols = size(abl.rmse, 2);

% Scale bubble sizes (min 20, max 100)
minSz = 20; maxSz = 100;
sz = (foldSz - min(foldSz(:))) ./ (max(foldSz(:)) - min(foldSz(:)));
sz = minSz + sz * (maxSz - minSz);

% Connect lines (light gray)
plot(1:nCols, abl.rmse', '-', 'Color', [0.7 0.7 0.7 0.3], 'LineWidth', 0.5);
hold on;

for iCol = 1:nCols
    % Jitter x-axis for visibility
    x = iCol + randn(size(abl.rmse, 1), 1) * 0.05;

    % Bubble Plot (Weighted by Fold Size)
    scatter(x, abl.rmse(:, iCol), sz(:, 1), 'filled', ...
        'MarkerFaceColor', [0 0.4470 0.7410], ...
        'MarkerFaceAlpha', 0.4);

    % Weighted Average Line
    plot([iCol-0.3, iCol+0.3], [abl.pRMSE(iCol), abl.pRMSE(iCol)], ...
        'k-', 'LineWidth', 2.5);
end

xticks(1:nCols); xticklabels(abl.vars);
if abl.flgBkTrans
    ylabel('RMSE (Hz)');
else
    ylabel('RMSE log(Hz)');
end
title('RMSE per Fold');
grid on;
xlim([0.5, nCols + 0.5]);

end

%% ========================================================================
%  HELPER: PLOT CLASSIFICATION
%  ========================================================================
function plot_ablationClass(abl)

varsFxd = abl.vars(2:end);
nVars = length(varsFxd);

figure('Color', 'w', 'Name', 'Ablation (Classification)', ...
    'Position', [100 100 1600 400]);
t = tiledlayout(1, 4, 'TileSpacing', 'compact', 'Padding', 'compact');

% 1. Importance BACC
nexttile;
mu = mean(abl.impBACC, 1, 'omitnan');
se = std(abl.impBACC, 0, 1, 'omitnan') ./ sqrt(size(abl.impBACC, 1));
bar(mu, 'FaceColor', 'k', 'FaceAlpha', 0.5); hold on;
errorbar(1:nVars, mu, se, 'k.', 'LineWidth', 1.5);
xticks(1:nVars); xticklabels(varsFxd);
ylabel('% \Delta BACC');
title('Importance (BACC)');
grid on;

% 2. Importance AUC
nexttile;
mu = mean(abl.impAUC, 1, 'omitnan');
se = std(abl.impAUC, 0, 1, 'omitnan') ./ sqrt(size(abl.impAUC, 1));
bar(mu, 'FaceColor', 'b', 'FaceAlpha', 0.5); hold on;
errorbar(1:nVars, mu, se, 'k.', 'LineWidth', 1.5);
xticks(1:nVars); xticklabels(varsFxd);
ylabel('% \Delta AUC');
title('Importance (AUC)');
grid on;

% 3. BACC Distribution
nexttile;
plot_dist(abl.bacc, abl.vars, 'BACC');

% 4. ROC Curves
nexttile;
hold on;
clrs = lines(nVars);
xGrid = linspace(0, 1, 100);

% Full
yMeanFull = mean(abl.roc{1}, 1, 'omitnan');
plot(xGrid, yMeanFull, 'k-', 'LineWidth', 3, 'DisplayName', 'Full');

for i = 1:nVars
    yMean = mean(abl.roc{i+1}, 1, 'omitnan');
    plot(xGrid, yMean, '-', 'Color', clrs(i, :), 'LineWidth', 1.5, ...
        'DisplayName', ['w/o ' varsFxd{i}]);
end
plot([0 1], [0 1], 'k:', 'HandleVisibility', 'off');
xlabel('FPR'); ylabel('TPR');
title('ROC Curves');
legend('Location', 'best');

end

%% ========================================================================
%  HELPER: PLOT DISTRIBUTION
%  ========================================================================
function plot_dist(data, labels, yLab)

nCols = size(data, 2);
plot(1:nCols, data', '-', 'Color', [0.7 0.7 0.7 0.3], 'LineWidth', 0.5);
hold on;

for iCol = 1:nCols
    x = iCol + randn(size(data,1), 1) * 0.05;
    scatter(x, data(:,iCol), 15, 'filled', 'MarkerFaceAlpha', 0.8);
    mu = mean(data(:,iCol), 'omitnan');
    plot([iCol-0.2, iCol+0.2], [mu, mu], 'k-', 'LineWidth', 2);
end
xticks(1:nCols); xticklabels(labels);
ylabel(yLab);
title(['Model Performance (' yLab ')']);
grid on;
xlim([0.5, nCols + 0.5]);

end

function val = ij(cond, t, f)
if cond, val = t; else, val = f; end
end


%% ========================================================================
%  HELPER: PARTITIONS
%  ========================================================================
function matTrn = get_partitions(tbl, nReps, flgClass)

hasName  = ismember('Name', tbl.Properties.VariableNames);
hasGroup = ismember('Group', tbl.Properties.VariableNames);

if hasName && hasGroup
    % Stratified Grouped Leave-One-Pair-Out
    [uNames, idxFirst] = unique(tbl.Name, 'stable');
    nameGrps = tbl.Group(idxFirst);
    uGrps = unique(nameGrps);

    grpSubjects = cell(numel(uGrps), 1);
    for iGrp = 1:numel(uGrps)
        grpSubjects{iGrp} = uNames(nameGrps == uGrps(iGrp));
    end

    % Cartesian Product
    combos = grpSubjects{1};
    for iGrp = 2:numel(uGrps)
        currSub = grpSubjects{iGrp};
        nOld = size(combos, 1);
        nNew = numel(currSub);

        tmpOld = repmat(combos, nNew, 1);
        tmpNew = repelem(currSub, nOld, 1);
        combos = [tmpOld, tmpNew];
    end

    nTotal = size(combos, 1);
    fprintf('[LME_ABLATION] Found %d unique test combinations.\n', nTotal);
    matTrn = true(height(tbl), nTotal);

    for iRep = 1 : nTotal
        matTrn(:, iRep) = ~ismember(tbl.Name, combos(iRep, :));
    end

else
    % Standard K-Fold
    nFolds = 5;
    nTotal = nReps * nFolds;
    matTrn = true(height(tbl), nTotal);

    cnt = 0;
    for iRep = 1 : nReps
        if flgClass
            cvp = cvpartition(tbl{:, 1}, 'KFold', nFolds);
        else
            cvp = cvpartition(height(tbl), 'KFold', nFolds);
        end
        for iFold = 1 : nFolds
            cnt = cnt + 1;
            matTrn(:, cnt) = training(cvp, iFold);
        end
    end
end

end