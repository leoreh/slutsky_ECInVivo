function res = lme_ablation(lmeTbl, frml, lmeCfg, varargin)
% LME_ABLATION Performs feature ablation analysis on a LME/GLME model.
%
%   RES = LME_ABLATION(LMETBL, FRML, LMECFG, ...)
%   Performs repeated cross-validation to rank feature importance by
%   iteratively removing predictors from the model formula and measuring the
%   drop in performance.
%
%   MODES:
%       - Classification (Binomial): Uses Balanced Accuracy & AUC.
%       - Regression (Continuous): Uses RMSE & R-Squared.
%
% INPUTS:
%   lmeTbl          (Required) Table: Pre-processed data (from LME_ANALYSE).
%   frml            (Required) Char: Full model formula.
%   lmeCfg          (Optional) Struct: Config from LME_ANALYSE (contains .distSelected).
%   ...             (Optional) Name-Value Pairs:
%                     'nFolds'  - Number of CV folds (default 5).
%                     'nReps'   - Number of CV repetitions (default 5).
%                     'flgPlot' - Plot results (default true).
%
% OUTPUTS:
%   res             Struct containing:
%                     .vars     - List of models (Full, No Var1, ...).
%                     .perfMat  - Matrix (nTotal x nCols) of primary metric (BACC or RMSE).
%                     .perfSec  - Matrix of secondary metric (AUC or R2).
%                     .impMat   - Delta Primary Metric (Full - Ablated).
%                     .vif      - Variance Inflation Factors.
%
% DEPENDENCIES:
%   lme_fit, lme_frml2vars, cvpartition.

%% ========================================================================
%  INPUT PARSING
%  ========================================================================
p = inputParser;
addRequired(p, 'lmeTbl', @istable);
addRequired(p, 'frml', @ischar);
addOptional(p, 'lmeCfg', struct());
addParameter(p, 'nFolds', 5, @isnumeric);
addParameter(p, 'nReps', 5, @isnumeric);
addParameter(p, 'flgPlot', true, @islogical);
parse(p, lmeTbl, frml, lmeCfg, varargin{:});

nFolds = p.Results.nFolds;
nReps = p.Results.nReps;
flgPlot = p.Results.flgPlot;

% Determine Distribution / Mode
if isfield(lmeCfg, 'distSelected') && ~isempty(lmeCfg.distSelected)
    dist = lmeCfg.distSelected;
elseif isfield(lmeCfg, 'distFinal') && ~isempty(lmeCfg.distFinal)
    dist = lmeCfg.distFinal;
elseif isfield(lmeCfg, 'dist') && ~isempty(lmeCfg.dist)
    dist = lmeCfg.dist;
else
    dist = 'Normal'; % Default fallback
    warning('Distribution not specified in lmeCfg. Defaulting to Normal.');
end

isBinomial = strcmpi(dist, 'Binomial');
if isBinomial
    metricPrim = 'Balanced Accuracy';
    metricSec  = 'AUC';
else
    metricPrim = 'RMSE';
    metricSec  = 'R-Squared';
end

fprintf('[LME_ABLATION] Mode: %s (Dist: %s)\n', ...
    ternary(isBinomial, 'Classification', 'Regression'), dist);


%% ========================================================================
%  PREPARATION
%  ========================================================================

% Extract variables from formula
[varsFxd, varRsp, varsRand] = lme_frml2vars(frml);

% Extract Random Effects String
if isempty(varsRand)
    randStr = '';
else
    randStr = [' + ' strjoin(varsRand, ' + ')];
end

% varsIter: [Full Model, No Var1, No Var2, ...]
varsIter = [{'None'}, varsFxd];

% Storage
nTotal = nReps * nFolds;
nCols  = length(varsIter);

res.vars   = varsIter;
res.perfPrim = nan(nTotal, nCols); % BACC or RMSE
res.perfSec  = nan(nTotal, nCols); % AUC or R2
res.roc    = cell(nCols, 1);     % ROC (Binomial only)
xGrid      = linspace(0, 1, 100); % Common grid for ROC

for iCol = 1:nCols
    res.roc{iCol} = nan(nTotal, length(xGrid));
end

% Initialize CV Partition
if isBinomial
    cvp = cvpartition(lmeTbl.(varRsp), 'KFold', nFolds, 'Stratify', true);
else
    cvp = cvpartition(height(lmeTbl), 'KFold', nFolds);
end


%% ========================================================================
%  VIF (COLLINEARITY)
%  ========================================================================

% Calculate VIF on transformed predictors
isNum = varfun(@isnumeric, lmeTbl(:, varsFxd), 'OutputFormat', 'uniform');
varsVif = varsFxd(isNum);

if isempty(varsVif)
    res.vif = table();
else
    X = table2array(lmeTbl(:, varsVif));
    R = corrcoef(X, 'Rows', 'pairwise');

    % Handle singular matrix
    if rcond(R) < 1e-12
        vifVal = nan(1, length(varsVif));
        warning('Predictors are perfectly collinear. VIF calculation skipped.');
    else
        vifVal = diag(inv(R))';
    end

    res.vif = table(varsVif(:), vifVal(:), 'VariableNames', {'Predictor', 'VIF'});
end


%% ========================================================================
%  ABLATION LOOP
%  ========================================================================

fprintf('Starting Ablation (%d Reps, %d Folds)...\n', nReps, nFolds);

cnt = 0;
for iRep = 1 : nReps

    if iRep > 1
        cvp = repartition(cvp);
    end

    for iFold = 1 : nFolds
        cnt = cnt + 1;

        trainIdx = training(cvp, iFold);
        testIdx  = test(cvp, iFold);

        tblTrn = lmeTbl(trainIdx, :);
        tblTst = lmeTbl(testIdx, :);
        yTrue  = tblTst.(varRsp);

        % Iterate Models
        for iVar = 1 : length(varsIter)

            varRem = varsIter{iVar};

            % Construct Formula
            varsCurr = varsFxd;
            if ~strcmp(varRem, 'None')
                varsCurr(strcmp(varsCurr, varRem)) = [];
            end

            if isempty(varsCurr)
                currFrml = sprintf('%s ~ 1%s', varRsp, randStr);
            else
                currFrml = sprintf('%s ~ %s%s', varRsp, strjoin(varsCurr, ' + '), randStr);
            end

            % Fit Model (Use lme_fit)
            % Suppress output logic inside lme_fit if possible or capture warnings
            try
                mdl = lme_fit(tblTrn, currFrml, 'dist', dist);
                yProb = predict(mdl, tblTst);

                if isBinomial
                    % --- CLASSIFICATION METRICS ---
                    [x, y, T, aucCurr] = perfcurve(yTrue, yProb, 1);

                    % Optimal Threshold (Youden)
                    J = y - x;
                    [~, idxJ] = max(J);
                    optThresh = T(idxJ);
                    yPred = double(yProb >= optThresh);

                    % Balanced Accuracy
                    tp = sum(yTrue == 1 & yPred == 1);
                    tn = sum(yTrue == 0 & yPred == 0);
                    sens = tp / max(sum(yTrue == 1), eps);
                    spec = tn / max(sum(yTrue == 0), eps);
                    valPrim = mean([sens, spec]); % BACC
                    valSec  = aucCurr;            % AUC

                    % ROC Interp
                    [uX, idxUni] = unique(x);
                    rocCurr = interp1(uX, y(idxUni), xGrid, 'linear', 'extrap');
                    res.roc{iVar}(cnt, :) = rocCurr;

                else
                    % --- REGRESSION METRICS ---
                    % RMSE
                    rmse = sqrt(mean((yTrue - yProb).^2));

                    % R-Squared
                    sst = sum((yTrue - mean(yTrue)).^2);
                    sse = sum((yTrue - yProb).^2);
                    r2 = 1 - (sse / sst);

                    valPrim = rmse;
                    valSec  = r2;
                end

            catch ME
                % Fail gracefully
                warning('Fit failed Rep %d Fold %d Var %s: %s', iRep, iFold, varRem, ME.message);
                valPrim = NaN;
                valSec = NaN;
            end

            % Store
            res.perfPrim(cnt, iVar) = valPrim;
            res.perfSec(cnt, iVar)  = valSec;
        end
        fprintf('.');
    end
    fprintf('\n');
end

% Calculate Deltas (Interpretation depends on metric)
% For BACC/AUC/R2: Higher is better -> Delta = Full - Reduced (Positive = Important)
% For RMSE: Lower is better -> Delta = Reduced - Full (Positive = Important, removing it increased error)

if strcmp(metricPrim, 'RMSE')
    % RMSE: Importance = Error(Reduced) - Error(Full)
    res.impPrim = res.perfPrim(:, 2:end) - res.perfPrim(:, 1);
else
    % BACC/AUC/R2: Importance = Score(Full) - Score(Reduced)
    res.impPrim = res.perfPrim(:, 1) - res.perfPrim(:, 2:end);
end

% Secondary Metric Deltas
if strcmp(metricSec, 'R-Squared') || strcmp(metricSec, 'AUC')
    res.impSec = res.perfSec(:, 1) - res.perfSec(:, 2:end);
else
    % Fallback
    res.impSec = res.perfSec(:, 1) - res.perfSec(:, 2:end);
end


%% ========================================================================
%  PLOTTING
%  ========================================================================
if flgPlot
    plot_ablation(res, metricPrim, metricSec, isBinomial);
end

end     % EOF


%% ========================================================================
%  HELPER: PLOTTING
%  ========================================================================
function plot_ablation(res, labPrim, labSec, isBinomial)

varsFxd = res.vars(2 : end);
nVars  = length(varsFxd);

figure('Color', 'w', 'Name', 'Feature Ablation', 'Position', [100 100 1200 400]);
t = tiledlayout(1, 3 + isBinomial, 'TileSpacing', 'compact', 'Padding', 'compact');

% 1. Primary Importance
nexttile;
muImp = mean(res.impPrim, 1, 'omitnan');
semImp = std(res.impPrim, 0, 1, 'omitnan') / sqrt(size(res.impPrim, 1));
bar(muImp, 'FaceColor', 'k', 'FaceAlpha', 0.5);
hold on;
errorbar(1:nVars, muImp, semImp, 'k.', 'LineWidth', 1.5);
xticks(1:nVars); xticklabels(varsFxd);
ylabel(['\Delta ' labPrim]);
title(['Importance (' labPrim ')']);
grid on;

% 2. Secondary Importance
nexttile;
muImpSec = mean(res.impSec, 1, 'omitnan');
semImpSec = std(res.impSec, 0, 1, 'omitnan') / sqrt(size(res.impSec, 1));
bar(muImpSec, 'FaceColor', 'b', 'FaceAlpha', 0.5);
hold on;
errorbar(1:nVars, muImpSec, semImpSec, 'k.', 'LineWidth', 1.5);
xticks(1:nVars); xticklabels(varsFxd);
ylabel(['\Delta ' labSec]);
title(['Importance (' labSec ')']);
grid on;

% 3. Model Comparison (Raw Values)
nexttile;
% Helper to plot raw comparisons
scatter_raw(res.perfPrim, res.vars, labPrim);

% 4. ROC (Binomial Only)
if isBinomial
    nexttile;
    hold on;
    clrs = lines(nVars);
    xGrid = linspace(0, 1, 100);

    % Full
    yMeanFull = mean(res.roc{1}, 1, 'omitnan');
    plot(xGrid, yMeanFull, 'k-', 'LineWidth', 3, 'DisplayName', 'Full');

    for i = 1:nVars
        yMeanRed = mean(res.roc{i+1}, 1, 'omitnan');
        plot(xGrid, yMeanRed, '-', 'Color', clrs(i,:), 'LineWidth', 1.5, ...
            'DisplayName', ['w/o ' varsFxd{i}]);
    end
    plot([0 1], [0 1], 'k:');
    xlabel('FPR'); ylabel('TPR');
    title('ROC Curves');
    legend('Location', 'best');
end

end

function scatter_raw(data, labels, ylab)
% Simple boxplot-like scatter
nCols = size(data, 2);
hold on;
for i = 1:nCols
    x = i + randn(size(data,1), 1) * 0.05;
    scatter(x, data(:,i), 15, 'filled', 'MarkerFaceAlpha', 0.3);
    plot([i-0.2, i+0.2], [mean(data(:,i)), mean(data(:,i))], 'k-', 'LineWidth', 2);
end
xticks(1:nCols); xticklabels(labels);
ylabel(ylab);
title('Model Performance');
grid on;
end

function out = ternary(cond, T, F), if cond, out = T; else, out = F; end, end