function hFig = mcu_rcvRes(tbl, varargin)
%   HFIG = MCU_RCVRES(TBL) performs a residual analysis to disentangle the
%   relationship between Burst and Single spike recovery, independent of
%   baseline firing rate and burstiness.
%
%   It compares two distinct perspectives in a 2x3 figure:
%       Rows:    Relative (Log-Fold), Absolute (SymLog Hz)
%       Columns: Allocation, Burst Prediction, Single Prediction
%
%   INPUTS:
%       tbl         - (table) Data table containing:
%                       'Group', 'Name', 'fr', 'pBspk'
%                       'frBspk', 'ss_frBspk', 'frSspk', 'ss_frSspk'
%                       'pBspk_trans' (Logit transformed burstiness)
%                       
%   OPTIONAL (Key-Value):
%       'flgPlot'   - (logical) Whether to generate the figure. {Default: true}
%
%   OUTPUTS:
%       hFig        - (handle) Figure handle.
%

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'tbl', @istable);
addParameter(p, 'flgPlot', true, @islogical);
parse(p, tbl, varargin{:});

flgPlot = p.Results.flgPlot;
hFig = [];

% Ensure required columns exist
reqVars = {'Group', 'Name', 'fr', 'pBspk', ...
           'frBspk', 'ss_frBspk', 'frSspk', 'ss_frSspk'};
if ~all(ismember(reqVars, tbl.Properties.VariableNames))
    error('[MCU_RCVRES] Missing required variables in table.');
end

%% ========================================================================
%  CALCULATE METRICS
%  ========================================================================

% Pseudocount for Log Ratios (1 spike / hour)
c = 1 / 3600;

% --- Relative Growth (Log Fold Change) ---
tbl.dBrst_rel = log((tbl.ss_frBspk + c) ./ (tbl.frBspk + c));
tbl.dSngl_rel = log((tbl.ss_frSspk + c) ./ (tbl.frSspk + c));

% --- Absolute Growth (SymLog Delta Hz) ---
tbl.dBrst_abs = tbl.ss_frBspk - tbl.frBspk;
tbl.dSngl_abs = tbl.ss_frSspk - tbl.frSspk;


%% ========================================================================
%  ALLOCATION ANALYSIS 
%  ========================================================================
%  Regress out Baseline Firing Rate (fr) and Burstiness (pBspk) to see
%  the underlying correlation between Burst and Single changes.

fprintf('[MCU_RCVRES] Calculating Allocation Residuals...\n');

frmlBase = ' ~ (pBspk + fr) * Group + (1|Name)';

% Relative
mdl = lme_analyse(tbl, ['dBrst_rel' frmlBase], 'dist', 'normal', 'verbose', false);
tbl.R_dBrst_rel = residuals(mdl, 'ResidualType', 'Pearson');

mdl = lme_analyse(tbl, ['dSngl_rel' frmlBase], 'dist', 'normal', 'verbose', false);
tbl.R_dSngl_rel = residuals(mdl, 'ResidualType', 'Pearson');

% Absolute
mdl = lme_analyse(tbl, ['dBrst_abs' frmlBase], 'dist', 'normal', 'verbose', false);
tbl.R_dBrst_abs = residuals(mdl, 'ResidualType', 'Pearson');

mdl = lme_analyse(tbl, ['dSngl_abs' frmlBase], 'dist', 'normal', 'verbose', false);
tbl.R_dSngl_abs = residuals(mdl, 'ResidualType', 'Pearson');


%% ========================================================================
%  PREDICTION ANALYSIS
%  ========================================================================
%  Does Baseline Burstiness (pBspk) predict the deviation from the 
%  standard plasticity rule? Regress out the "Other" component.

fprintf('[MCU_RCVRES] Calculating Prediction Residuals...\n');

% --- Relative ---
% Burst (Control for Single)
frml_Brst = ' ~ (fr + dSngl_rel) * Group + (1|Name)';
mdl = lme_analyse(tbl, ['dBrst_rel' frml_Brst], 'dist', 'normal', 'verbose', false);
tbl.P_dBrst_rel = residuals(mdl, 'ResidualType', 'Pearson');

% Single (Control for Burst)
frml_Sngl = ' ~ (fr + dBrst_rel) * Group + (1|Name)';
mdl = lme_analyse(tbl, ['dSngl_rel' frml_Sngl], 'dist', 'normal', 'verbose', false);
tbl.P_dSngl_rel = residuals(mdl, 'ResidualType', 'Pearson');

% --- Absolute ---
% Burst (Control for Single)
frml_Brst = ' ~ (fr + dSngl_abs) * Group + (1|Name)';
mdl = lme_analyse(tbl, ['dBrst_abs' frml_Brst], 'dist', 'normal', 'verbose', false);
tbl.P_dBrst_abs = residuals(mdl, 'ResidualType', 'Pearson');

% Single (Control for Burst)
frml_Sngl = ' ~ (fr + dBrst_abs) * Group + (1|Name)';
mdl = lme_analyse(tbl, ['dSngl_abs' frml_Sngl], 'dist', 'normal', 'verbose', false);
tbl.P_dSngl_abs = residuals(mdl, 'ResidualType', 'Pearson');


%% ========================================================================
%  PLOTTING
%  ========================================================================

if ~flgPlot
    return;
end

hFig = figure('Color', 'w', 'Name', 'Recovery: Allocation & Prediction');
hTile = tiledlayout(2, 3, 'TileSpacing', 'compact', 'Padding', 'compact');

% Definitions for Loop (Values correspond to suffixes of calculated table vars)
rowDefs = {
    'Relative', 'dBrst_rel',    'dSngl_rel';
    'Absolute', 'dBrst_abs',    'dSngl_abs'
};

for iRow = 1:2
    typeStr = rowDefs{iRow, 1};
    sufB = rowDefs{iRow, 2}; % Suffix Burst
    sufS = rowDefs{iRow, 3}; % Suffix Single
    
    % --- 1. Allocation (Burst vs Single) ---
    nexttile; hold on;
    title([typeStr ' Allocation']);
    
    xVar = ['R_' sufB];
    yVar = ['R_' sufS];
    
    % Reference Lines
    lims = max(abs([tbl.(xVar); tbl.(yVar)])) * 1.1;
    plot([-lims, lims], [-lims, lims], '--k', 'HandleVisibility', 'off'); % Identity
    xline(0, '-', 'Color', [0.8 0.8 0.8], 'HandleVisibility', 'off');
    yline(0, '-', 'Color', [0.8 0.8 0.8], 'HandleVisibility', 'off');
    
    plot_grpScatter(tbl, xVar, yVar, 'ortho', lims);

    if strcmpi(typeStr, 'Absolute')
        symlog(gca, 'xy');
    end
   
    xlim([-lims, lims]); ylim([-lims, lims]);
    xlabel('Burst Residuals'); ylabel('Single Residuals');
    
    % --- 2. Burst Prediction ---
    nexttile; hold on;
    title([typeStr ' Burst Recovery']);
    
    yVar = ['P_' sufB];
    xVar = 'pBspk_trans';
    
    yline(0, '-', 'Color', [0.8 0.8 0.8], 'HandleVisibility', 'off');
    
    plot_grpScatter(tbl, xVar, yVar, 'ortho', []);
    
    if strcmpi(typeStr, 'Absolute')
        symlog(gca, 'y');
    end

    xlabel('Baseline Burstiness'); ylabel('Burst Residuals');
    
    
    % --- 3. Single Prediction ---
    nexttile; hold on;
    title([typeStr ' Single Recovery']);
    
    yVar = ['P_' sufS];
    xVar = 'pBspk_trans';
    
    yline(0, '-', 'Color', [0.8 0.8 0.8], 'HandleVisibility', 'off');
    
    plot_grpScatter(tbl, xVar, yVar, 'ortho', []);
    
    if strcmpi(typeStr, 'Absolute')
        symlog(gca, 'y');
    end
    
    xlabel('Baseline Burstiness'); ylabel('Single Residuals');
end

end

%% ========================================================================
%  HELPER FUNCTIONS
%  ========================================================================

function plot_grpScatter(tbl, xVar, yVar, regType, lims)
    % PLOT_GRPSCATTER Helper for common grouping scatter/regression logic
    
    cfg = mcu_cfg;
    clr = cfg.clr.grp;
    groups = unique(tbl.Group);
    alphaVal = 0.4;
    
    axis square;
    
    for iGrp = 1:length(groups)
        idx = tbl.Group == groups(iGrp);
        x = tbl.(xVar)(idx); 
        y = tbl.(yVar)(idx);
        c = clr(iGrp, :);
        
        % Scatter
        scatter(x, y, 20, c, 'filled', 'MarkerFaceAlpha', alphaVal, ...
            'MarkerEdgeColor', 'none', 'HandleVisibility', 'off');
            
        % Regression
        Stats = plot_linReg(x, y, 'hAx', gca, 'type', regType, ...
            'clr', c, 'flgTxt', false);
            
        % Annotation
        if strcmpi(regType, 'ortho') && ~isnan(Stats.slope) && ~isempty(lims)
            % Orthogonal: Show Angle
            txtX = -lims * 0.9;
            txtY = lims * (0.8 - (iGrp-1)*0.15);
            text(txtX, txtY, sprintf('%s: %.2f (%.0f\\circ)', ...
                char(groups(iGrp)), Stats.slope, Stats.angle), ...
                'Color', c, 'FontSize', 8, 'FontWeight', 'bold');
                
        elseif strcmpi(regType, 'linear') && ~isnan(Stats.pVal)
            % Linear: Show P-Value
            xL = xlim; yL = ylim;
            txtX = xL(2) * 0.5;
            txtY = yL(2) * (0.9 - (iGrp-1)*0.12);
            text(txtX, txtY, sprintf('b=%.2f, p=%.3f', Stats.slope, Stats.pVal), ...
                'Color', c, 'FontSize', 8, 'FontWeight', 'bold');
        end
    end
end
