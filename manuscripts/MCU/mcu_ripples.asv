

%% ========================================================================
%  RE-ANALYZE
%  ========================================================================

% run the analysis on multiple sessions
% -------------------------------------------------------------------------
% basepaths = mcu_basepaths('all');
basepaths = [mcu_basepaths('wt_bsl_ripp'), mcu_basepaths('mcu_bsl')];
nFiles = length(basepaths);

for iFile = 1 : nFiles
    basepath = basepaths{iFile};
    cd(basepath)
    [~, basename] = fileparts(basepath);
    tic
    ripp = ripp_wrapper('basepath', pwd, ...
        'win', [0 6] * 3600, ...
        'rippCh', [], ...
        'flgPlot', false, ...
        'flgSave', true, ...
        'flgSaveFig', true);
    toc
end




%% ========================================================================
%  LOAD TABLE
%  ========================================================================

% RIPPLE SPIKES
basepaths = [mcu_basepaths('wt_bsl_ripp'), mcu_basepaths('mcu_bsl')];
nFiles = length(basepaths);

presets = {'rippSpks'};
tbl = mcu_tblVivo('basepaths', basepaths, 'presets', presets);

% Plot
tblPlot = tbl(tbl.UnitType == 'RS', :);
tblGUI_bar(tbl, 'xVar', 'Group', 'yVar', 'rippMRL');
tblGUI_scatHist(tblPlot, 'xVar', 'rippMos', 'yVar', 'rippGain', 'grpVar', 'Group');


% RIPPLE PARAMS
basepaths = [mcu_basepaths('wt_bsl_ripp'), mcu_basepaths('mcu_bsl')];
nFiles = length(basepaths);

presets = {'ripp'};
tbl = mcu_tblVivo('basepaths', basepaths, 'presets', presets);

% Plot
tblGUI_bar(tbl, 'xVar', 'Group', 'yVar', 'dur');
tblGUI_scatHist(tbl, 'xVar', 'dur', 'yVar', 'peakAmp', 'grpVar', 'Group');




%% ========================================================================
%  LOAD RIPP STRUCTS
%  ========================================================================

grps = {'wt_bsl_ripp'; 'mcu_bsl'};
vars = {'ripp', 'units', 'session'};
for iGrp = 1 : length(grps)
    basepaths = mcu_basepaths(grps{iGrp});
    vRipp{iGrp} = basepaths2vars('basepaths', basepaths, 'vars', vars);
end


%% ========================================================================
%  RIPPLE PARAMETERS (Per Ripple)
%  ========================================================================

% Organize data table
cfg = mcu_cfg();
clear varMap
varMap.peakFreq = 'peakFreq';
varMap.peakAmp = 'peakAmp';
varMap.dur = 'dur';
varMap.peakFilt = 'peakFilt';
varMap.peakPower = 'peakPower';
varMap.peakEnergy = 'peakEnergy';
varMap.peakRng = 'peakRng';
varMap.idxNREM = 'states.idx';

for iGrp = 1 : length(grps)
    basepaths = mcu_basepaths(grps{iGrp});

    % Prepare tag structures for this mouse
    tagAll.Group = cfg.lbl.grp{iGrp};
    tagFiles.Name = get_mname(basepaths);

    % Create table
    tblCell{iGrp} = v2tbl('v', [vRipp{iGrp}(:).ripp], 'varMap', varMap, ...
        'tagFiles', tagFiles, 'tagAll', tagAll, 'idxCol', 4);
end
% Combine all tables, clean and organize
tblLme = vertcat(tblCell{:});
tblLme = rmmissing(tblLme);
tblLme.Group = reordercats(tblLme.Group, cfg.lbl.grp);

% Hard code exclusion of weak ripples, validated by manual inspection
idxBad = tblLme.peakAmp <= 8;
tblLme(idxBad, :) = [];

% Include only ripples that occured during NREM
idxBad = tblLme.idxNREM == 0;
tblLme(idxBad, :) = [];

% Plot
hFig = tblGUI_scatHist(tblLme);

% -------------------------------------------------------------------------

% Variables
lblY = {'Peak Frequency (Hz)', 'Peak Amplitude (µV)', 'Duration (ms)',...
    'Peak Energy (µV²)'};
varRsp = {'peakFreq', 'peakAmp', 'dur', 'peakEnergy', 'Rate'};
idxVar = 3;

% Run LME
frml = [varRsp{idxVar}, ' ~ Group + (1|Name)'];
[lmeMdl, lmeStats, lmeInfo] = lme_analyse(tblLme, frml);

% Plot
tblGUI_bar(tblLme, 'yVar', varRsp{idxVar});
tblGUI_scatHist(tblLme, 'xVar', 'peakEnergy', 'yVar', 'Duration', 'grpVar', 'Group');


% Prism
[prismMat] = tbl2prism(tblLme, 'yVar', varRsp{idxVar});


%% ========================================================================
%  RIPPLE RATE / DENSITY (Per NREM Bout)
%  ========================================================================

% Pre-process: extract NREM rate (state 4) to a dedicated field
for iGrp = 1:length(v)
    for iFile = 1:length(v{iGrp})
        % Check if states analysis exists and has NREM (state 4)
        v{iGrp}(iFile).ripp.rateNrem = v{iGrp}(iFile).ripp.states.rate{4};
        v{iGrp}(iFile).ripp.densNrem = v{iGrp}(iFile).ripp.states.density{4};
    end
end

% Organize table
cfg = mcu_cfg();
clear varMap
varMap.Rate = 'rateNrem';
varMap.Density = 'densNrem';

for iGrp = 1 : length(grps)
    basepaths = mcu_basepaths(grps{iGrp});

    % Prepare tag structures for this mouse
    tagAll.Group = cfg.lbl.grp{iGrp};
    tagFiles.Name = get_mname(basepaths);

    % Create table
    tblCell{iGrp} = v2tbl('v', [v{iGrp}(:).ripp], 'varMap', varMap, ...
        'tagFiles', tagFiles, 'tagAll', tagAll, 'idxCol', 1);
end
% Combine all tables, clean and organize
tblLme = vertcat(tblCell{:});
tblLme = rmmissing(tblLme);
tblLme.Group = reordercats(tblLme.Group, cfg.lbl.grp);

% Assert non-zero
tblLme = tbl_trans(tblLme, 'flg0', true, 'verbose', true);


% -------------------------------------------------------------------------
% Run analysis


% Variables
lblY = {'Rate (SWR/s)', 'Density (% NREM)'};
varRsp = {'Rate', 'Density'};
idxVar = 1;

% Formula
frml = [varRsp{idxVar}, ' ~ Group + (1|Name)'];

% Check best model
% statsPark = lme_parkTest(tblLme, frml);
% statsDist = lme_compareDists(tblLme, frml);

% Run LME
cfgLme.contrasts = 'all';
cfgLme.dist = 'Normal';
[lmeStats, lmeMdl] = lme_analyse(tblLme, frml, cfgLme);

% Plot
hFig = tblGUI_bar(tblLme, 'yVar', varRsp{idxVar});

% Prism
[prismMat] = tbl2prism(tblLme, 'yVar', varRsp{idxVar});



%% ========================================================================
%  RIPPLE SPIKES (Per Unit)
%  ========================================================================

% Organize data table
% Pre-process: extract NREM firing rates to dedicated fields
for iGrp = 1:length(v)
    for iFile = 1:length(v{iGrp})
        % Get data
        ripp = v{iGrp}(iFile).ripp;

        % Get NREM state index (state 4)
        idxNrem = ripp.states.idx(:, 4);

        % Calculate mean rates Restricted to NREM
        rippRates = ripp.spks.su.rippRates(:, idxNrem);
        ctrlRates = ripp.spks.su.ctrlRates(:, idxNrem);

        v{iGrp}(iFile).ripp.spks.su.FRripp = mean(rippRates, 2, 'omitnan');
        v{iGrp}(iFile).ripp.spks.su.FRrand = mean(ctrlRates, 2, 'omitnan');
    end
end

[cfg] = mcu_cfg();
clear varMap
varMap.UnitType = 'units.type';
varMap.frMod = 'ripp.spks.su.frModulation';
varMap.FRripp = 'ripp.spks.su.FRripp';
varMap.FRrand = 'ripp.spks.su.FRrand';
varMap.MRL = 'ripp.spkLfp.phase.mrl';
varMap.pVal = 'ripp.spkLfp.phase.pVal';
varMap.Theta = 'ripp.spkLfp.phase.theta';

for iGrp = 1 : length(grps)
    basepaths = mcu_basepaths(grps{iGrp});

    % Prepare tag structures for this mouse
    tagAll.Group = cfg.lbl.grp{iGrp};
    tagFiles.Name = get_mname(basepaths);

    % Create table
    tblCell{iGrp} = v2tbl('v', v{iGrp}, 'varMap', varMap, ...
        'tagFiles', tagFiles, 'tagAll', tagAll, 'idxCol', 1);
end
% Combine all tables, clean and organize
tblLme = vertcat(tblCell{:});

% Assert category order
tblLme.Group = reordercats(tblLme.Group, cfg.lbl.grp);
tblLme.UnitType = reordercats(tblLme.UnitType, cfg.lbl.unit);

% Remove bad units
tblLme(tblLme.UnitType == 'Other', :) = [];
tblLme.UnitType = removecats(tblLme.UnitType, 'Other');
% CONSIDER:
%  - REMOVING FS
%  - GLME DIRECTLY ON FRs WITH NEW FIXED EFFECT - EVENTTYPE

% Assert non-zero for mrl (fr modulation included negative values by
% definition)
tblLme = tbl_trans(tblLme, 'flg0', true, 'verbose', true, ...
    'varsInc', {'MRL'});

% Plot
hFig = tblGUI_scatHist(tblLme);

% -------------------------------------------------------------------------
% LME

% Variables
lblY = {'Mean Resultant Length', 'FR Modulation (a.u.)'};
varRsp = {'MRL', 'frMod'};
idxVar = 2;

% Formula
frml = [varRsp{idxVar}, ' ~ Group * UnitType + (1|Name)'];

% Check best model
% statsPark = lme_parkTest(tblLme, frml)
% statsDist = lme_compareDists(tblLme, frml)

% Run LME
cfgLme.dist = 'Normal';
[lmeStats, lmeMdl] = lme_analyse(tblLme, frml, cfgLme);

% Plot
hFig = tblGUI_bar(tblLme, 'yVar', varRsp{idxVar}, 'xVar', 'UnitType', ...
    'grpVar', 'Group');

% Prism
idxRow = tblLme.UnitType == 'RS' & tblLme.Group == 'Control';
[tblLme.FRripp(idxRow, :), tblLme.FRrand(idxRow, :)];



%% ========================================================================
%  POLAR PLOT
%  ========================================================================

% Figure Parameters
hFig = figure;
fntSize = 16; FntName = 'Arial';
txtUnit = cfg.lbl.unit;
txtGrp = cfg.lbl.grp;

% Plot each group
nGrp = length(grps);
iUnit = 1;
for iGrp = 1 : nGrp
    % Get specific data from table
    idxUnit = tblLme.UnitType == categorical(txtUnit(iUnit));
    idxGrp = tblLme.Group == categorical(txtGrp(iGrp));
    idxSgn = tblLme.pVal < 0.05;
    idxTbl = idxUnit & idxGrp & idxSgn;
    grpTbl = tblLme(idxTbl, :);

    % Plot units, colored by type if population info is available.
    hPlt = polarscatter(grpTbl.Theta, grpTbl.MRL, 50, ...
        cfg.clr.grp(iGrp, :), 'filled', ...
        'MarkerFaceAlpha', 0.3);
    hold on;
end
rlim([0 0.6])
rticks(0 : 0.3 : 1)
thetaticks(0:90:270)
hAx = gca;
hAx.ThetaAxisUnits = 'degrees';
hAx.GridAlpha = 0.2;
legend(txtGrp, 'Location', 'northwest', 'Interpreter', 'none');
set(hAx, 'FontName', 'Arial', 'FontSize', fntSize);
set(hFig, 'Color', 'w');

% Assert Size
plot_axSize('hFig', hFig, 'szOnly', true, 'axShape', 'square', 'axHeight', 300);

% Save
fname = ['Ripp~SpkPolar_', txtUnit{iUnit}];
lme_save('hFig', hFig, 'fname', fname, 'frmt', {'svg', 'mat'});



%% ========================================================================
%  RIPPLE LFP TRACES
%  ========================================================================
%  NOTE: SEM is across mice (not individual ripples)

% Stores matrices of ripple LFP traces for each group
nGrp = length(grps);
lfpGrp = cell(1, nGrp);

% Process data for each group
for iGrp = 1:nGrp
    nMice = length(v{iGrp});
    lfpMap = cell(nMice, 1);

    for iMouse = 1:nMice
        mData = v{iGrp}(iMouse);
        ripp = mData.ripp;

        % Select NREM ripples
        idxNREM = ripp.states.idx(:, 4);

        % Select ripp based on peakAmp
        idxAmp = ripp.peakAmp > 8;

        % Get mean ripple LFP trace
        idxGood = idxNREM & idxAmp;
        lfpMap{iMouse} = mean(ripp.maps.raw(idxGood, :), 1, 'omitnan');
    end
    lfpGrp{iGrp} = cell2padmat(lfpMap, 1);
end

% Get time bins
mapDur = ripp.spks.info.mapDur * 1000;
nBinsMap = ripp.spks.info.nBinsMap;
timeBins = linspace(mapDur(1), mapDur(2), nBinsMap);

% initialize
[cfg] = mcu_cfg();
clr = cfg.clr;
[hFig, hAx] = plot_axSize('szOnly', false);

% Plot each group in reverse order so Control appears on top
txtLgd = cell(nGrp,1);
clear hPlt
for iGrp = nGrp : -1 : 1 % Use a different loop variable
    hPlt(iGrp) = plot_stdShade('hAx', hAx, 'dataMat', lfpGrp{iGrp},...
        'alpha', 0.3, 'clr', clr.grp(iGrp, :), 'xVal', timeBins);
    hPlt(iGrp).DisplayName = cfg.lbl.grp{iGrp}; % Assign DisplayName for legend
end

% Graphics
xline(hAx, 0, '--k');
ylabel(hAx, 'LFP (µV)')
xlabel(hAx, 'Time (ms)')
xlim(hAx, [-50 50])
ylim(hAx, [-45, 45])
legend(hPlt, cfg.lbl.grp, 'Location', 'southwest');
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'square');

% Save
fname = 'Ripp~LFP Trace';
lme_save('hFig', hFig, 'fname', fname, 'frmt', {'svg', 'mat'});

% Prism
xVal = timeBins;
iGrp = 2;
prismMat = [mean(lfpGrp{iGrp}, 1, 'omitnan')', ...
    std(lfpGrp{iGrp}, 1, 'omitnan')', ...
    repmat(size(lfpGrp{iGrp}, 1), length(xVal), 1)];



%% ========================================================================
%  RIPPLE PETH
%  ========================================================================
% Create a mean normalized SU PETH for RS and FS units from all mice of
% a group and create a figure the superimposes WT and MCU-KO (separately
% for RS and FS units.

normMet = 'zscore';        % 'max', 'ctrl', 'none', 'zscore', 'modulation'

% Stores matrices of unit-normalized PETHs for each group
normGrp = cell(1, length(grps));
unitGrp = cell(1, length(grps));

% Process data for each group
for iGrp = 1:length(grps)

    nMice = length(v{iGrp});
    normMap = cell(nMice, 1);
    unitData = cell(nMice, 1);

    for iMouse = 1:nMice
        mData = v{iGrp}(iMouse);
        ripp = mData.ripp;
        units = mData.units;

        % Calculate mean PETH per unit
        rippMap = squeeze(mean(ripp.spks.su.rippMap, 2, 'omitnan'));
        ctrlMap = squeeze(mean(ripp.spks.su.ctrlMap, 2, 'omitnan'));

        % Calculate unit FR params
        ctrlAvg = mean(ctrlMap, 2, 'omitnan');

        % Use std of per-trial control rates for z-scoring
        ctrlRates = mean(ripp.spks.su.ctrlMap, 3, 'omitnan');
        ctrlSD = std(ctrlRates, [], 2, 'omitnan');
        ctrlSD(ctrlSD == 0) = 1; % Avoid division by zero

        rippMax = max(rippMap, [], 2);
        rippMax(rippMax == 0) = 1;

        % normalize
        switch normMet
            case 'max'
                normData = rippMap ./ rippMax;
            case 'ctrl'
                normData = rippMap ./ ctrlAvg; % ctrlAvg might be zero for some units
            case 'zscore'
                normData = (rippMap - ctrlAvg) ./ ctrlSD;
            case 'modulation'
                normData = (rippMap - ctrlAvg) ./ (rippMap + ctrlAvg);
            case 'none'
                normData = rippMap;
        end

        % Collect PETHs
        normMap{iMouse} = normData;

        % get unit data
        nUnits = size(normData, 1);
        unitIdx = nan(nUnits, 1);
        unitIdx(units.clean(1, :)) = 1;
        unitIdx(units.clean(2, :)) = 2;
        unitData{iMouse} = unitIdx;
    end
    normGrp{iGrp} = cell2padmat(normMap, 1);
    unitGrp{iGrp} = cell2padmat(unitData, 1);
end

% Get time bins
mapDur = ripp.spks.info.mapDur * 1000;
nBinsMap = ripp.spks.info.nBinsMap;
timeBins = linspace(mapDur(1), mapDur(2), nBinsMap);

% Figure Parameters
cfg = mcu_cfg();
clr = cfg.clr;
fntSize = 16;
txtUnit = {'RS', 'FS'};
txtGrp = {'Control', 'MCU-KO'};

% initialize
[hFig, hAx] = plot_axSize('szOnly', false);

% Plot each group
nGrp = length(grps);
iUnit = 1;
hAx = gca; cla; hold on
set(hAx, 'FontName', 'Arial', 'FontSize', fntSize);

% Plot each group in reverse order so Control appears on top
txtLgd = cell(nGrp,1);
clear hPlt
flgRvrs = false;
if flgRvrs
    grpOrdr = nGrp : -1 : 1;
else
    grpOrdr = 1 : nGrp;
end
for iGrp = grpOrdr
    % Get data for current unit type and group
    unitIdx = unitGrp{iGrp} == iUnit;
    pethData = normGrp{iGrp}(unitIdx, :);

    hPlt(iGrp) = plot_stdShade('hAx', hAx, 'dataMat', pethData,...
        'alpha', 0.3, 'clr', clr.grp(iGrp, :), 'xVal', timeBins);
    hPlt(iGrp).DisplayName = txtGrp{iGrp}; % Assign DisplayName for legend
    txtLgd{iGrp} = txtGrp{iGrp};
end

% Add zero line
xline(hAx, 0, '--k');

% Update labels
ylabel(hAx, 'Norm. FR (z-score)')
xlabel(hAx, 'Time (ms)')
title(hAx, txtUnit{iUnit})

% Set limits
% ylim(hAx, [-0.5, 0.5])
xlim(hAx, [-75 75])
legend(hPlt, txtLgd, 'Location', 'northwest',...
    'FontName', 'Arial', 'FontSize', fntSize);

% Assert Size
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'square');

% Save
fname = ['Ripp~FR_', txtUnit{iUnit}];
lme_save('hFig', hFig, 'fname', fname, 'frmt', {'svg', 'mat'});

% Prism
xVal = timeBins;
iGrp = 2;
unitIdx = unitGrp{iGrp} == iUnit;
pethData = normGrp{iGrp}(unitIdx, :);
prismMat = [mean(pethData, 1, 'omitnan')', ...
    std(pethData, 1, 'omitnan')', ...
    repmat(size(pethData, 1), length(xVal), 1)];







%% ========================================================================
%  RATE-PHASE MAP
%  ========================================================================

% Select
flgCbar = false;
iGrp = 1;
iUnit = 1;

% get map data
nSgn = nan(2, 2);
prctSgn = nan(2, 2);
nMice = length(v{iGrp});
mapData = cell(nMice, 1);
for iMouse = 1 : nMice
    ripp = v{iGrp}(iMouse).ripp;
    mapData{iMouse} = ripp.spkLfp.rateMap.rate;
end
mapData = cell2padmat(mapData, 3);
rateMap = ripp.spkLfp.rateMap;

% get unit indices
idxGrp = tblLme.Group == categorical(txtGrp(iGrp));
grpTbl = tblLme(idxGrp, :);
idxUnit = grpTbl.UnitType == categorical(txtUnit(iUnit));
idxSgn = grpTbl.pVal < 0.05;
idxMap = idxUnit & idxSgn;

% store number of significant units
nSgn(iGrp, iUnit) = sum(idxUnit & idxSgn);
prctSgn(iGrp, iUnit) = sum(idxUnit & idxSgn) / sum(idxUnit) * 100;

% Plot Mean Power-Phase Rate Map (averaged across cells).
% This 2D heatmap shows the average firing rate of neurons as a function of
% LFP phase (x-axis) and LFP power (y-axis). The phase axis is duplicated
% (0 to 4*pi) to visualize cyclic nature. A cosine wave is overlaid as a phase reference.


[hFig, hAx] = plot_axSize('szOnly', false);

mapAvg = mean(mapData(:, :, idxMap), 3, 'omitnan'); % Average rate map across units.
imagesc(hAx, rateMap.phaseBins, rateMap.powBins, mapAvg);
hold on
% Overlay cosine wave for phase reference.
plot(hAx, linspace(0, 2*pi, 100), ...
    cos(linspace(0, 2*pi, 100)) * (range(rateMap.powBins)/4) + mean(rateMap.powBins), ...
    'k--', 'LineWidth', 0.5);
axis xy
if flgCbar
    hCb = colorbar;
    hCb.Label.String = 'Firing Rate (Hz)';
end
colormap(hAx, "pink")
clim([0 12])
ylim(hAx, [min(rateMap.powBins), max(rateMap.powBins)])
xlim([0 2 * pi])
xticks(0:pi/2:2*pi)
hAx.XTickLabel = {'0', '90', '180', '270', '360'};
xlabel('Phase (°)')
ylabel('LFP Power (z-score)');
title([cfg.lbl.grp{iGrp}]);
hTtl = get(hAx, 'Title');
set(hTtl, 'FontSize', 18, 'FontWeight', 'bold');

% Assert Size
plot_axSize('hFig', hFig, 'szOnly', false, 'axWidth', 232, 'axHeight', 300);

% Save
fname = ['Ripp~SpkPhaseMap_', cfg.lbl.grp{iGrp}, '_', cfg.lbl.unit{iUnit}];
lme_save('hFig', hFig, 'fname', fname, 'frmt', {'svg', 'mat'});









