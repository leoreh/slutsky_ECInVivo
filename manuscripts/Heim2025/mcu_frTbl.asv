function [tAxis, frTbl] = mcu_frTbl(basepaths, varargin)
% MCU_FRTBL Create a table of firing rates aligned to perturbation
%
%   [tAxis, frTbl] = mcu_frTbl(basepaths)
%   [tAxis, frTbl] = mcu_frTbl(..., 'uTbl', uTbl)
%   [tAxis, frTbl] = mcu_frTbl(..., 'flgPlot', true)
%
%   Refactored to use mcu_detectPert for detection and alignment.
%   Combines data from multiple mice into a single global time axis.
%
% INPUTS:
%   basepaths (cell) - List of recording session paths.
%   uTbl      (table)- Optional. If provided, joins with the created table.
%   flgPlot   (log)  - Resules plotting.
%
% OUTPUTS:
%   tAxis     (vec)  - Global time axis in Hours (0 = Perturbation).
%   frTbl     (tbl)  - Table with metadata and 'FRt' column (aligned matrix).
%
% See also: MCU_DETECTPERT, CATFRTIME, V2TBL

%% ========================================================================
%  PARSE INPUTS
%  ========================================================================
p = inputParser;
addRequired(p, 'basepaths', @iscell);
addOptional(p, 'uTbl', table(), @istable);
addOptional(p, 'flgPlot', false, @islogical);
parse(p, basepaths, varargin{:});

uTbl = p.Results.uTbl;
flgPlot = p.Results.flgPlot;

%% ========================================================================
%  PROCESS BY MOUSE
%  ========================================================================
mice = unique(get_mname(basepaths));
nMice = length(mice);

mouseData = struct();

for iMouse = 1:nMice
    mName = mice{iMouse};

    % Get paths for this mouse (maintain input order sanity)
    % We rely on the input order of basepaths effectively representing
    % the potential chunks, but for a single mouse, we trust mcu_detectPert
    % and catFRtime to handle chronological sorting or stacking if implicit.
    % However, catFRtime uses absolute dates from filenames to stack.
    % So we just need to pass all paths belonging to this mouse.

    myPaths = basepaths(contains(basepaths, mName));


    % 1. PERTURBATION DETECTION & ALIGNMENT (Per Mouse)
    % Returns frMat (concatenated sessions), tAxis (centered at 0), pertIdx
    [frMat, tMouse, ~] = mcu_detectPert(myPaths);



    % 3. GENERATE METADATA TABLE
    % We need to match rows of frMat.
    % catFRtime stacks sessions in the order of valid processing/time.
    % Actually catFRtime implementation:
    % It iterates 1:nPaths (input order) and computes time relative to expStart.
    % It stacks them into frMat_chunks and then vertcat.
    % So row order is determined by inputs to catFRtime (myPaths).
    % We must generate table rows in the same order.

    % v = basepaths2vars('basepaths', myPaths, 'vars', {'units'});
    % 
    % varMap.unitType = 'units.type';
    % tagFiles.Mouse = get_mname(myPaths);
    % [~, fNames] = fileparts(myPaths);
    % tagFiles.File = fNames;
    % 
    % mTbl = v2tbl('v', v, 'varMap', varMap, 'tagFiles', tagFiles);
    % 
    % % Integrity Check
    % if height(mTbl) ~= size(frMat, 1)
    %     warning('Mismatch between unit table and FR matrix for mouse %s', mName);
    % end

    % Store
    mouseData(iMouse).frMat = frMat;
    mouseData(iMouse).tAxis = tMouse;
    % mouseData(iMouse).tbl   = mTbl;
    mouseData(iMouse).name  = mName;

end

%% ========================================================================
%  GLOBAL ALIGNMENT
%  ========================================================================

% 1. Determine Global Time Range
minT = inf;
maxT = -inf;
dt = [];

validMice = false(nMice, 1);

for iMouse = 1:nMice
    t = mouseData(iMouse).tAxis;
    if isempty(t), continue; end

    minT = min(minT, min(t));
    maxT = max(maxT, max(t));

    if isempty(dt) && length(t) > 1
        dt = t(2) - t(1);
    end
end


% 2. Create Global Axis
% Round to nearest dt to avoid floating point alignment issues
tAxis = minT : dt : maxT;
nBins = length(tAxis);

% 3. Align Data to Global Axis
tblParts = {};

for iMouse = 1:nMice

    fr = mouseData(iMouse).frMat;
    t = mouseData(iMouse).tAxis;
    % mTbl = mouseData(iMouse).tbl;

    % Find Start Index in Global Grid
    % t(1) should match one of the tAxis points approx
    [~, idxStart] = min(abs(tAxis - t(1)));

    % Container (NaN padded)
    [nUnits, nTimeMouse] = size(fr);
    alignedMat = nan(nUnits, nBins);

    % Fill
    idxEnd = min(nBins, idxStart + nTimeMouse - 1);
    lenToFill = idxEnd - idxStart + 1;

    if lenToFill > 0
        alignedMat(:, idxStart:idxEnd) = fr(:, 1:lenToFill);
    end

    % Assign to Table
    mTbl.FRt = alignedMat;
    % Should we store perturbation time?
    % It's 0 in the aligned axis.
    % Originally frTbl.pertOnset stored the time relative to the file.
    % But here we are already aligned.

    tblParts{end+1} = mTbl;
end

% 4. Combine
if ~isempty(tblParts)
    frTbl = vertcat(tblParts{:});
else
    frTbl = table();
end



%% ========================================================================
%  PLOT
%  ========================================================================
if flgPlot
    plot_FRtime(tAxis, frTbl);
end

end

%% ========================================================================
%  HELPER: PLOT FR vs TIME
%  ========================================================================
function plot_FRtime(tAxis, frTbl)

mice = unique(frTbl.Mouse);
nMice = length(mice);

f = figure('Name', 'Firing Rate vs Time', 'NumberTitle', 'off', ...
    'Position', [100 100 1000 600]);

tabgp = uitabgroup(f);

for i = 1:nMice
    mName = mice{i};
    tab = uitab(tabgp, 'Title', mName);
    ax = axes('Parent', tab);
    hold(ax, 'on');

    idx = strcmp(frTbl.Mouse, mName);
    subTbl = frTbl(idx, :);

    if isempty(subTbl), continue; end

    frData = subTbl.FRt; % This is the matrix
    if isempty(frData), continue; end

    % Plot All Traces (Light Gray)
    plot(ax, tAxis, frData', 'Color', [0.7 0.7 0.7 0.2]);

    % Plot Mean (Blue)
    meanFR = mean(frData, 1, 'omitnan');
    plot(ax, tAxis, meanFR, 'Color', 'b', 'LineWidth', 2, ...
        'DisplayName', 'Mean FR');

    xlabel(ax, 'Time (Hours)');
    ylabel(ax, 'Firing Rate (Hz)');
    title(ax, sprintf('Mouse: %s', mName), 'Interpreter', 'none');
    legend(ax, 'Location', 'best');
    grid(ax, 'on');
    xline(ax, 0, '--k', 'Perturbation');
end

end
