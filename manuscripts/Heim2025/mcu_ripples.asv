
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% run the analysis on multiple sessions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

basepaths = [mcu_sessions('wt_bsl_ripp'), mcu_sessions('mcu_bsl')];
nfiles = length(basepaths);

v = basepaths2vars('basepaths', basepaths, 'vars', {'session'});

for ifile = 1 : nfiles
    basepath = basepaths{ifile};
    cd(basepath)
    [~, basename] = fileparts(basepath);

    rippCh = v(ifile).session.channelTags.Ripple;

    ripp = ripp_wrapper('basepath', pwd, 'rippCh', rippCh,...
        'limState', 4, 'flgRefine', true, 'flgGraphics', true,...
        'flgSaveVar', false, 'flgSaveFig', true);
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% load and organize data from all sessions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define groups and get basepaths
grps = {'wt_bsl_ripp'; 'mcu_bsl'};
clear grppaths
for igrp = 1 : length(grps)
    grppaths{igrp} = string(mcu_sessions(grps{igrp})');
end
basepaths = vertcat(grppaths{:});

% Preload existing ripple data
v = basepaths2vars('basepaths', basepaths, 'vars', {'ripp', 'units'});

% Organize data struct for lmeOrg
idxStart = 1;
for igrp = 1 : length(grppaths)
    nPaths = length(grppaths{igrp});
    idxEnd = idxStart + nPaths - 1;

    % Assign the relevant subset of the preloaded 'v' to vCell
    vCell{igrp}{1} = v(idxStart : idxEnd);

    % Update start index for the next group
    idxStart = idxEnd + 1;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% lme
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% FR increase during ripples
frml = 'RippSpks ~ Group * UnitType + (1|Mouse)';
var_field = 'frModulation';

% organize for lme
[lme_tbl, lme_cfg] = lme_org('grppaths', grppaths, 'frml', frml,...
    'flg_emg', false, 'var_field', var_field, 'vCell', vCell);

% run lme
contrasts = 'all';
[lme_results, lme_cfg] = lme_analyse(lme_tbl, lme_cfg, 'contrasts', contrasts);

% plot
fh = lme_plot(lme_tbl, lme_cfg.mdl, 'ptype', 'bar');

% Update labels
axh = gca;
ylabel(axh, 'MFR Modulation Index', 'FontSize', 20)
xlabel(axh, 'Unit Type', 'FontSize', 20)
title(axh, '')

% save
lme_save('fh', fh, 'fname', frml, 'frmt', {'svg', 'mat', 'xlsx'},...
    'lme_tbl', lme_tbl, 'lme_results', lme_results, 'lme_cfg', lme_cfg)


% -------------------------------------------------------------------------


% analyze ripple parameter
frml = 'Ripp ~ Group + (1|Mouse)';

% organize for lme
var_field = 'rate';

% organize for lme
[lme_tbl, lme_cfg] = lme_org('grppaths', grppaths, 'frml', frml,...
    'flg_emg', false, 'var_field', var_field, 'vCell', vCell);

% run lme
contrasts = 'all';
[lme_results, lme_cfg] = lme_analyse(lme_tbl, lme_cfg, 'contrasts', contrasts);

% plot
fh = lme_plot(lme_tbl, lme_cfg.mdl, 'ptype', 'bar', 'figShape', 'tall');
axh = gca;
ylabel(axh, 'Rate (SWR / s)', 'FontSize', 20)
xlabel(axh, '', 'FontSize', 20)
title(axh, '')
axh.XAxis.FontSize = 20;
axh.XTickLabelRotation = 0;
ylim([0 3])

ylbl = 'Ripp Density';
fname = lme_frml2char(frml, 'rm_rnd', true, 'resNew', ylbl);

% save
lme_save('fh', fh, 'fname', fname, 'frmt', {'svg', 'mat', 'xlsx'},...
    'lme_tbl', lme_tbl, 'lme_results', lme_results, 'lme_cfg', lme_cfg)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Re-run only part of the analysis pipeline (e.g., ripp_spks)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Assumes data was already loaded

for ifile = 1 : length(basepaths)

    % File
    basepath = basepaths{ifile};
    [~, basename] = fileparts(basepath);

    % Get the preloaded ripple structure
    ripp = v(ifile).ripp;

    % Re-run ripp_spks
    % ripp = ripp_spks(ripp, 'basepath', basepath, 'limState', 4,...
    %     'flgGraphics', false, 'flgSaveVar', true);
    
    % Re-run state analysis
    ripp = ripp_states(ripp, 'basepath', basepath, 'flgGraphics', false, ...
        'flgSaveVar', true, 'flgSaveFig', true);

    % plot detection
    % ripp_plot(ripp, 'basepath', basepath, 'flgSaveFig', false);

    % Plot spikes
    % ripp_plotSpks(ripp, 'basepath', basepath, 'flgSaveFig', false);

    % Update the preloaded variable structure if needed later
    v(ifile).ripp = ripp;
end





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Play with the data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Create a mean normalized SU PETH for RS and FS units from all mice of
% a group and create a figure the superimposes WT and MCU-KO (separately
% for RS and FS units.

% Define Parameters
baselineFraction = 0.2; % Use first 20% of window for baseline normalization
colors = {[0 0 1], [1 0 0]}; % WT: Blue, MCU: Red

% Get Time Axis Info (assuming consistent across sessions)
mapInfo = vCell{1}{1}(1).ripp.spks.info;
mapDur = mapInfo.mapDur;
nBinsMap = mapInfo.nBinsMap;
timeVector = linspace(mapDur(1), mapDur(2), nBinsMap);
baselineBins = 1:floor(nBinsMap * baselineFraction);

% Stores matrices of unit-normalized PETHs for each group
normPethsRS_grp = cell(1, length(grps));
normPethsFS_grp = cell(1, length(grps));

% Process data for each group
for igrp = 1:length(grps)
    allNormRS = []; % Renamed and kept concise
    allNormFS = []; % Renamed and kept concise

    for iMouse = 1:length(vCell{igrp}{1})
        mouseData = vCell{igrp}{1}(iMouse);
        
        % Access data with concise names
        rippMap = mouseData.ripp.spks.su.rippMap;
        % rippMap = mouseData.ripp.spks.su.ctrlMap;
        idxRS = mouseData.units.clean(1, :);
        idxFS = mouseData.units.clean(2, :);

        % Calculate mean PETH per unit & normalize by unit max
        meanPethUnit = squeeze(mean(rippMap, 2, 'omitnan'));
        flgNorm = false;
        if flgNorm
            maxUnit = max(meanPethUnit, [], 2);
            maxUnit(maxUnit == 0) = 1;
            normPethUnit = meanPethUnit ./ maxUnit;
        else
            normPethUnit = meanPethUnit;
        end

        % Collect normalized PETHs
        allNormRS = [allNormRS; normPethUnit(idxRS, :)];
        allNormFS = [allNormFS; normPethUnit(idxFS, :)];
    end

    % Store the matrices for the group
    normPethsRS_grp{igrp} = allNormRS;
    normPethsFS_grp{igrp} = allNormFS;
 
end

% Plotting using plot_stdShade
fh_peth = figure('Name', 'Mean Unit-Normalized PETHs with SEM');
tl = tiledlayout(1, 2, 'Padding', 'compact', 'TileSpacing', 'compact');
title(tl, 'Mean SU PETH around Ripple Peak (Unit-Normalized +/- SEM)');

% RS Units Plot
ax1 = nexttile;
hold(ax1, 'on');
for igrp = 1:length(grps)
    plot_stdShade('axh', ax1, 'dataMat', normPethsRS_grp{igrp}, 'alpha', 0.3, 'clr', colors{igrp}, 'xVal', timeVector);
end
xline(ax1, 0, '--k');
title(ax1, 'RS Units');
xlabel(ax1, 'Time (s)');
ylabel(ax1, 'Mean Norm. FR (Unit Max = 1)');
legend(ax1, grps, 'Location', 'best', 'Interpreter', 'none');
grid(ax1, 'on');
% ylim(ax1, [0, 1]); % Keep y-axis limit

% FS Units Plot
ax2 = nexttile;
hold(ax2, 'on');
for igrp = 1:length(grps)
     if ~isempty(normPethsFS_grp{igrp})
        plot_stdShade('axh', ax2, 'dataMat', normPethsFS_grp{igrp}', 'alpha', 0.3, 'clr', colors{igrp}, 'xVal', timeVector);
     end
end
xline(ax2, 0, '--k');
title(ax2, 'FS Units');
xlabel(ax2, 'Time (s)');
ylabel(ax2, 'Mean Norm. FR (Unit Max = 1)');
legend(ax2, grps, 'Location', 'best', 'Interpreter', 'none');
grid(ax2, 'on');
% ylim(ax2, [0, 1]); % Keep y-axis limit

% Save Figure - Intentionally commented out based on user edit
% grph_save('fh', fh_peth, 'fname', 'mean_unitnorm_peth_ripples_stdshade', 'frmt', {'jpg', 'ai'});


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compare Raw Spike Counts near Ripple Peak (+/- 5ms)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define window & bins (assuming mapDur, nBinsMap exist from PETH section)
peakWinSec = 0.003; % +/- 5ms
binWidth = diff(mapDur) / nBinsMap;
centerBin = ceil(nBinsMap / 2);
binsNeededHalf = ceil(peakWinSec / binWidth);
binStart = max(1, centerBin - binsNeededHalf);
binEnd = min(nBinsMap, centerBin + binsNeededHalf);
binIdx = binStart : binEnd;

% Store the matrices for the group
for igrp = 1 : 2
    peakFR_RS{igrp} = mean(normPethsRS_grp{igrp}(:, binIdx), 2);
    peakFR_FS{igrp} = mean(normPethsFS_grp{igrp}(:, binIdx), 2); % Also calculate for FS units
end

% --- Bar Plot Comparison for RS Units using plot_boxMean ---
fh_peakFR_RS = figure('Name', 'Peak FR RS Units');
ax1 = gca;
dataMat = cell2padmat(peakFR_RS, 2);
plot_boxMean('dataMat', dataMat', 'xVal', [1, 2],...
             'axh', ax1, ...
             'plotType', 'bar', ...
             'grpNames', grps, ...
             'clr', cell2padmat(colors, 1));
yLabel = sprintf('Mean Norm. FR per Unit (±%dms Peak)', peakWinSec*1000);
ylabel(ax1, yLabel);
title(ax1, 'RS Unit Normalized Firing Rate Near Ripple Peak');
box(ax1, 'off'); grid(ax1, 'on');

% --- Bar Plot Comparison for FS Units using plot_boxMean ---
fh_peakFR_FS = figure('Name', 'Peak FR RS Units');
ax1 = gca;
dataMat = cell2padmat(peakFR_FS, 2);
plot_boxMean('dataMat', dataMat', 'xVal', [1, 2],...
             'axh', ax1, ...
             'plotType', 'bar', ...
             'grpNames', grps, ...
             'clr', cell2padmat(colors, 1));
yLabel = sprintf('Mean Norm. FR per Unit (±%dms Peak)', peakWinSec*1000);
ylabel(ax2, yLabel);
title(ax2, 'FS Unit Normalized Firing Rate Near Ripple Peak');
box(ax2, 'off'); grid(ax2, 'on');

% Optional: Save Figures
% grph_save('fh', fh_peakFR_RS, 'fname', 'peak_normFR_RS_comparison', 'frmt', {'jpg', 'ai'});
% grph_save('fh', fh_peakFR_FS, 'fname', 'peak_normFR_FS_comparison', 'frmt', {'jpg', 'ai'});



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RIPPLE CORRECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

bit2uv = 0.195;

for ifile = 2:length(v)
        
    basepath = char(basepaths(ifile)); % Ensure basepath is char for fileparts
    [~, basename] = fileparts(basepath);
    rippFile = fullfile(basepath, [basename, '.ripp.mat']);

    if contains(basename, 'lh107')
        v(ifile).ripp.info.bit2uv = 1;
        ripp = v(ifile).ripp;
        save(rippFile, 'ripp', '-v7.3');
        continue
    end

    % Apply correction factor
    v(ifile).ripp.peakFilt = v(ifile).ripp.peakFilt * bit2uv;
    v(ifile).ripp.peakAmp  = v(ifile).ripp.peakAmp  * bit2uv;

    v(ifile).ripp.maps.raw  = v(ifile).ripp.maps.raw  * bit2uv;
    v(ifile).ripp.maps.ripp = v(ifile).ripp.maps.ripp * bit2uv;
    v(ifile).ripp.maps.amp  = v(ifile).ripp.maps.amp  * bit2uv;

    % Recalculate correlations if the corr field and necessary data exist
    % corr function with 'rows', 'complete' handles NaNs and should be okay with empty inputs (returning NaN)
    v(ifile).ripp.corr.AmpFreq = corr(v(ifile).ripp.peakAmp, v(ifile).ripp.peakFreq, 'rows', 'complete');
    v(ifile).ripp.corr.DurAmp  = corr(v(ifile).ripp.dur, v(ifile).ripp.peakAmp, 'rows', 'complete');

    % Add/update informational fields regarding the correction
    v(ifile).ripp.info.bit2uv = bit2uv;

    % Save the updated ripp structure
    ripp = v(ifile).ripp;
    save(rippFile, 'ripp', '-v7.3');
end







