%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ANALYZE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PRC Params
clear prcParams
prcParams.winLim = [0 70 * 60];        % Analysis window [s]
prcParams.binSize = 0.001;             % 1ms bins
prcParams.gkHw = 0.012;                % 12ms sigma
prcParams.winStpr = 1.0;               % 1s window
prcParams.nShuffles = 1000;            % Number of shuffles
prcParams.spkLim = 2000;
prcParams.shuffleMet = 'raster';

% Files
% basepaths = [mcu_sessions('mea_mk801')];
basepaths = [mcu_sessions('mea_bac'), mcu_sessions('mea_mcuko')];
nFiles = length(basepaths);
vars = {'mea', 'st_metrics'};
v = basepaths2vars('basepaths', basepaths, 'vars', vars);

% Analysis Params
bslLim = [5 70] * 60;        
ssLim = [7 * 60, 9 * 60 - 5] * 60;
troughLim = [4 * 60 + 10, 4.5 * 60] * 60;
stWin = {bslLim, ssLim, troughLim};
expLim = [0, 9 * 60]  * 60;

% expLim = [0, Inf];

for iFile = 1 : nFiles

    basepath = basepaths{iFile};
    cd(basepath);
    
    % files = dir('*sorted*');
    % mea = mea_orgNex('fname', files.name, 'basepath', pwd, 'forceL', false);
    spktimes = v(iFile).mea.spktimes;
    
    % % --- Firing Rate Recovery
    frr = mea_frr(spktimes, 'winLim', expLim,...
        'flgSave', true, 'flgPlot', false, 'flgForce', false);

    % % --- Spike timing metrics
    % st = spktimes_metrics('spktimes', spktimes, 'sunits', [],...
    %     'bins', stWin, 'flg_force', true, 'flg_save', true, 'flg_all', false);
    % 
    % % --- Bursts
    % brst = spktimes_meaBrst(spktimes, 'binsize', [], 'isiThr', 0.02,...
    %     'minSpks', 2, 'flgSave', true, 'flgForce', true, 'bins', stWin);

    % % --- Population Coupling
    % [prc] = prCoupling(spktimes, prcParams, 'flgSave', true);
    % prCoupling_plot(prc, 'basepath', basepath, 'flgSaveFig', true);

end



vars = {'frr', 'mea'};
basepaths = mcu_sessions('mea_mcuko');
v = basepaths2vars('basepaths', basepaths, 'vars', vars);
frr = catfields([v(:).frr], 1);
uGood = frr.uGood;

x = frr.frFit.idxTrough(uGood);
y = frr.mdl.idxTrough(uGood);
figure;
scatter(x, y)


x = frr.mdl.frTrough(uGood);
y = frr.mdlF.frTrough(uGood);
min(x(x > 0))
min(y(y > 0))

x = frr.mdl.frBsl(uGood);
y = frr.mdlF.frBsl(uGood);
min(x(x > 0))
min(y(y > 0))

vars = {'frr', 'mea'};
basepaths = mcu_sessions('mea_bac');
v = basepaths2vars('basepaths', basepaths, 'vars', vars);
frr = catfields([v(:).frr], 1);
uGood = frr.uGood;

x = frr.mdl.frTrough(uGood);
y = frr.mdlF.frTrough(uGood);
min(x(x > 0))
min(y(y > 0))
figure;
histogram(y)
hold on
histogram(x)

x = frr.mdl.frBsl(uGood);
y = frr.mdlF.frBsl(uGood);
min(x(x > 0))
min(y(y > 0))






x = frr.mdl.frSs(uGood);
y = frr.mdlF.frSs(uGood);
min(x(x > 0))
min(y(y > 0))

x = frr.mdl.pertDepth(uGood);
y = frr.mdlF.pertDepth(uGood);
figure;
% scatter(x, y)
histogram(x)

x = frr.mdl.rcvGain(uGood);
y = frr.mdlF.rcvGain(uGood);
figure;
histogram(y)





clear lg
figure
hold on
clr = lines(nFiles);
for iFile = 1 : 10
    spktimes = v(iFile).mea.spktimes;
    uBad = v(iFile).frr.uBad;
    uGood = v(iFile).frr.uGood;
    lg{iFile} = spktimes(uBad);

    x = v(iFile).frr.mdl.pertDepth(uGood);
    y = v(iFile).frr.mdlF.pertDepth(uGood);
    % x = v(iFile).frr.mdl.rcvGain(uGood);
    % y = v(iFile).frr.mdlF.rcvGain(uGood);
    scatter(x, y, 10, clr(iFile, :))

    % lg(iFile) = isreal(v(iFile).frr.mdl.frTrough);
    % lg(iFile) = all(v(iFile).frr.mdlF.frTrough > 0)
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TABLE PREPARATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Load data from both groups
grps = {'mea_bac'; 'mea_mcuko'};
grpLbls = {'Control'; 'MCU-KO'};
vars = {'frr', 'st_brst'};

% Choose between model-based (mdl) or model-free (mdlF) metrics
mdlPrfx = 'frr.mdl';
mdlPrfx = 'frr.mdlF';

clear varMap
varMap.uGood      = 'frr.uGood';
varMap.frBsl      = [mdlPrfx, '.frBsl'];
varMap.frSs       = [mdlPrfx, '.frSs'];  
varMap.frTrough   = [mdlPrfx, '.frTrough'];  
varMap.pertDepth  = [mdlPrfx, '.pertDepth'];
varMap.uRcv       = [mdlPrfx, '.uRcv'];
varMap.uPert      = [mdlPrfx, '.uPert'];
varMap.rcvTime    = [mdlPrfx, '.rcvTime'];
varMap.bslTime    = [mdlPrfx, '.bslTime'];
varMap.rcvErr     = [mdlPrfx, '.rcvErr'];
varMap.rcvGain    = [mdlPrfx, '.rcvGain'];
varMap.rcvWork    = [mdlPrfx, '.rcvWork'];
varMap.rcvSlope   = [mdlPrfx, '.normSlope'];
varMap.spkDfct    = [mdlPrfx, '.spkDfct'];
varMap.rcvDiff    = [mdlPrfx, '.rcvDiff'];
varMap.rcvFit     = ['frr.frFit.rsquare'];
varMap.BSpks      = 'brst.bspks';
varMap.brBsl      = 'brst.rate';
% varMap.brMiz      = 'st.mizuseki';    % keeping st_metrics removes many rows
% varMap.brRoy      = 'st.royer';
% varMap.prc        = 'prc.prc0_norm';

% Specific overrides
varMap.pertDepth  = 'frr.mdl.pertDepth';
varMap.uRcv       = 'frr.mdlF.uRcv';
varMap.spkDfct    = 'frr.mdlF.spkDfct';
varMap.rcvGain    = 'frr.mdlF.rcvGain';
varMap.rcvTime    = 'frr.mdl.rcvTime';
varMap.bslTime    = 'frr.mdl.bslTime';

clear tblCell
for iGrp = 1 : length(grps)
    basepaths = mcu_sessions(grps{iGrp});
    
    % Load data for this group
    v = basepaths2vars('basepaths', basepaths, 'vars', vars);
    
    % Prepare tag structures for v2tbl
    tagAll.Group = grpLbls{iGrp};
    tagFiles.Name = get_mname(basepaths);
    
    % Create table using new flexible approach
    tblCell{iGrp} = v2tbl('v', v, 'varMap', varMap,...
        'tagFiles', tagFiles, 'tagAll', tagAll, 'idxCol', 1);
end
tbl = vertcat(tblCell{:});

% Organize for analysis
lmeData = tbl(tbl.uGood, :);
lmeData.uGood = [];
lmeData = rmmissing(lmeData);   

% Convert time to min, specific for mea x3 data reduction
lmeData.rcvTime = lmeData.rcvTime * 3 / 60;
lmeData.bslTime = lmeData.bslTime * 3 / 60;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT CORRELATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Log transform for plotting
varsInc = {'frBsl', 'frSs', 'frTrough', 'BSpks',...
    'rcvErr', 'pertDepth', 'brBsl', 'rcvSlope'};
lData = tbl_transform(lmeData, 'varsInc', varsInc, 'flgZ', false,...
    'skewThr', 0.1, 'varsGrp', {'Group'}, 'flgLog', true);

% Remove units that didn't recover from rcvTime
idxUnits = lmeData.uRcv;
lData.rcvTime(~idxUnits) = nan;
lData.bslTime(~idxUnits) = nan;
lData.rcvErr(~idxUnits) = nan;
lData.rcvSlope(~idxUnits) = nan;
clr = mcu_clr();

% Plot correlations
varsRow = {'spkDfct', 'rcvGain', 'bslTime', 'rcvTime', 'rcvWork'};
varsCol = {'BSpks', 'frBsl', 'pertDepth'};
[hFig, ~, hGrid] = plot_corrHist(lData, 'varsRow', varsRow, 'varsCol', varsCol,...
    'grpIdx', 'Group', 'clrGrp', clr.grp, 'thrOut', 100);
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'wide', 'axHeight', 400);


varsInc = {'frBsl', 'BSpks', 'pertDepth', 'spkDfct',...
    'rcvGain', 'rcvWork', 'bslTime'};
[hFig, ~, hGrid] = plot_corrHist(lData, 'varsInc', varsInc,...
    'grpIdx', 'Group', 'clrGrp', clr.grp, 'thrOut', 100);
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'wide', 'axHeight', 700);


uIdx = lData.rcvFit > 0;
tData = lData(uIdx, :);

varsInc = {'frBsl', 'frSs', 'frTrough', 'pertDepth', 'BSpks',...
    'bslTime', 'rcvTime', 'rcvFit'};
[hFig, ~, hGrid] = plot_corrHist(tData, 'varsInc', varsInc,...
    'grpIdx', 'Group', 'clrGrp', clr.grp, 'thrOut', 100);
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'wide', 'axHeight', 700);

txtLbls = 'Spike Deficit (log-ratio)';
txtLbls = 'Spike Deficit (log-ratio)';


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LINEAR MODELS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% -------------------------------------------------------------------------
% (*) REMARKS
% Since the primary question concerns genotypes, only test interactions
% between predictors and group (rather then between predictors). Due to
% collinearity, I only use BSpks as a measure of brustiness because it is
% the only one not correlation with bslFr.

% I only apply z score when using contineous predictors for easier
% interpretation. with only grouping variables (when means are compared) I
%  want to keep the original units of the response variables. Same goes for
%  log transform. 

% Insisted to use rcvGain and spkDfct on logarithm scale so they can be
% analyzed with fitlme. rcvTime (and MF) probably still needs glme. 

% BslFr is positively correlated with recovery time (model and model free).
% This makes sense considering most units drop to zero, and thus despite
% normalizing the target value, it is still largely influenced by BslFr. A
% similar result is obtain for SpkDftc. Because of this, and because it
% does not predict uRcv, it is omitted from subsequent models

% For recovery time, the gamma distribution used the reciprocal link which
% means that a positive coefficient decreases the response

% Recovery slope is impossible with raw firing rates and for the model
% fits, it depends too much on the selected model (e.g. sigmoid vs.
% exponential).

% A discripency between model-based and model-free parameters is that in
% the latter there is no correlation between frBsl and pertDepth because
% many values are clamped to c. Hence pertDepth should only be from the
% model. 

% Recovery time includes units that reached their threshold value but
% didn't manage to maintain it, i.e. 

% -------------------------------------------------------------------------
% PREPS

% Recovered units
idxUnits = lmeData.uRcv;
lmeMdl = {};

% List of possible predictors
listPrdct = {'pertDepth', 'frBsl', 'BSpks', 'PRC', 'Group', '(1|Name)', 'brBsl'}; 
listRspns = {'uRcv', 'rcvGain', 'rcvWork', 'rcvErr', 'bslTime', 'spkDfct', 'rcvSlope'}; 

% Z score predictors
zlData = tbl_transform(lmeData, 'varsExc', listRspns, 'flgZ', true,...
    'skewThr', 2, 'varsGrp', {'Group'}, 'flgLog', true);

% -------------------------------------------------------------------------
% RECOVERY PROBABILITY
% Only among units that were perturbed > 50%
idxBac = lmeData.uPert;
iPr = [1, 2, 3, 5, 6];
frml = sprintf('%s ~ %s', listRspns{1}, strjoin(listPrdct([iPr]), ' + '));
lmeMdl{end + 1} = fitglme(zlData(idxBac, :), frml, 'FitMethod', 'REMPL',...
    'Distribution', 'Binomial');

% -------------------------------------------------------------------------
% RECOVERY WORK 
frml = [listRspns{3}, ' ~ frBsl + BSpks * Group + (1|Name)'];
lmeMdl{end + 1} = fitlme(zlData, frml, 'FitMethod', 'REML');

% -------------------------------------------------------------------------
% RECOVERY TIME 
% only units who recovered, from both groups combined
frml = [listRspns{5}, ' ~ frBsl + BSpks + (1|Name)'];
lmeMdl{end + 1} = fitglme(zlData(idxUnits, :), frml, 'FitMethod', 'REMPL',...
    'Distribution', 'Gamma');

% -------------------------------------------------------------------------
% SPIKE DEFICIT 
frml = [listRspns{6}, ' ~ pertDepth + frBsl + BSpks * Group + (1|Name)'];
lmeMdl{end + 1} = fitlme(zlData, frml, 'FitMethod', 'REML');

% % -------------------------------------------------------------------------
% % RECOVERY ERROR 
% % only units who recovered, from both groups combined
% frml = [listRspns{4}, ' ~ pertDepth + BSpks + frBsl + Group + (1|Name)'];
% lmeMdl{end + 1} = fitglme(zlData(idxUnits, :), frml, 'FitMethod', 'REMPL',...
%     'Distribution', 'Gamma');

% -------------------------------------------------------------------------
% SAVE MODELS
fname = 'MEA ~ frrMdl';
for iMdl = 1 : length(lmeMdl)
    sheetNames = {'LME_Data', lmeMdl{iMdl}.ResponseName};
    lme_save('fname', fname, 'frmt', {'mat', 'xlsx'},...
        'lmeData', lmeData, 'lmeMdl', lmeMdl{iMdl}, 'sheetNames', sheetNames)
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMPARE BASELINE VS RECOVERY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -------------------------------------------------------------------------
% Load data from both groups
grps = {'mea_bac'; 'mea_mcuko'};
grpLbls = {'Control'; 'MCU-KO'};
vars = {'frr', 'st_metrics', 'st_brst'};
vars = {'frr', 'st_brst'};

% Create varMap based on time point
clear varMap
varMap.uGood      = 'frr.uGood';
% varMap.BrMiz      = 'st.mizuseki';
% varMap.BrRoy      = 'st.royer';
varMap.BSpks      = 'brst.bspks';

% Override the source prefix (in main analysis)
mdlPrfx = 'frr.mdlF';

cnt = 1;
clear tblCell
for iGrp = 1 : length(grps)
    basepaths = mcu_sessions(grps{iGrp});
    v = basepaths2vars('basepaths', basepaths, 'vars', vars);
   
    % Create consistent UnitIDs for this group (reset between groups). Use
    % frr for grabbing the number of units.
    frr = catfields([v(:).frr], 1);
    [nUnits, ~] = size(frr.fr);
    unitIDs = (1:nUnits)';

    for iCol = 1 : 3

        % Fr maps to different sources based on time point
        switch iCol
            case 1
                varMap.Fr  = [mdlPrfx, '.frBsl'];
                tagAll.Time = 'BSL';
            case 2
                varMap.Fr  = [mdlPrfx, '.frTrough'];
                tagAll.Time = 'BAC 1h';

            case 3
                varMap.Fr  = [mdlPrfx, '.frSs'];
                tagAll.Time = 'BAC 24h';
        end

        % Prepare tag structures for v2tbl
        tagAll.Group = grpLbls{iGrp};
        tagFiles.Name = get_mname(basepaths);

        tempTbl = v2tbl('v', v, 'varMap', varMap, 'tagFiles',...
            tagFiles, 'tagAll', tagAll, 'idxCol', iCol);
        
        % Override the UnitID to ensure consistency across time points
        % Add group offset to make UnitIDs unique between groups
        groupOffset = (iGrp - 1) * 10000;  % 10000 units per group
        tempTbl.UnitID = groupOffset + unitIDs;

        tblCell{cnt} = tempTbl;
        cnt = cnt + 1;
    end
end
tbl = vertcat(tblCell{:});
tbl = sortrows(tbl, 'Group');


% -------------------------------------------------------------------------
% Bursty
varRsp = 'BSpks';

% Organize for analysis
lmeData = tbl(tbl.uGood, :);
lmeData.uGood = [];
lmeData = rmmissing(lmeData);

% Normalize to baseline
nData = tbl_transform(lmeData, 'varsInc', {varRsp}, 'flgZ', false,...
    'skewThr', 2, 'varsGrp', {'Group'}, 'varNorm', 'Time',...
    'flgLog', false, 'flgNorm', false);
nData.BSpks = nData.BSpks + min(nData.BSpks(nData.BSpks > 0)) / 2;

% Remove unused categorical levels
% nData(nData.Time == 'BAC 24h', :) = [];
nData(nData.Time == 'BAC 1h', :) = [];
if ismember('Time', nData.Properties.VariableNames)
    actualTimeLevels = unique(nData.Time);
    nData.Time = categorical(nData.Time, actualTimeLevels);
end
grpstats(lmeData, {'Group', 'Time'});

% run lme
frml = [varRsp, ' ~ Group * Time + (1|Name)'];
lmeCfg.contrasts = [1 : 7];
lmeCfg.distribution = 'Gamma';
[lmeStats, lmeMdl] = lme_analyse(nData, frml, lmeCfg);

% plot
hFig = lme_plot(nData, lmeMdl, 'lmeStats', lmeStats,...
    'ptype', 'bar', 'axShape', 'square', 'idxRow', [4, 3]);

% Update labels
hAx = gca;
ylabel(hAx, 'Burstiness P(Spk\inBrst)', 'Interpreter', 'tex')
xlabel(hAx, '')
title(hAx, '')
hAx.Legend.Location = 'southeast';
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'square',...
    'axHeight', 300)



% -------------------------------------------------------------------------
% Firing Rate

% Organize for analysis
lmeData = tbl(tbl.uGood, :);
lmeData.uGood = [];
lmeData = rmmissing(lmeData);

% Normalize to baseline
nData = tbl_transform(lmeData, 'varsInc', {varRsp}, 'flgZ', false,...
    'skewThr', 2, 'varsGrp', {'Group'}, 'varNorm', 'Time',...
    'flgLog', false, 'flgNorm', false);
nData.Fr = nData.Fr + min(nData.Fr(nData.Fr > 0)) / 2;

% Remove unused categorical levels
% nData(nData.Time == 'BSL', :) = [];
nData(nData.Time == 'BAC 1h', :) = [];
if ismember('Time', nData.Properties.VariableNames)
    actualTimeLevels = unique(nData.Time);
    nData.Time = categorical(nData.Time, actualTimeLevels);
end
grpstats(lmeData, {'Group', 'Time'});

% run lme
varRsp = 'Fr';
frml = [varRsp, ' ~ Group * Time + (1|Name)'];
lmeCfg.contrasts = [];
lmeCfg.distribution = 'Gamma';
[lmeStats, lmeMdl] = lme_analyse(nData, frml, lmeCfg);

% plot
hFig = lme_plot(nData, lmeMdl, 'lmeStats', lmeStats,...
    'ptype', 'bar', 'axShape', 'square', 'idxRow', [1 : 7]);

% Update labels
hAx = gca;
ylabel(hAx, 'Firing Rate (Hz)', 'Interpreter', 'tex')
xlabel(hAx, '')
title(hAx, '')
hAx.Legend.Location = 'southeast';
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'square',...
    'axHeight', 300)

