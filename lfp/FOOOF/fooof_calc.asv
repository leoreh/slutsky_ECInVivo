function ffOut = fooof_calc(psd_data, freqs, varargin)

% Parameterizes neural power spectra using FOOOF (Fitting Oscillations &
% One-Over F), separating periodic (peaks) and aperiodic (1/f-like)
% components. Uses the MATLAB wrapper for Python FOOOF implementation.
%
%
% INPUT
%   psd_data    power spectra to analyze [bout x freq].
%   freqs       vector of frequencies [1 x nfreq]
%   basepath    char. recording session path {pwd}
%   f_range     frequency range for fitting []
%   fooof_cfg   struct with optional fields for configuration. see below.
%   flg_plot    logical. plot fooof results per bout (true)
%   saveVar     logical / char. save variable {true}. if char then variable
%               will be named [saveVar].mat
%
% OUTPUT
%   psd_1of     struct with fields: 
%                 .psd_orig [nBouts x nfreqs] - original power spectrum
%                 .psd_fit  [nBouts x nfreqs] - fooofed power spectrum (aperiodic + periodic)
%                 .psd_ap   [nBouts x nfreqs] - aperiodic component of the spectrum
%                 .cf       [nBouts x nbands] - center frequencies of selected peaks per band
%                 .pow      [nBouts x nbands] - power of selected peaks per band
%                 .bw       [nBouts x nbands] - bandwidth of selected peaks per band
%                 .amp      [nBouts x nbands] - amplitude of selected peaks per band (from gaussian_params)
%                 .sd       [nBouts x nbands] - std dev of selected peaks per band (from gaussian_params)
%                 .ap_offset [nBouts x 1]    - aperiodic offset
%                 .ap_exp    [nBouts x 1]    - aperiodic exponent
%                 .ap_knee   [nBouts x 1]    - aperiodic knee (if present, else [])
%                 .prob_osc  [1 x nbands]    - probability of detecting an oscillation in each band
%                 .residuals [nBouts x nfreqs] - residual spectrum (psd_orig - psd_ap)
%                 .residuals_fit [nBouts x nfreqs] - residual of model fit (psd_fit - psd_ap)
%                 .powsum    [nBouts x nbands] - sum of power in residuals within bands
%                 .freqs     [1 x nfreqs]    - frequency vector
%                 .fit       struct with fields (each [nBouts x 1]): rmse, loglik, aic, bic, r_squared
%                 .info      struct with analysis details (bandefs, fooof_cfg, etc.)
%
% CALLS
%   fooof
%   peaks2bands (local function)
%   calc_fit (local function)
%
% DEPENDENCIES
%   Python with packages installed:
%   py -3.12 -m pip install numpy fooof matplotlib
%
% SEE ALSO
%   https://fooof-tools.github.io/fooof/
%
% 09 Jan 24 LH

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p = inputParser;
addOptional(p, 'fooof_cfg', []);
addOptional(p, 'basepath', pwd);
addOptional(p, 'f_range', []);
addOptional(p, 'flg_plot', true, @islogical);
addOptional(p, 'saveVar', true);

parse(p, varargin{:})
fooof_cfg           = p.Results.fooof_cfg;
f_range             = p.Results.f_range;
basepath            = p.Results.basepath;
flg_plot            = p.Results.flg_plot;
saveVar             = p.Results.saveVar;

if isempty(f_range)
    f_range = [min(freqs), max(freqs)];
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% preparations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% filename
[~, basename] = fileparts(basepath);
if ischar(saveVar)
    fname = [basepath, filesep, basename, '.' saveVar '.mat'];
else
    fname = fullfile(basepath, [basename, '.psd_1of.mat']);
end

% ensure row vectors
freqs = freqs(:)';

% initialize python and packages if needed
% in windows cmd, make sure python includes relevant packages
% py -3.12 -m pip install numpy
% py -3.12 -m pip install fooof
% py -3.12 -m pip install matplotlib
try         % check if modules already imported
    py.importlib.import_module('numpy');
    py.importlib.import_module('fooof');
    py.importlib.import_module('matplotlib');
catch ME
    clear classes
    clear py.*
    pyenv;   % initialize python environment
    pyversion
    % Verify FOOOF is installed in that Python environment
    py.help('fooof')
    py.importlib.import_module('numpy');
    py.importlib.import_module('fooof');
    py.importlib.import_module('matplotlib');
end

% model parameters
if isempty(fooof_cfg)
    % defaults
    % 'peak_width_limits', [0.5 12],...    % [min max] allowed peak width
    % 'max_n_peaks', inf,...               % maximum number of peaks to fit
    % 'min_peak_height', 0.0,...           % minimum peak height threshold
    % 'peak_threshold', 2,...              % relative height above background
    % 'aperiodic_mode', 'fixed',...        % 'fixed' or 'knee'
    % 'verbose', true,...                  % print output
    % 'return_model', true);               % return model results

    fooof_cfg = struct(...
        'peak_width_limits', [2 Inf],...
        'max_n_peaks', 5,...
        'min_peak_height', 0.05,...
        'peak_threshold', 0.5,...
        'aperiodic_mode', 'knee',...
        'verbose', true,...
        'return_model', true);
end

% append info to output
ffOut.info.fooof_cfg = fooof_cfg;

% test models with different peak numbers. adapted from
% https://www.biorxiv.org/content/10.1101/2024.08.01.606216v1.full.pdf
% (brainstorm). In sum, the idea is to create models with 0 to
% max_peaks and quantify the Bayesian Information Criterion for each
% model. The model with the lowest BIC is then subjected to Bayes factor
% inference against the aperiodic spectral model to adjudicate whether
% spectral peaks are likely. A Bayes factor < 1 is evidence in
% favour of periodic brain activity over the null hypothesis of no periodic
% activity. Note in their paper they implement this more efficiently, by
% adding peaks to the aperiodic component rather then remodeling the data.
% an example call to their function can be found at the end of this script.

% here, a model will be created for each combination of parameters below.
npeaks = [0 : fooof_cfg.max_n_peaks];
nmdls = length(npeaks);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% run fooof
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% get number of bouts
[nBouts, nfreq] = size(psd_data); % Directly use psd_data

% validate psd input
if nfreq ~= length(freqs)
    error('chech psd_data input')
end

% initialize output
clear ffMdl
% loop through bouts
for ibout = 1 : nBouts
    for imdl = 1 : nmdls

        % adjust model parameters
        fooof_cfg.max_n_peaks = npeaks(imdl);

        % run fooof. note output (and subsequent spectrums) are in power
        % (log10)
        ffMdl(imdl) = fooof(freqs, psd_data(ibout, :),... 
            f_range, fooof_cfg, fooof_cfg.return_model);

        % calculate model fit
        mdl_fit(imdl) = calc_fit(ffMdl(imdl));
    end

    % select best model
    bic = vertcat(mdl_fit.bic);
    [~, idx_best] = min(bic);

    % Bayes Factor between best model and apreiodic component
    bf = exp((bic(idx_best) - bic(1)) ./ 2);
    if bf > 1
        idx_best = 1;
    end
    
    ffTmp = ffMdl(idx_best);
    ffTmp.fit = mdl_fit(idx_best);
    
    % append
    ffIn(ibout) = ffTmp;
end

% concatenate
ffIn = catfields(ffIn, 'addim');

% organize output 
ffOut = fooof_org(ffIn); 
mask_freq = freqs >= f_range(1) & freqs <= f_range(2);
ffOut.freqs = freqs(mask_freq);

% calc bands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% band params
bandNames = ffOut.peaks.info.bandNames;
bandFreqs = ffOut.peaks.info.bandFreqs; 
nbands = length(bandNames);

% sum power in bands from residual psd
ffOut.bandPow = nan(nBouts, nbands);
for iband = 1 : nbands
    mask_band = ffOut.freqs >= bandFreqs(iband, 1) & ffOut.freqs < bandFreqs(iband, 2);
    ffOut.bandPow(:, iband) = sum(ffOut.psd_res(:, mask_band), 2);
end

% plot
if flg_plot
    fh = psd_fooofPlot(ffOut);
end

% organize info
ffOut.info.runtime = datetime("now");
ffOut.info.cfg = fooof_cfg;



% save
if saveVar
    save(fname, 'ffOut')
end

end

% EOF

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% local functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% calculate model fit metrics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function ffit = calc_fit(fmdl)

% Number of data points
n = length(fmdl.power_spectrum);

% Number of parameters (peaks + aperiodic)
k = length(fmdl.gaussian_params(:)) + size(fmdl.aperiodic_params, 2);

% Root Mean Squared Error of the model fit (difference between original and model fit)
ffit.rmse = sqrt(mean((fmdl.power_spectrum - fmdl.fooofed_spectrum) .^ 2));

% Log-likelihood of the model fit
ffit.loglik = -n / 2 * (log(2 * pi) + log(ffit.rmse) + 1);

% Akaike Information Criterion
ffit.aic = 2 * k - 2 * ffit.loglik;

% Bayesian Information Criterion
ffit.bic = k * log(n) - 2 * ffit.loglik;

% r-squared
coefs = corrcoef(fmdl.power_spectrum, fmdl.fooofed_spectrum);
ffit.r_squared = coefs(1, 2);

end

% organize output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function ffOut = fooof_org(ffIn) 

ffOut.freqs = squeeze(ffIn.freqs(1, :, 1)); 
nBouts = length(ffIn.aperiodic_params(1, 1, :));
nFreqs = length(ffOut.freqs);

% Convert from power to linear
ffOut.psd_orig = reshape([10 .^ squeeze(ffIn.power_spectrum)]', [nBouts, nFreqs]);
ffOut.psd_fit = reshape([10 .^ squeeze(ffIn.fooofed_spectrum)]', [nBouts, nFreqs]);
ffOut.psd_ap = reshape([10 .^ squeeze(ffIn.ap_fit)]', [nBouts, nFreqs]);
ffOut.psd_res = log10(ffOut.psd_orig) - log10(ffOut.psd_ap);
ffOut.psd_res_fit = log10(ffOut.psd_fit) - log10(ffOut.psd_ap);

% Aperiodic parameters - can be [1x2] or [1x3]
ffOut.ap.offset = squeeze(ffIn.aperiodic_params(:, 1, :));
if size(ffIn.aperiodic_params, 2) == 2
    ffOut.ap.knee = nan(nBouts, 1); 
    ffOut.ap.exp = squeeze(ffIn.aperiodic_params(:, 2, :));
else
    ffOut.ap.knee = squeeze(ffIn.aperiodic_params(:, 2, :));
    ffOut.ap.exp = squeeze(ffIn.aperiodic_params(:, 3, :));
end

% Peak parameters need to be processed by peaks2bands
% peaks2bands will take the struct array and return [nbands x 3 x nBouts]
[pParams, gParams, band_info] = peaks2bands(ffIn);
ffOut.peaks.info = band_info; % Contains bandFreqs, bandNames

% peak_params_banded is [nbands x 3 x nBouts]
% We want cf, pow, bw as [nBouts x nbands]
ffOut.peaks.cf = squeeze(pParams(:, 1, :))';            % Center frequency 
ffOut.peaks.pow = squeeze(pParams(:, 2, :))';           % Power
ffOut.peaks.bw = squeeze(pParams(:, 3, :))';            % Bandwidth

% gaussian_params_banded is [nbands x 3 x nBouts]
% We want amp, sd as [nBouts x nbands]
ffOut.peaks.amp = squeeze(gParams(:, 2, :))';           % Amplitude
ffOut.peaks.sd = squeeze(gParams(:, 3, :))';            % Standard deviation

% add probability of detecting an oscillation in each band
[~, nBands] = size(ffOut.peaks.cf); % cf is now [nBouts x nbands]
ffOut.peaks.prob = nan(1, nBands); 
for iband = 1 : nBands
    ffOut.peaks.prob(1, iband) = sum(~isnan(ffOut.peaks.pow(:, iband))) / nBouts;
end

end

% restructure peaks according to pre-defined frequency bands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [pParams, gParams, info] = peaks2bands(ffIn) % Input is struct array [nBouts x 1]

% band params
info.bandNames = ["delta", "theta", "gamma"];
info.bandFreqs = [0, 5.5; 5.5, 12; 30, 100]; 
nbands = length(info.bandNames);
nBouts = length(ffIn.aperiodic_params(1, 1, :));

% Initialize output arrays: [nbands x 3 params x nBouts]
pParams = nan(nbands, 3, nBouts);
gParams = nan(nbands, 3, nBouts);

% Loop through bouts (elements of the struct array fd)
for ibout = 1 : nBouts
    pBout = ffIn.peak_params(:, :, ibout);            % [nPeaks x 3]
    gBout = ffIn.gaussian_params(:, :, ibout);        % [nPeaks x 3]
    
    if isempty(pBout) || all(isnan(pBout(:)))
        continue; % Skip if no peaks for this bout
    end

    peak_freqs = pBout(:, 1);
    peak_powers = pBout(:, 2);          

    % For each band
    for iband = 1 : nbands
        
        % Find peaks in this band
        band_mask = peak_freqs >= info.bandFreqs(iband,1) &...
            peak_freqs < info.bandFreqs(iband,2);

        if any(band_mask)
            
            % Get power of peaks in this band
            powBand = peak_powers(band_mask);
            idxBand = find(band_mask);

            % Find index of highest power peak in this band (relative to selection)
            [~, idxMax] = max(powBand);
            
            % Get the original index from current_bout_peak_params
            idxPeak = idxBand(idxMax);

            % Store parameters for highest power peak
            pParams(iband, :, ibout) = pBout(idxPeak, :);
            gParams(iband, :, ibout) = gBout(idxPeak, :);
        end
    end
end
end


