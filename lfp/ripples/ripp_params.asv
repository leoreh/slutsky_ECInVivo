function ripp = ripp_params(rippSig, ripp)
% RIPP_PARAMS Calculates physiological parameters for ripple events.
%
%   ripp = RIPP_PARAMS(rippSig, ripp)
%
%   SUMMARY:
%       Computes "Best Practice" parameters for each event using the
%       pre-processed signals.
%       1. Duration: Exact time difference (End - Start).
%       2. Peak Amplitude: Envelope amplitude at the peak index.
%       3. Mean Frequency: Average instantaneous frequency (Hz).
%       4. Total Energy: Sum of squared filtered signal (Integrated Power).
%       5. Skewness: Center of Mass of the envelope relative to peak (in ms).
%
%   INPUTS:
%       rippSig     - (Struct) Signal structure (requires .filt, .amp, .freq).
%       ripp        - (Struct) Event structure with .times and .peakTime.
%                              Must contain .info.fs.
%
%   OUTPUTS:
%       ripp        - (Struct) Updated structure with new fields:
%                       .amp       (N x 1) [uV]
%                       .freq      (N x 1) [Hz]
%                       .energy    (N x 1) [uV^2]
%                       .dur       (N x 1) [ms]
%                       .skew      (N x 1) [ms]
%
%   DEPENDENCIES:
%       None.
%
%   HISTORY:
%       Updated: 23 Jan 2026

%% ========================================================================
%  ARGUMENTS & SETUP
%  ========================================================================

fs = ripp.info.fs;
nEvents = size(ripp.times, 1);
nSamples = length(rippSig.filt);

% Initialize Output Structure
ripp.amp = nan(nEvents, 1);
ripp.freq = nan(nEvents, 1);
ripp.energy = nan(nEvents, 1);
ripp.dur = nan(nEvents, 1);
ripp.skew = nan(nEvents, 1);

% Convert Times to Samples (1-based indexing)
% We use max/min to ensure we don't index outside the signal bounds
startSamps = max(1, round(ripp.times(:, 1) * fs) + 1);
endSamps   = min(nSamples, round(ripp.times(:, 2) * fs) + 1);
peakSamps  = round(ripp.peakTime * fs) + 1;

% Ensure peaks are within bounds (sanity check)
peakSamps = max(1, min(nSamples, peakSamps));

% Fixed window for skewness calculation (avoid duration bias)
winFxd = 0.020; 
nWin = round(winFxd * fs);

%% ========================================================================
%  CALCULATE PARAMETERS
%  ========================================================================

for iEvent = 1:nEvents
    
    % Fixed window indices 
    idxSkew = (peakSamps(iEvent) - nWin) : (peakSamps(iEvent) + nWin);
    idxSkew = idxSkew(idxSkew >= 1 & idxSkew <= nSamples);
    
    % Duration (ms)
    % Calculated directly from timestamps for precision
    ripp.dur(iEvent) = (ripp.times(iEvent, 2) - ripp.times(iEvent, 1)) * 1000;

    % Peak Amplitude (uV)
    % Instantaneous amplitude of the envelope at the exact peak index
    ripp.amp(iEvent) = rippSig.amp(peakSamps(iEvent));

    % Define the full event dur window
    idxDur = startSamps(iEvent) : endSamps(iEvent);

    % Check for valid window indices
    if isempty(idxDur), continue; end

    % Mean Frequency (Hz)
    % Average of the instantaneous frequency across the entire event
    if isfield(rippSig, 'freq')
        ripp.freq(iEvent) = mean(rippSig.freq(idxDur), 'omitnan');
    end

    % Total Energy (uV^2)
    % Sum of the squared filtered signal over the dur.
    % This represents the total integrated power of the event.
    ripp.energy(iEvent) = sum(rippSig.filt(idxDur) .^ 2, 'omitnan');

    % Skewness (ms)
    % Center of Mass of the Hilbert Envelope relative to the Peak Time.
    evtAmp = rippSig.amp(idxSkew);
    tRel = (idxSkew(:) - peakSamps(iEvent)) / fs; % Relative time in seconds
    ampSum = sum(evtAmp, 'omitnan');
    ripp.skew(iEvent) = (sum(tRel .* evtAmp, 'omitnan') / ampSum) * 1000;

end

end     % EOF