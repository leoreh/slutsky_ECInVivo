function ripp = ripp_detect(sig, fs, varargin)
% RIPP_DETECT Detects hippocampal ripple events from LFP data.
%
% SUMMARY:
% Uses provided signal 'sig' (assumed filtered) for event detection.
% Calculates detection signal, applies adaptive thresholds, refines events
% based on power/duration/EMG, and calculates event properties.
%
% INPUT:
%   sig             Numeric vector of LFP data (filtered).
%   fs              Sampling frequency [Hz].
%   varargin        'emg', 'basepath', 'thr', 'limDur', 'detectAlt', 'flgPlot', 'flgSave'.
%
% OUTPUT:
%   ripp            Structure (times, peakTime, info, maps, etc).
%
% DEPENDENCIES: binary2bouts, Sync, SyncMap, CCG, times2rate.

%% ========================================================================
%  ARGUMENTS
%  ========================================================================
p = inputParser;
addRequired(p, 'sig', @isnumeric);
addRequired(p, 'fs', @isnumeric);
addParameter(p, 'emg', [], @isnumeric);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'thr', [1.5, 2.5, 2, 200, 100], @isnumeric);
addParameter(p, 'limDur', [15, 300, 20, 10], @isnumeric);
addParameter(p, 'detectAlt', 3, @isnumeric);
addParameter(p, 'flgPlot', true, @islogical);
addParameter(p, 'flgSave', true, @islogical);

parse(p, sig, fs, varargin{:});
sig         = p.Results.sig;
fs          = p.Results.fs;
emg         = p.Results.emg;
basepath    = p.Results.basepath;
thr         = p.Results.thr;
limDur      = p.Results.limDur;
detectAlt   = p.Results.detectAlt;
flgPlot     = p.Results.flgPlot;
flgSave     = p.Results.flgSave;

ripp = ripp_initialize();


%% ========================================================================
%  SETUP
%  ========================================================================
cd(basepath);
[~, basename] = fileparts(basepath);
rippfile = fullfile(basepath, [basename, '.ripp.mat']);

timestamps = (0:length(sig)-1)' / fs;
ripp.rate.binsize = 60;

% Duration limits to samples
limDur_Samples = round(limDur / 1000 * fs);
movLen = round(10 * fs);

if ~isempty(emg) && length(emg) ~= length(sig)
    error('EMG length (%d) does not match Signal length (%d).', length(emg), length(sig));
end


%% ========================================================================
%  SIGNAL PROCESSING
%  ========================================================================
sigH = hilbert(sig);
sigAmp = abs(sigH);
sigPhase = angle(sigH);
sigUnwrapped = unwrap(sigPhase);

% Instantaneous Frequency
dt = 1/fs;
d0 = diff(medfilt1(sigUnwrapped, 12)) ./ dt;
t_diff = timestamps(1:end-1) + dt/2;
d1 = interp1(t_diff, d0, timestamps(2:end-1), 'linear', 'extrap');
sigFreq = [d0(1); d1; d0(end)] / (2 * pi);

% Detection Signal
switch detectAlt
    case 1 % Smoothed Amp
        baseSignal = sigAmp;
        winSmooth = round(0.005 * fs);
    case 2 % Smoothed Sq
        baseSignal = sig .^ 2;
        winSmooth = round(0.010 * fs);
    case 3 % Smoothed TEO
        sPad = [sig(1); sig; sig(end)];
        baseSignal = sPad(2:end-1).^2 - sPad(1:end-2) .* sPad(3:end);
        baseSignal(baseSignal < 0) = 0;
        winSmooth = round(0.005 * fs);
end
baseSignal = smoothdata(baseSignal, 'gaussian', winSmooth);

% Adaptive Threshold
localMean = movmean(baseSignal, movLen);
localStd = movstd(baseSignal, movLen);
stdFloor = 1e-6 * mean(localStd, 'omitnan');
localStd(localStd < stdFloor) = stdFloor;
sigDetect = (baseSignal - localMean) ./ localStd;


%% ========================================================================
%  DETECTION
%  ========================================================================
eventSamples = binary2bouts('vec', sigDetect > thr(1), 'minDur', limDur_Samples(1),...
    'maxDur', limDur_Samples(2), 'interDur', limDur_Samples(3));
nEvents = size(eventSamples, 1);

idxDiscard = false(nEvents, 1);
emgRms = nan(nEvents, 1);
peakPower = nan(nEvents, 1);
contPowDur = nan(nEvents, 1);
contPowAvg = nan(nEvents, 1);
avgFreq = nan(nEvents, 1);

% EMG Exclusion
if ~isempty(emg)
    for iEvent = 1:nEvents
        idx = eventSamples(iEvent,1):eventSamples(iEvent,2);
        emgRms(iEvent) = rms(emg(idx));
    end
    idxDiscard = idxDiscard | (emgRms > prctile(emgRms, thr(5)));
end

% Frequency Exclusion
if ~isempty(emg)
    for iEvent = 1:nEvents
        idx = eventSamples(iEvent,1):eventSamples(iEvent,2);
        avgFreq(iEvent) = mean(sigFreq(idx), 'omitnan');
    end

    highEmgIdx = emgRms > prctile(emgRms, 99);
    if any(highEmgIdx)
        thrFreq = mean(avgFreq(highEmgIdx));
        idxDiscard = idxDiscard | (avgFreq > thrFreq);
    end
end

% Power and Continuity thresholds
for iEvent = 1:nEvents
    if idxDiscard(iEvent), continue; end

    idx = eventSamples(iEvent,1):eventSamples(iEvent,2);
    evtPow = sigDetect(idx);

    % Peak Power
    peakPower(iEvent) = max(evtPow);
    if peakPower(iEvent) < thr(2) || peakPower(iEvent) > thr(4)
        idxDiscard(iEvent) = true;
        continue;
    end

    % Continuous Power
    above = evtPow > thr(3);
    if ~any(above)
        contPowDur(iEvent) = 0;
        contPowAvg(iEvent) = NaN;
    else
        d = [0; above(:); 0];
        on = find(diff(d)==1);
        off = find(diff(d)==-1);
        lens = off - on;
        [maxLen, maxIdx] = max(lens);

        contPowDur(iEvent) = maxLen;
        contPowAvg(iEvent) = mean(evtPow(on(maxIdx):off(maxIdx)-1));
    end

    if contPowDur(iEvent) < limDur_Samples(4)
        idxDiscard(iEvent) = true;
    end
end

% Cleanup discarded
eventSamples(idxDiscard, :) = [];
avgFreq(idxDiscard) = [];
peakPower(idxDiscard) = [];
contPowAvg(idxDiscard) = [];
contPowDur(idxDiscard) = [];
emgRms(idxDiscard) = [];

nEvents = size(eventSamples, 1);
if nEvents == 0
    warning('No valid ripples detected.');
    return;
else
    fprintf('Detected %d events.\n', nEvents);
end


%% ========================================================================
%  PROPERTIES & STATISTICS
%  ========================================================================

% Peak Finding
peakSample = zeros(nEvents, 1);
for iEvent = 1:nEvents
    idx = eventSamples(iEvent,1):eventSamples(iEvent,2);
    [~, peakRel] = min(sig(idx));
    peakSample(iEvent) = eventSamples(iEvent,1) + peakRel - 1;
end

peakTime = timestamps(peakSample);
times = timestamps(eventSamples);
dur = times(:,2) - times(:,1);

% Maps
nbinsMap = floor(fs * diff(ripp.maps.durWin) / 2) * 2 + 1;
centerBin = ceil(nbinsMap / 2);
mapArgs = {'durations', ripp.maps.durWin, 'nbins', nbinsMap, 'smooth', 0};

[r, ir] = Sync([timestamps sig], peakTime, 'durations', ripp.maps.durWin);
ripp.maps.raw = SyncMap(r, ir, mapArgs{:});
ripp.maps.filt = ripp.maps.raw;

[r, ir] = Sync([timestamps sigAmp], peakTime, 'durations', ripp.maps.durWin);
ripp.maps.amp = SyncMap(r, ir, mapArgs{:});

[r, ir] = Sync([timestamps sigPhase], peakTime, 'durations', ripp.maps.durWin);
ripp.maps.phase = SyncMap(r, ir, mapArgs{:});

[r, ir] = Sync([timestamps sigFreq], peakTime, 'durations', ripp.maps.durWin);
ripp.maps.freq = SyncMap(r, ir, mapArgs{:});

% Store Properties
ripp.times = times;
ripp.peakTime = peakTime;
ripp.dur = dur;
ripp.peakAmp = ripp.maps.amp(:, centerBin);
ripp.peakFreq = ripp.maps.freq(:, centerBin);
ripp.peakFilt = ripp.maps.filt(:, centerBin);

idxWin = centerBin + (-5:5);
ripp.peakEnergy = mean(ripp.maps.filt(:, idxWin).^2, 2);

% ACG
[ripp.acg.data, ripp.acg.t] = CCG(peakTime, ones(nEvents, 1), 'binSize', 0.01, 'duration', 1);

% Rate
[ripp.rate.rate, ripp.rate.binedges, ripp.rate.timestamps] = ...
    times2rate(peakTime, 'binsize', ripp.rate.binsize, 'winCalc', [timestamps(1) timestamps(end)], 'c2r', true);


%% ========================================================================
%  PARAMETER SUGGESTIONS
%  ========================================================================
% Analyzes detected properties to suggest data-driven thresholds

ripp.info.thrData(1) = prctile(contPowAvg, 1);
ripp.info.thrData(2) = prctile(peakPower, 10);
ripp.info.thrData(3) = prctile(contPowAvg, 10);
ripp.info.thrData(4) = prctile(peakPower, 99) * 2;
ripp.info.thrData(5) = thr(5);
ripp.info.thrData = round(ripp.info.thrData, 1);

% Note: avgFreq calculated only when EMG present in original.
% Assuming here if available it's used.
ripp.info.passbandData = [prctile(avgFreq, 2), prctile(ripp.peakFreq, 99.9)];


%% ========================================================================
%  FINALIZE
%  ========================================================================
ripp.contPowDur = contPowDur * 1000 / fs; % Convert to ms if storing
ripp.dur = ripp.dur * 1000; % ms

if flgSave
    save(rippfile, 'ripp', '-v7.3');
end

if flgPlot
    ripp_plot(ripp, 'basepath', basepath, 'flgSaveFig', true);
end

end

% -------------------------------------------------------------------------
% Helper: Initialize
% -------------------------------------------------------------------------
function ripp = ripp_initialize()
ripp = struct();
ripp.times = []; ripp.dur = []; ripp.peakTime = [];
ripp.info = struct();
ripp.maps = struct('durWin', [-0.075 0.075]);
ripp.rate = struct();
ripp.acg = struct();
% No corr substruct as requested
end
