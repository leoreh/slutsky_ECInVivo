function rippSpks = ripp_spks(rippTimes, spkTimes, peakTimes, varargin)
% RIPP_SPKS Analyzes spiking activity relative to ripple events.
%
% SUMMARY:
% Analyzes single-unit (SU) and multi-unit (MU) activity during ripples.
% Calculates rates, modulation statistics, and generates PETH maps.
%
% INPUT:
%   rippTimes       [N x 2] start/end times (s).
%   spkTimes        {Nunits x 1} spike times (s).
%   peakTimes       [N x 1] ripple peak times (s).
%   varargin        'muTimes' (cell array), 'basepath', 'flgPlot', 'flgSave'.
%
% OUTPUT:
%   rippSpks        Structure of results.
%   * Saves 'basename.rippSpks.mat'.
%
% DEPENDENCIES: SubtractIntervals, Restrict, times2rate.

%% ========================================================================
%  ARGUMENTS
%  ========================================================================
p = inputParser;
addRequired(p, 'rippTimes', @isnumeric);
addRequired(p, 'spkTimes', @iscell);
addRequired(p, 'peakTimes', @isnumeric);
addParameter(p, 'muTimes', [], @isnumeric);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'flgPlot', true, @islogical);
addParameter(p, 'flgSave', true, @islogical);
addParameter(p, 'mapDur', [-0.075 0.075], @isnumeric);
parse(p, rippTimes, spkTimes, peakTimes, varargin{:});

rippTimes = p.Results.rippTimes;
spkTimes = p.Results.spkTimes;
peakTimes = p.Results.peakTimes;
muTimes = p.Results.muTimes;
basepath = p.Results.basepath;
flgPlot = p.Results.flgPlot;
flgSave = p.Results.flgSave;
mapDur = p.Results.mapDur;

%% ========================================================================
%  INITIALIZATION
%  ========================================================================
cd(basepath);
[~, basename] = fileparts(basepath);
rippSpksFile = fullfile(basepath, [basename, '.rippSpks.mat']);

nUnits = length(spkTimes);
nRipples = size(rippTimes, 1);
rippDur = rippTimes(:, 2) - rippTimes(:, 1);

% Map Params
fsLfp = 1250;
nBinsMap = floor(fsLfp * diff(mapDur) / 2) * 2 + 1;

% Output Struct
rippSpks = struct();
rippSpks.info.recWin = [0 Inf];
rippSpks.info.mapDur = mapDur;
rippSpks.info.nBinsMap = nBinsMap;
rippSpks.su = struct('pVal', nan(nUnits, 1), 'sigMod', false(nUnits, 1), ...
    'frGain', nan(nUnits, 1), 'frModulation', nan(nUnits, 1), ...
    'frPrct', nan(nUnits, 1), 'frRipp', nan(nUnits, 1), 'frRand', nan(nUnits, 1), ...
    'rippMap', [], 'ctrlMap', []);
rippSpks.mu = struct('rippMap', [], 'ctrlMap', []);

%% ========================================================================
%  CONTROL EVENTS
%  ========================================================================
% Finds non-ripple intervals of matched duration (Linear Scavenger).

recEnd = max([max(rippTimes(:)); 100]) + 10;
buffer = max(rippDur);
intervalsExclude = rippTimes + [-buffer, buffer];
intervalsInclude = [0, recEnd];
intervalsCtrl = SubtractIntervals(intervalsInclude, intervalsExclude);

% Filter short
% Note: Using ripple max dur as minimum requirement for control blocks
durIdx = diff(intervalsCtrl, 1, 2) < max(rippDur);
intervalsCtrl(durIdx, :) = [];

if isempty(intervalsCtrl)
    warning('No valid control intervals found.');
    ctrlTimes = nan(nRipples, 2);
else
    % Match Events
    nRipples = length(rippDur);
    ctrlTimes = nan(nRipples, 2);
    nFree = size(intervalsCtrl, 1);

    maxDist = 4 * 60 * 60;
    padding = 0.1;
    currentFreeIdx = 1;
    lastEndTime = -inf;

    for iRipp = 1:nRipples
        needed = rippDur(iRipp);
        while currentFreeIdx <= nFree
            blockStart = intervalsCtrl(currentFreeIdx, 1);
            blockEnd = intervalsCtrl(currentFreeIdx, 2);
            t_start = max(blockStart, lastEndTime + padding);

            if t_start + needed <= blockEnd
                if blockStart < peakTimes(iRipp) - maxDist
                    currentFreeIdx = currentFreeIdx + 1;
                    continue;
                end
                ctrlTimes(iRipp, :) = [t_start, t_start + needed];
                lastEndTime = t_start + needed;
                break;
            else
                currentFreeIdx = currentFreeIdx + 1;
            end
        end
    end
end

rippSpks.info.ctrlTimes = ctrlTimes;


%% ========================================================================
%  SU ANALYSIS
%  ========================================================================
fprintf('Analyzing %d Single Units...\n', nUnits);

if nUnits > 0
    % Firing Rates
    rippRates = times2rate(spkTimes, 'winCalc', rippTimes, 'binsize', Inf);
    ctrlRates = times2rate(spkTimes, 'winCalc', ctrlTimes, 'binsize', Inf);

    rippSpks.su.rippRates = rippRates;
    rippSpks.su.ctrlRates = ctrlRates;

    % Maps & Stats
    rippSpks.su.rippMap = nan(nUnits, nRipples, nBinsMap);
    rippSpks.su.ctrlMap = nan(nUnits, nRipples, nBinsMap);

    for iRipp = 1:nUnits
        % Stats
        rRate = rippRates(iRipp, :);
        cRate = ctrlRates(iRipp, :);

        if any(~isnan(rRate)) && any(~isnan(cRate))
            [pVal, h] = signrank(rRate, cRate);
            rippSpks.su.pVal(iRipp) = pVal;
            rippSpks.su.sigMod(iRipp) = h;

            mC = mean(cRate, 'omitnan');
            sdC = std(cRate, 0, 'omitnan');
            mR = mean(rRate, 'omitnan');

            rippSpks.su.frGain(iRipp) = (mR - mC) / sdC;
            rippSpks.su.frModulation(iRipp) = (mR - mC) / (mR + mC);
            rippSpks.su.frPrct(iRipp) = (mR - mC) / mC * 100;
            rippSpks.su.frRipp(iRipp) = mR;
            rippSpks.su.frRand(iRipp) = mC;
        end

        % Maps
        rippSpks.su.rippMap(iRipp, :, :) = sync_spksMap(spkTimes{iRipp}, ...
            peakTimes, mapDur, nBinsMap);
        rippSpks.su.ctrlMap(iRipp, :, :) = sync_spksMap(spkTimes{iRipp}, ...
            diff(ctrlTimes, 1, 2) / 2, mapDur, nBinsMap);
    end
end


%% ========================================================================
%  MU ANALYSIS
%  ========================================================================
if ~isempty(muTimes)
    fprintf('Analyzing Multi-Unit Activity...\n');
    rippSpks.mu.rippMap = sync_spksMap(muTimes, peakTimes, mapDur, nBinsMap);
    rippSpks.mu.ctrlMap = sync_spksMap(muTimes, diff(ctrlTimes, 1, 2) / 2, mapDur, nBinsMap);
else
    rippSpks.mu = [];
end

if ~isempty(rippSpks.mu)
    ctrlRates = times2rate(spkTimes, 'winCalc', ctrlTimes, 'binsize', Inf);

    cRate = mean(rippSpks.mu.ctrlMap, 2, 'omitnan');
    cMu = 
    cSigma
end

%% ========================================================================
%  SAVE & PLOT
%  ========================================================================
if flgSave
    save(rippSpksFile, 'rippSpks', '-v7.3');
    fprintf('Saved: %s\n', rippSpksFile);
end

if flgPlot
     ripp_plotSpks(rippSpks)
end

end     % EOF


%% ========================================================================
%  HELPER: SYNC MAP
%  ========================================================================
function syncMap = sync_spksMap(spikeTimes, eventTimes, mapDur, nBinsMap)

nEvents = length(eventTimes);
syncMap = zeros(nEvents, nBinsMap);

if isempty(spikeTimes) || isempty(eventTimes), return; end
spikeTimes = sort(spikeTimes(:));
eventTimes = eventTimes(:);

winStart = eventTimes + mapDur(1);
winEnd = eventTimes + mapDur(2);

searchEdges = [-inf; spikeTimes; inf];

startIdx = discretize(winStart, searchEdges);
[~, endBin] = histc(winEnd, searchEdges);
endIdx = endBin - 1;

validWin = find(endIdx >= startIdx);
if isempty(validWin), return; end

spkInEvt = endIdx(validWin) - startIdx(validWin) + 1;
evtIds = repelem(validWin, spkInEvt);

totalSpk = sum(spkInEvt);
spkIndices = zeros(totalSpk, 1);
c = 1;
for k = 1:length(validWin)
    e = validWin(k);
    n = spkInEvt(k);
    spkIndices(c:c+n-1) = startIdx(e) : endIdx(e);
    c = c+n;
end

spkVals = spikeTimes(spkIndices);
relTimes = spkVals - eventTimes(evtIds);
edges = linspace(mapDur(1), mapDur(2), nBinsMap+1);
bins = discretize(relTimes, edges);

validBin = ~isnan(bins);
finalEvtIds = evtIds(validBin);
finalBins = bins(validBin);

syncMap = accumarray([finalEvtIds, finalBins], 1, [nEvents, nBinsMap]);


end
