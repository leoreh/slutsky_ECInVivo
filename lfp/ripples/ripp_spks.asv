function rippSpks = ripp_spks(spkTimes, rippTimes, ctrlTimes, varargin)
% RIPP_SPKS Analyzes spiking rate modulation during ripples.
%
%   rippSpks = RIPP_SPKS(spkTimes, rippTimes, ctrlTimes, peakTime, varargin)
%
%   SUMMARY:
%       Calculates scalar modulation metrics comparing Ripple vs Control periods.
%       1. Instantaneous Firing Rates (FR) per event.
%       2. Mean FR differences (RippleMu vs ControlMu).
%       3. Z-Scored Gain.
%       4. Statistical Significance (Wilcoxon Sign-Rank / Rank-Sum).
%       5. Rank Order (Mean and Variance).
%       6. Population Center of Mass (CoM) per event.
%
%   INPUTS:
%       spkTimes    - (Cell) {N_units x 1} Spike times [s].
%       rippTimes   - (Mat)  [N x 2] Ripple start/end times [s].
%       ctrlTimes   - (Mat)  [N x 2] Control start/end times [s].
%       peakTime    - (Vec)  [N x 1] Peak times of ripples [s].
%       varargin    - Parameter/Value pairs:
%           'basepath' - (Char) Save location. (Default: pwd).
%           'flgSave'  - (Log)  Save output? (Default: true).
%           'unitType' - (Cat)  [N_units x 1] Categorical array of unit types.
%
%   OUTPUTS:
%       rippSpks    - (Struct) Stats structure with [N_units x 1] fields.
%
%   HISTORY:
%       Updated: 26 Jan 2026
%

% =========================================================================
%  ARGUMENTS
% =========================================================================
p = inputParser;
addRequired(p, 'spkTimes', @iscell);
addRequired(p, 'spkTimes', @iscell);
addRequired(p, 'rippTimes', @isnumeric);
addRequired(p, 'ctrlTimes', @isnumeric);
addRequired(p, 'peakTime', @isnumeric);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'flgSave', true, @islogical);
addParameter(p, 'unitType', [], @(x) iscategorical(x) || iscell(x));
parse(p, spkTimes, rippTimes, ctrlTimes, peakTime, varargin{:});

basepath  = p.Results.basepath;
flgSave   = p.Results.flgSave;
peakTime  = p.Results.peakTime; 
unitType  = p.Results.unitType;

[~, basename] = fileparts(basepath);
savefile = fullfile(basepath, [basename, '.rippSpks.mat']);

% Fixed window for asym / com
winFxd = 0.020;

% =========================================================================
%  FR METRICS
% =========================================================================

nUnits = length(spkTimes);

% Calculate Durations
durRipp = (rippTimes(:, 2) - rippTimes(:, 1))'; % [1 x nRipp]
durCtrl = (ctrlTimes(:, 2) - ctrlTimes(:, 1))'; % [1 x nRand]

% Get Spike COUNTS
rippCounts = times2rate(spkTimes, 'winCalc', rippTimes, 'binsize', Inf, 'c2r', false);
ctrlCounts = times2rate(spkTimes, 'winCalc', ctrlTimes, 'binsize', Inf, 'c2r', false);

% Calculate RATES (Hz)
rippRates = rippCounts ./ durRipp;
ctrlRates = ctrlCounts ./ durCtrl;

% Mean Rates
frRipp = mean(rippRates, 2, 'omitnan');
frRand = mean(ctrlRates, 2, 'omitnan');
sdRand = std(ctrlRates, [], 2, 'omitnan');

% Spike Count Stats
cRipp = mean(rippCounts, 2, 'omitnan');
pFire = mean(rippCounts > 0, 2, 'omitnan');

% Modulation Metrics
frZ = (frRipp - frRand) ./ sdRand;
frZ(sdRand < eps) = NaN; % Avoid infs

frSum = frRipp + frRand;
frMod = (frRipp - frRand) ./ frSum;
frMod(frSum < eps) = NaN;

% Conditional Rate / Count (intensity when active).
% Essentially equal to frRipp ./ pFire.
% Prepare matrix with NaNs where rate is 0 (inactive)
activeMat = rippRates;
activeMat(activeMat == 0) = NaN;
frActive = mean(activeMat, 2, 'omitnan');

activeMat = rippCounts;
activeMat(activeMat == 0) = NaN;
cActive = mean(activeMat, 2, 'omitnan');

% =========================================================================
%  STATISTICAL TEST
% =========================================================================

pVal = nan(nUnits, 1);
flgPair = size(rippRates, 2) == size(ctrlRates, 2);

% Pre-calculate nanflag to speed up loop skip
goodIdx = ~all(isnan(rippRates), 2) & sum(rippCounts, 2) > 0;

for iUnit = 1:nUnits
    if ~goodIdx(iUnit), continue; end

    if flgPair
        pVal(iUnit) = signrank(rippRates(iUnit, :), ctrlRates(iUnit, :));
    else
        pVal(iUnit) = ranksum(rippRates(iUnit, :), ctrlRates(iUnit, :));
    end
end
h0 = pVal < 0.05;


% =========================================================================
%  CENTER OF MASS (PER UNIT)
% =========================================================================
% Average time of spikes relative to ripple peak

com = nan(nUnits, 1);
com = nan(nUnits, 1);

peakTime = peakTime(:);
nRipp = length(peakTime);

for iUnit = 1:nUnits
    uSpks = spkTimes{iUnit};
    if isempty(uSpks), continue; end

    % Find index of nearest peak for each spike
    % We use interp1 with 'nearest' to map spike times to the "index" of the peak
    idx = interp1(peakTime, 1:nRipp, uSpks, 'nearest', 'extrap');
    nearestPeaks = peakTime(idx);
    relTime = uSpks - nearestPeaks;

    % Filter by Window
    isValid = abs(relTime) <= winFxd;

    % Calculate Mean
    if any(isValid)
        com(iUnit) = mean(relTime(isValid)) * 1000;     % (ms)
    end
end

% =========================================================================
%  ASYMMETRY (PER UNIT)
% =========================================================================

% Asymmetry (Per Unit)
% Define Intervals (Fixed Window)
timesMid = peakTime;
timesPre  = [timesMid - winFxd, timesMid];
timesPost = [timesMid, timesMid + winFxd];

% Durations
durPre  = timesPre(:,2) - timesPre(:,1);
durPost = timesPost(:,2) - timesPost(:,1);

% Spike Counts (all units)
cPre  = times2rate(spkTimes, 'winCalc', timesPre, 'binsize', Inf, 'c2r', false);
cPost = times2rate(spkTimes, 'winCalc', timesPost, 'binsize', Inf, 'c2r', false);

% Rates
frPre  = sum(cPre, 2) ./ sum(durPre);
frPost = sum(cPost, 2) ./ sum(durPost);

% Asymmetry Index (Unit)
% (Pre - Post) / (Pre + Post)
frSum = frPre + frPost;
asym = (frPre - frPost) ./ frSum;
asym(frSum < eps) = NaN;

% =========================================================================
%  PER RIPPLE / UNITTYPE
% =========================================================================

% Initialize Output Containers
rankMean   = nan(nUnits, 1);
rankVar    = nan(nUnits, 1);
timesFirst = cell(nUnits, 1);
timesLate  = cell(nUnits, 1);

% Prepare Iteration (Global vs Types)
if isempty(unitType)
    iterNames = {'Global'};
    iterMasks = {true(nUnits, 1)};
else
    uTypes = unique(unitType);
    uTypes(isundefined(uTypes)) = [];
    uTypes(uTypes == 'Other') = [];

    iterNames = cellstr(uTypes);
    iterMasks = cell(length(uTypes), 1);
    for iType = 1:length(uTypes)
        iterMasks{iType} = unitType == uTypes(iType);
    end
end

% Initialize Events Structure
rippSpks.events = struct();

% Loop
for iIter = 1:length(iterNames)
    currName = iterNames{iIter};
    currMask = iterMasks{iIter};

    if sum(currMask) == 0, continue; end

    % --- Rank & Timing ---
    subSpks = spkTimes(currMask);
    [subMean, subVar, subFirst, subLate] = ripp_rankOrder(subSpks, rippTimes);

    % Fill Global Arrays
    rankMean(currMask)   = subMean;
    rankVar(currMask)    = subVar;
    timesFirst(currMask) = subFirst;
    timesLate(currMask)  = subLate;

    % --- Population Stats (Per Ripple) ---

    % Counts for this subset
    subCounts = rippCounts(currMask, :);

    % Fraction Participation
    % (Active Units in Group / Total Units in Group)
    nActive = sum(subCounts > 0, 1); % [1 x nRipp]
    nTotal  = sum(currMask);
    currFrac = (nActive ./ nTotal)';

    % Asymmetry (Per Ripple)
    currAsym = nan(1, size(rippTimes, 1));
    % Asymmetry (Per Ripple)
    currAsym = nan(1, size(rippTimes, 1));

    subPre  = cPre(currMask, :);
    subPost = cPost(currMask, :);

    ratePre  = sum(subPre, 1) ./ durPre';
    ratePost = sum(subPost, 1) ./ durPost';

    frSum = ratePre + ratePost;
    currAsym = (ratePre - ratePost) ./ frSum;
    currAsym(frSum < eps) = NaN;

    % --- Center of Mass (Per Ripple) ---
    % Calculate the center of mass of spikes relative to the ripple peak.
    % This is done by aggregating all spikes from the current unit group.
    currCom = nan(size(rippTimes, 1), 1);
    % --- Center of Mass (Per Ripple) ---
    % Calculate the center of mass of spikes relative to the ripple peak.
    % This is done by aggregating all spikes from the current unit group.
    currCom = nan(size(rippTimes, 1), 1);

    % Collect all spikes from the current unit selection
    grpSpks = vertcat(subSpks{:});

    % Find nearest ripple peak for each spike
    peakIdx = interp1(peakTime, 1:length(peakTime), grpSpks, 'nearest', 'extrap');

    % Calculate relative time
    tRel = grpSpks - peakTime(peakIdx);

    % Filter spikes within fixed window
    inWin = abs(tRel) <= winFxd;

    if any(inWin)
        valIdx = peakIdx(inWin);
        valRel = tRel(inWin);

        % Calculate Mean CoM per Ripple (in ms)
        currCom = accumarray(valIdx, valRel, [length(peakTime), 1], @mean, NaN) * 1000;
    end

    % --- Store Results ---
    fn = matlab.lang.makeValidName(currName);
    rippSpks.events.(fn).frac = currFrac;
    rippSpks.events.(fn).asym = currAsym';
    rippSpks.events.(fn).com  = currCom;
end



% =========================================================================
%  OUTPUT & SAVE
% =========================================================================

% Pack results
rippSpks.cRipp     = cRipp;
rippSpks.frRipp    = frRipp;
rippSpks.frRand    = frRand;
rippSpks.frZ       = frZ;
rippSpks.frMod     = frMod;
rippSpks.pFire     = pFire;
rippSpks.frActive  = frActive;
rippSpks.cActive   = cActive;
rippSpks.pVal      = pVal;
rippSpks.h0        = h0;
rippSpks.rankMean  = rankMean;
rippSpks.rankVar   = rankVar;
rippSpks.com       = com;

rippSpks.frPre    = frPre;
rippSpks.frPost   = frPost;
rippSpks.asym = asym;

% Export Times
rippSpks.times.first = timesFirst;
rippSpks.times.late  = timesLate;

% Save
if flgSave
    save(savefile, 'rippSpks', '-v7.3');
end

end     % EOF