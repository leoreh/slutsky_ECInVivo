function rippSpks = ripp_spks(spkTimes, rippTimes, ctrlTimes, varargin)
% RIPP_SPKS Analyzes spiking rate modulation during ripples.
%
%   rippSpks = RIPP_SPKS(spkTimes, rippTimes, ctrlTimes, varargin)
%
%   SUMMARY:
%       Calculates scalar modulation metrics comparing Ripple vs Control periods.
%       1. Instantaneous Firing Rates (FR) per event.
%       2. Mean FR differences (RippleMu vs ControlMu).
%       3. Z-Scored Gain.
%       4. Statistical Significance (Wilcoxon Sign-Rank / Rank-Sum).
%       5. Rank Order (Mean and Variance).
%
%   INPUTS:
%       spkTimes    - (Cell) {N_units x 1} Spike times [s].
%       rippTimes   - (Mat)  [N x 2] Ripple start/end times [s].
%       ctrlTimes   - (Mat)  [N x 2] Control start/end times [s].
%       varargin    - Parameter/Value pairs:
%           'basepath' - (Char) Save location. (Default: pwd).
%           'flgSave'  - (Log)  Save output? (Default: true).
%           'peakTime' - (Vec)  [N x 1] Peak times of ripples [s].
%           'unitType' - (Cat)  [N_units x 1] Categorical array of unit types.
%
%   OUTPUTS:
%       rippSpks    - (Struct) Stats structure with [N_units x 1] fields.
%
%   HISTORY:
%       Updated: 26 Jan 2026
%

% =========================================================================
%  ARGUMENTS
% =========================================================================
p = inputParser;
addRequired(p, 'spkTimes', @iscell);
addRequired(p, 'rippTimes', @isnumeric);
addRequired(p, 'ctrlTimes', @isnumeric);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'flgSave', true, @islogical);
addParameter(p, 'peakTime', [], @isnumeric);
addParameter(p, 'unitType', [], @(x) iscategorical(x) || iscell(x));
parse(p, spkTimes, rippTimes, ctrlTimes, varargin{:});

basepath  = p.Results.basepath;
flgSave   = p.Results.flgSave;
peakTime  = p.Results.peakTime;
unitType  = p.Results.unitType;

[~, basename] = fileparts(basepath);
savefile = fullfile(basepath, [basename, '.rippSpks.mat']);

% =========================================================================
%  CALCULATION
% =========================================================================

nUnits = length(spkTimes);

% Calculate Durations
durRipp = (rippTimes(:, 2) - rippTimes(:, 1))'; % [1 x nRipp]
durCtrl = (ctrlTimes(:, 2) - ctrlTimes(:, 1))'; % [1 x nRand]

% Get Spike COUNTS
rippCounts = times2rate(spkTimes, 'winCalc', rippTimes, 'binsize', Inf, 'c2r', false);
ctrlCounts = times2rate(spkTimes, 'winCalc', ctrlTimes, 'binsize', Inf, 'c2r', false);

% Calculate RATES (Hz)
rippRates = rippCounts ./ durRipp;
ctrlRates = ctrlCounts ./ durCtrl;

% Mean Rates
frRipp = mean(rippRates, 2, 'omitnan');
frRand = mean(ctrlRates, 2, 'omitnan');
sdRand = std(ctrlRates, [], 2, 'omitnan');

% Spike Count Stats
cRipp = mean(rippCounts, 2, 'omitnan');
pFire = mean(rippCounts > 0, 2, 'omitnan');

% Modulation Metrics
frZ = (frRipp - frRand) ./ sdRand;
frZ(sdRand < eps) = NaN; % Avoid infs

frSum = frRipp + frRand;
frMod = (frRipp - frRand) ./ frSum;
frMod(frSum < eps) = NaN;

% Conditional Rate / Count (intensity when active).
% Essentially equal to frRipp ./ pFire.
% Prepare matrix with NaNs where rate is 0 (inactive)
activeMat = rippRates;
activeMat(activeMat == 0) = NaN;
frActive = mean(activeMat, 2, 'omitnan');

activeMat = rippCounts;
activeMat(activeMat == 0) = NaN;
cActive = mean(activeMat, 2, 'omitnan');

% =========================================================================
%  STATISTICAL TEST
% =========================================================================

pVal = nan(nUnits, 1);
flgPair = size(rippRates, 2) == size(ctrlRates, 2);

% Pre-calculate nanflag to speed up loop skip
goodIdx = ~all(isnan(rippRates), 2) & sum(rippCounts, 2) > 0;

for iUnit = 1:nUnits
    if ~goodIdx(iUnit), continue; end

    if flgPair
        pVal(iUnit) = signrank(rippRates(iUnit, :), ctrlRates(iUnit, :));
    else
        pVal(iUnit) = ranksum(rippRates(iUnit, :), ctrlRates(iUnit, :));
    end
end
h0 = pVal < 0.05;

% =========================================================================
%  ASYMMETRY (PER UNIT)
% =========================================================================

if ~isempty(peakTime)
    % Define Intervals
    timesMid = peakTime;
    timesPre  = [rippTimes(:,1), timesMid];
    timesPost = [timesMid, rippTimes(:,2)];

    % Durations
    durPre  = timesPre(:,2) - timesPre(:,1);
    durPost = timesPost(:,2) - timesPost(:,1);

    % Spike Counts (all units)
    cPre  = times2rate(spkTimes, 'winCalc', timesPre, 'binsize', Inf, 'c2r', false);
    cPost = times2rate(spkTimes, 'winCalc', timesPost, 'binsize', Inf, 'c2r', false);

    % Rates
    frPre  = sum(cPre, 2) ./ sum(durPre);
    frPost = sum(cPost, 2) ./ sum(durPost);

    % Asymmetry Index (Unit)
    % (Pre - Post) / (Pre + Post)
    frSum = frPre + frPost;
    asym = (frPre - frPost) ./ frSum;
    asym(frSum < eps) = NaN;
else
    frPre  = nan(nUnits, 1);
    frPost = nan(nUnits, 1);
    asym = nan(nUnits, 1);
end

% =========================================================================
%  PER RIPPLE / UNITTYPE
% =========================================================================

% Initialize Output Containers
rankMean   = nan(nUnits, 1);
rankVar    = nan(nUnits, 1);
timesFirst = cell(nUnits, 1);
timesLate  = cell(nUnits, 1);

% Prepare Iteration (Global vs Types)
if isempty(unitType)
    iterNames = {'Global'};
    iterMasks = {true(nUnits, 1)};
else
    uTypes = unique(unitType);
    uTypes(isundefined(uTypes)) = [];
    uTypes(uTypes == 'Other') = [];

    iterNames = cellstr(uTypes);
    iterMasks = cell(length(uTypes), 1);
    for iType = 1:length(uTypes)
        iterMasks{iType} = unitType == uTypes(iType);
    end
end

% Initialize Events Structure
rippSpks.events = struct();

% Loop
for iIter = 1:length(iterNames)
    currName = iterNames{iIter};
    currMask = iterMasks{iIter};

    if sum(currMask) == 0, continue; end

    % --- Rank & Timing ---
    subSpks = spkTimes(currMask);
    [subMean, subVar, subFirst, subLate] = ripp_rankOrder(subSpks, rippTimes);

    % Fill Global Arrays
    rankMean(currMask)   = subMean;
    rankVar(currMask)    = subVar;
    timesFirst(currMask) = subFirst;
    timesLate(currMask)  = subLate;

    % --- Population Stats (Per Ripple) ---

    % Counts for this subset
    subCounts = rippCounts(currMask, :);

    % Fraction Participation
    % (Active Units in Group / Total Units in Group)
    nActive = sum(subCounts > 0, 1); % [1 x nRipp]
    nTotal  = sum(currMask);
    currFrac = (nActive ./ nTotal)';

    % Asymmetry (Per Ripple)
    currAsym = nan(1, size(rippTimes, 1));
    if ~isempty(peakTime)
        subPre  = cPre(currMask, :);
        subPost = cPost(currMask, :);

        ratePre  = sum(subPre, 1) ./ durPre';
        ratePost = sum(subPost, 1) ./ durPost';

        frSum = ratePre + ratePost;
        currAsym = (ratePre - ratePost) ./ frSum;
        currAsym(frSum < eps) = NaN;
    end

    % --- Store Results ---
    fn = matlab.lang.makeValidName(currName);
    rippSpks.events.(fn).frac = currFrac;
    rippSpks.events.(fn).asym = currAsym';
end


% =========================================================================
%  CENTER OF MASS (COM)
% =========================================================================
% Average time of spikes relative to ripple peak (within +/- 30 ms)

com = nan(nUnits, 1);
winCOM = 0.030; 

if ~isempty(peakTime) 

    peakTime = peakTime(:);
    nRipp = length(peakTime);

    % Prepare for search
    % Find the nearest peak for every spike.
    for iUnit = 1:nUnits
        uSpks = spkTimes{iUnit};
        if isempty(uSpks), continue; end

        relTime = [];

        if nRipp == 1
            % Single ripple case
            d = uSpks - peakTime;
            relTime = d;
        else
            % Multiple ripples
            % Find index of nearest peak for each spike
            % We use interp1 with 'nearest' to map spike times to the "index" of the peak
            % Domain is time, Range is Index 1..N
            % Note: peaks must be unique. If duplicates exist (rare/bad), this handles it roughly.

            % To use interp1, X must be distinct. Ripples should be.
            % But interp1 needs at least 2 points.

            idx = interp1(peakTime, 1:nRipp, uSpks, 'nearest', 'extrap');

            % If interp1 returns neighbors, calculate diff
            nearestPeaks = peakTime(idx);
            relTime = uSpks - nearestPeaks;
        end

        % Filter by Window
        isValid = abs(relTime) <= winCOM;

        % Calculate Mean
        if any(isValid)
            com(iUnit) = mean(relTime(isValid));
        end
    end
end


% =========================================================================
%  OUTPUT & SAVE
% =========================================================================

% Pack results
rippSpks.cRipp     = cRipp;
rippSpks.frRipp    = frRipp;
rippSpks.frRand    = frRand;
rippSpks.frZ       = frZ;
rippSpks.frMod     = frMod;
rippSpks.pFire     = pFire;
rippSpks.frActive  = frActive;
rippSpks.cActive   = cActive;
rippSpks.pVal      = pVal;
rippSpks.h0        = h0;
rippSpks.rankMean  = rankMean;
rippSpks.rankVar   = rankVar;
rippSpks.com       = com;

rippSpks.frPre    = frPre;
rippSpks.frPost   = frPost;
rippSpks.asym = asym;

% Export Times
rippSpks.times.first = timesFirst;
rippSpks.times.late  = timesLate;

% Save
if flgSave
    save(savefile, 'rippSpks', '-v7.3');
end

end     % EOF