function ripp = ripp_states(ripp, boutTimes, varargin)
% RIPP_STATES Analyzes ripple events in relation to vigilance states.
%
% SUMMARY:
% This function calculates ripple rates and densities within different
% vigilance states.
%
% INPUT:
%   ripp                Structure with fields: .peakTime, .dur, .info.recWin.
%   boutTimes           Cell array of state times (e.g. ss.bouts.times).
%   basepath            (Optional) Path to session {pwd}.
%   flgPlot             (Optional) Plot results {true}.
%   flgSave             (Optional) Save 'rippStates' struct to disk {true}.
%   flgSaveFig          (Optional) Save figure {true}.
%
% OUTPUT:
%   ripp                Input structure with .states field added.
%   * Saves 'basename.rippStates.mat' containing 'rippStates' struct.
%
% DEPENDENCIES: 
%   basepaths2vars
%   InIntervals
%   times2rate
% as_loadConfig.

%% ========================================================================
%  ARGUMENTS
%  ========================================================================
p = inputParser;
addRequired(p, 'ripp', @isstruct);
addRequired(p, 'boutTimes', @iscell);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'flgPlot', true, @islogical);
addParameter(p, 'flgSave', true, @islogical);
addParameter(p, 'flgSaveFig', true, @islogical);
parse(p, ripp, boutTimes, varargin{:});

ripp = p.Results.ripp;
boutTimes = p.Results.boutTimes;
basepath = p.Results.basepath;
flgPlot = p.Results.flgPlot;
flgSave = p.Results.flgSave;
flgSaveFig = p.Results.flgSaveFig;

%% ========================================================================
%  INITIALIZATION
%  ========================================================================
cd(basepath);
[~, basename] = fileparts(basepath);
savefile = fullfile(basepath, [basename, '.rippStates.mat']);

nStates = length(boutTimes);
nRipples = length(ripp.peakTime);
recWin = ripp.info.recWin;

% Initialize Output Struct
rippStates = struct();
rippStates.rate = cell(nStates, 1);     % Rate [Hz] per bout
rippStates.density = cell(nStates, 1);  % Density [s/s] per bout
rippStates.idx = false(nRipples, nStates); % [N x S] Logical index
rippStates.binedges = cell(nStates, 1);
rippStates.tstamps = cell(nStates, 1);

%% ========================================================================
%  CALCULATION
%  ========================================================================
fprintf('Calculating ripple states for %s...\n', basename);

for iState = 1:nStates
    bouts = boutTimes{iState};

    % Restrict bouts to recording window
    if ~isempty(bouts)
        valid = InIntervals(mean(bouts, 2), recWin);
        bouts = bouts(valid, :);
        bouts(:, 1) = max(bouts(:, 1), recWin(1));
        bouts(:, 2) = min(bouts(:, 2), recWin(2));
        bouts(diff(bouts, 1, 2) <= 0, :) = [];
    end

    if isempty(bouts)
        rippStates.rate{iState} = NaN;
        rippStates.density{iState} = NaN;
        continue;
    end

    % Ripple Rate (per bout)
    [rippStates.rate{iState}, rippStates.binedges{iState}, rippStates.tstamps{iState}] = ...
        times2rate(ripp.peakTime, 'binsize', Inf, 'winCalc', bouts, 'c2r', true);

    % Ripple Density (per bout)
    nBouts = size(bouts, 1);
    boutDensity = zeros(nBouts, 1);
    for iBout = 1:nBouts
        inBout = (ripp.peakTime >= bouts(iBout,1)) & (ripp.peakTime <= bouts(iBout,2));

        % Density = Total Duration of Ripples / Bout Duration
        totalRippDur_s = sum(ripp.dur(inBout)) / 1000;
        boutDur_s = bouts(iBout, 2) - bouts(iBout, 1);

        if boutDur_s > 0
            boutDensity(iBout) = totalRippDur_s / boutDur_s;
        end
    end
    rippStates.density{iState} = boutDensity;

    % Index
    rippStates.idx(:, iState) = InIntervals(ripp.peakTime, bouts);
end

%% ========================================================================
%  OUTPUT & SAVING
%  ========================================================================
ripp.states = rippStates; % Attach to main struct for potential use in memory

if flgSave
    save(savefile, 'rippStates', '-v7.3');
    fprintf('Saved: %s\n', savefile);
end

%% ========================================================================
%  PLOTTING
%  ========================================================================
if flgPlot

    % Attempt to load colors config
    try
        cfg = as_loadConfig([]);
        colors = cfg.colors;
        stateNames = arrayfun(@(x) sprintf('State %d',x), 1:nStates, 'UniformOutput', false);
    catch
        colors = lines(nStates);
        stateNames = arrayfun(@(x) sprintf('State %d',x), 1:nStates, 'UniformOutput', false);
    end

    fh = figure('Name', [basename '_rippleStates'], 'NumberTitle', 'off');

    % Rate
    subplot(2, 4, [1, 2]);
    if isfield(ripp, 'rate') && ~isempty(ripp.rate)
        % Ensure ripp.rate.timestamps exists
        if isfield(ripp.rate, 'timestamps')
            plot(ripp.rate.timestamps / 3600, ripp.rate.rate, 'k', 'LineWidth', 1);
        end
    end
    hold on;
    for iState = 1:nStates
        if ~isempty(rippStates.tstamps{iState})
            plot(rippStates.tstamps{iState} / 3600, ...
                rippStates.rate{iState}, '.', ...
                'Color', colors{iState}, ...
                'MarkerSize', 10);
        end
    end
    xlabel('Time (h)'); ylabel('Rate (Hz)'); title('Ripple Rate');
    axis tight;

    % Density
    subplot(2, 4, [5, 6]);
    hold on;
    for iState = 1:nStates
        if ~isempty(rippStates.tstamps{iState})
            plot(rippStates.tstamps{iState} / 3600, ...
                rippStates.density{iState}, '.', ...
                'Color', colors{iState}, ...
                'MarkerSize', 10);
        end
    end
    xlabel('Time (h)'); ylabel('Density (s/s)'); title('Ripple Density');
    axis tight;

    % Pie
    subplot(2, 4, [3, 4, 7, 8]);
    counts = sum(rippStates.idx, 1);
    if sum(counts) > 0
        pie(counts, ones(size(counts)));
        legend(stateNames, 'Location', 'bestoutside');
        title('Ripple State Distribution');
    end

    sgtitle([basename ' - Ripple States'], 'Interpreter', 'none');

    if flgSaveFig
        figDir = fullfile(basepath, 'graphics');
        if ~exist(figDir, 'dir')
            mkdir(figDir);
        end
        saveas(fh, fullfile(figDir, [basename '_ripp_states.png']));
    end
end

end