function as_stateSeparation(EEG, EMG, labels, varargin)

% plot the separation of states based on emg (rms) and eeg (spectrogram)
% signals
%
% INPUT:
%   EMG             numeric. emg data (1 x n)
%   EEG             numeric. eeg data (1 x n)
%   labels          numeric. 
%   stateEpochs     cell of nstates where each cell contains an 2 x n
%                   describing the start and end of an epoch
%   fs              numeric. sampling frequency
%   saveFig         logical. save figure {true}
%
% DEPENDENCIES
%   AccuSleep (modified in slutskycode)
%   IOSR.DSP.SINCFILTER     for filtering data
% 
% TO DO LIST
%   calc fft power through spectrogram
%
% 08 jun 21 LH  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p = inputParser;
addOptional(p, 'stateEpochs', []);
addOptional(p, 'fs', []);
addOptional(p, 'saveFig', true, @islogical);

parse(p, varargin{:})
stateEpochs     = p.Results.stateEpochs;
fs              = p.Results.fs;
saveFig         = p.Results.saveFig;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% preparations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

basepath = pwd;
[~, basename] = fileparts(basepath);

% constants
epochLen = 1;        
minBoutLen = epochLen;

% get params from configuration file
[cfg_colors, cfg_names, ~] = as_loadConfig([]);
cfg_colors = cfg_colors(:);
nstates = length(cfg_names);
sstates = 1 : nstates - 1;      % selected states (ignore bin)

% validate data
if length(EEG) ~= length(EMG)
    error('EEG and EMG must be the same length')
end

if isempty(fs)
    fs = 1250;
end
newFs = 128;

tic;
fprintf('\nPreparing signals, this may take some time...')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prep signals (similar pipeline to AccuSleep_classify)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% standardize
eeg = standardizeSR(EEG, fs, newFs);
emg = standardizeSR(EMG, fs, newFs);
eeg = eeg(:);
emg = emg(:);

% calibration 
calibrationData = createCalibrationData(eeg,...
    emg, labels, newFs, epochLen);

calibrationData = createCalibrationData(EEG,...
    EMG, labels, fs, epochLen);

% select relavent labels
labelsIdx = find(labels < nstates);

% create spectrogram
[specDisp, taxis, f] = createSpectrogram(eeg, newFs, epochLen);

% frequency indices
[~, f1idx] = min(abs(f - 1));
[~, f4idx] = min(abs(f - 4));
[~, f6idx] = min(abs(f - 6));
[~, f12idx] = min(abs(f - 12));
[~, f20idx] = min(abs(f - 20)); % index in f of 20Hz
[~, f50idx] = min(abs(f - 50)); % index in f of 50Hz

% select frequencies up to 50 Hz, and downsample between 20 and 50 Hz
specNorm = specDisp(:, [1 : (f20idx - 1), f20idx : 2 : f50idx]);
% take log
specNorm = log(specNorm);
% scale the spectrogram
for j = 1:size(specNorm, 2)
    specNorm(:, j) = (specNorm(:, j) - calibrationData(j, 1)) ./ calibrationData(j, 2);
    specNorm(:, j) = (specNorm(:, j) + 4.5) ./ 9; % clip z scores
end
% clip
specNorm(specNorm < 0) = 0;
specNorm(specNorm > 1) = 1;

sDelta = sum(specNorm(:, f1idx : f4idx), 2);
sTheta = sum(specNorm(:, f6idx : f12idx), 2);
sRatio = sDelta ./ sTheta;

% calculate log rms for each EMG bin
processedEMG = processEMG(emg, newFs, epochLen);

% scale the EMG
processedEMG = (processedEMG - calibrationData(end, 1)) ./ calibrationData(end, 2);
processedEMG = (processedEMG + 4.5) ./ 9;

% clip
processedEMG(processedEMG < 0) = 0;
processedEMG(processedEMG > 1) = 1;

fprintf('\ndone in %.1f sec\n\n', toc)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calculate stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[psdStates, faxis, emgRMS] = psd_states('eeg', eeg, 'emg', emg,...
    'labels', labels, 'fs', newFs, 'graphics', false);

% convert labels to state epochs.
if isempty(stateEpochs)
    for istate = 1 : nstates
        binaryVec = zeros(length(labels), 1);
        binaryVec(labels == istate) = 1;
        stateEpisodes = binary2epochs('vec', binaryVec, 'minDur', [], 'maxDur', [],...
            'interDur', [], 'exclude', false); % these are given as indices and are equivalent to seconds
        stateEpochs{istate} = stateEpisodes * epochLen;
    end
end
epLen = cellfun(@(x) (diff(x')'), stateEpochs, 'UniformOutput', false);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graphics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

setMatlabGraphics(false)
fh = figure('Color', 'w', 'Position', [0.08, 0.04, 0.83, 0.88]);
sb1 = axes('Position' ,[0.08, 0.85, 0.83, 0.12]);   % emg vs time
sb2 = axes('Position' ,[0.08, 0.70, 0.83, 0.12]);
sb3 = axes('Position' ,[0.08, 0.42, 0.35, 0.24]);
sb4 = axes('Position' ,[0.55, 0.42, 0.35, 0.24]);
sb5 = axes('Position' ,[0.08, 0.08, 0.35, 0.24]);
sb6 = axes('Position' ,[0.55, 0.08, 0.35, 0.24]);
linkaxes([sb1, sb2], 'x');      % link spectrogram and emg rms
set([sb1, sb2, sb3, sb4, sb5, sb6], 'box', 'off', 'TickLength', [0 0])

% emg vs time colored by state
fh.CurrentAxes = sb1;
hold on
for istate = 1 : nstates
    stateLabels = find(labels == istate);
    scatter(stateLabels / epochLen / 60 / 60,...
        processedEMG(stateLabels),...
        3, cfg_colors{istate})
end
axis tight
ylim([min(processedEMG) 1])
ylabel('Norm. EMG RMS')
set(gca, 'XTick', [], 'YTick', [])

% spectrogram
fh.CurrentAxes = sb2;
% time axis in hours
nbins = length(taxis);
tSpec = ((1 : nbins) * epochLen - epochLen / 2) / 3600; % spectrogram time axis, in seconds
showFreqs = find(faxis <= 15);  % choose freqs to display
% take a sample of the spectrogram to help initialize the colormap
sampleBins = randperm(nbins, round(nbins / 10));
specSample = reshape(specDisp(sampleBins, showFreqs), 1, length(sampleBins) * length(showFreqs));
caxis1 = prctile(specSample, [6 98]);
% plot 
imagesc(tSpec, faxis(showFreqs), specDisp(:, showFreqs)', caxis1);
colormap(AccuSleep_colormap());
axis('xy')
ylabel('Frequency [Hz]')
xlabel('Time [h]')
% set(gca, 'YTick', [])

% spectral power per state
fh.CurrentAxes = sb3;
ph = plot(faxis, psdStates ./ sum(psdStates, 2), 'LineWidth', 3);
set(ph, {'color'}, cfg_colors(sstates))
xlim([0 30])
xlabel('Frequency [Hz]')
ylabel('Norm PSD')     
% set(gca, 'YTick', [])

% scatter spectrogram vs. emg (could not use axes handle w/ gscatter)
fh.CurrentAxes = sb4;
hold on
for istate = sstates
scatter(sRatio(labels == istate), processedEMG(labels == istate)',...
    2, cfg_colors{istate}, 'filled')
end
ylabel('Norm. EMG RMS')
xlabel('Delta / Theta Ratio')
set(gca, 'YTick', [])

% histogram of epoch lengths for NREM, REM, and WAKE
fh.CurrentAxes = sb5;
hold on
epMat = cell2nanmat(epLen(sstates));
plot([1 : size(epMat, 2)], mean(epMat, 1, 'omitnan'),...
    'kd', 'markerfacecolor', 'k')
boxplot(epMat, 'PlotStyle', 'traditional', 'Whisker', 6);
bh = findobj(sb5, 'Tag', 'Box');
bh = flipud(bh);
for ibox = 1 : length(bh)
    patch(get(bh(ibox), 'XData'), get(bh(ibox), 'YData'),...
        cfg_colors{sstates(ibox)}, 'FaceAlpha', 0.5)
end
xticklabels(cfg_names(sstates))
xtickangle(45)
set(sb5, 'YScale', 'log')
ylabel('Epoch Length [log(s)]')
ylim([0 ceil(prctile(epMat(:), 99.99))])
    
% percent time in state
fh.CurrentAxes = sb6;
pie(sum(cell2nanmat(epLen(sstates)), 1, 'omitnan'), ones(1, length(sstates)));
hold on
ph = findobj(sb6, 'Type', 'Patch');
set(ph, {'FaceColor'}, flipud(cfg_colors(sstates)))
legend(cfg_names, 'Units', 'normalized', 'Position', [0.81 0.11 0.10 0.20]);

% save figure
if saveFig
    figpath = fullfile('graphics', 'sleepState');
    mkdir(figpath)
    figname = fullfile(figpath, sprintf('%s_stateSeparation', basename));
    export_fig(figname, '-tif', '-transparent', '-r300')
end

end

% EOF
