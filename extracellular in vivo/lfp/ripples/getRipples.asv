function ripp = getRipples(varargin)

% Detects ripples from lfp: rectifies (squares) the signal, applies a
% moving average, standardizes, finds crossings of a threshold
%(in z-scores) and converts them to epochs by applying duration criterions.
% Alas, discards ripples with a low peak power. After detection, calculates
% various stats and plots a summary. based in part on
% bz_FindRipples but.
% 
% INPUT:
%   basepath        path to recording {pwd}
%   sig             numeric vec of lfp data. if empty will be loaded from
%                   basename.lfp according to rippCh.  
%   emg             numeric of of emg data. must be the same sampling
%                   frequency as sig. if empty will be loaded from
%                   basename.lfp according to emgCh.
%   fs          	numeric. sampling frequency of lfp file / data. 
%                   if empty will be extracted from session info (ce
%                   format)
%   rippCh          numeric vec. channels to load and average from lfp
%                   file {1}. if empty will be selected best on the ratio
%                   of mean to median within the passband. 
%   emgCh           numeric vec. emg channel in basename.lfp file. 
%   recWin          numeric 2 element vector. time to analyse in recording
%                   [s]. start of recording is marked by 0. {[0 Inf]}
%   graphics        logical. plot graphics {true} or not (false)
%   saveVar         logical. save variables (update spikes and save su)
%
% OUTPUT:
%   ripp            struct
%
% DEPENDENCIES:
%   binary2epochs
%   lfpFilter
%   Sync (buzcode)
%   SyncMap (buzcode)
%   PlotColorMap (buzcode)
%
% TO DO LIST:
%   finish graphics (done)
%   stats (done)
%   rate (done)
%   exclusion by emg noise
%   exclusion by spiking activity
%   exlude active periods when normalizing signal
%   allow user to input sig directly instead of loading from binary (done)
%   improve routine to select best ripple channel automatically
%
% 02 dec 21 LH

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
p = inputParser;
addOptional(p, 'basepath', pwd);
addOptional(p, 'sig', [], @isnumeric);
addOptional(p, 'emg', [], @isnumeric);
addOptional(p, 'recWin', [0 Inf]);
addOptional(p, 'rippCh', 1, @isnumeric);
addOptional(p, 'emgCh', [], @isnumeric);
addOptional(p, 'fs', [], @isnumeric);
addOptional(p, 'graphics', true, @islogical);
addOptional(p, 'saveVar', true, @islogical);

parse(p, varargin{:})
basepath    = p.Results.basepath;
sig         = p.Results.sig;
emg         = p.Results.emg;
recWin      = p.Results.recWin;
rippCh      = p.Results.rippCh;
emgCh       = p.Results.emgCh;
fs          = p.Results.fs;
graphics    = p.Results.graphics;
saveVar     = p.Results.saveVar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% params
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

basepath = pwd;
win = ones(11, 1) / 11;     % for moving average
shift = (length(win) - 1) / 2;
thr = [1 4];                % threshold of stds above the sig
limDur = [20, 150, 30];     % min, max, and inter dur limits for ripples [ms]
passband = [100 200];
binsizeRate = 30;           % binsize for calculating ripple rate [s]

% load session info
[~, basename] = fileparts(basepath);
sessionName = [basename, '.session.mat'];
if ~exist(sessionName, 'file')
    session = CE_sessionTemplate(pwd, 'viaGUI', false,...
        'force', true, 'saveVar', true);
else
    load(sessionName)
end

spkgrp = session.extracellular.spikeGroups.channels;
spkch = sort([spkgrp{:}]);
nchans = session.extracellular.nChannels;
if isempty(fs)
    fs = session.extracellular.srLfp;
end

fprintf('\ngetting ripples for %s\n', basename)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% load data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if isempty(sig)    
    if isempty(rippCh)
        % if rippCh not specified, load 4 hr of data and find ch with best
        % SNR for ripples. note this subrutine occasionally points to the
        % channel with the highest movement artifacts / spikes. better to
        % select manually.
        fprintf('selecting best ripple channel...\n')

        recDur = min([diff(recWin), 4 * 60 * 60]);
        sig = double(bz_LoadBinary([basename, '.lfp'], 'duration', recDur,...
            'frequency', fs, 'nchannels', nchans, 'start', recWin(1),...
            'channels', spkch, 'downsample', 1));
        
        sig_filt = filterLFP(sig, 'fs', fs, 'type', 'butter', 'dataOnly', true,...
            'order', 3, 'passband', passband, 'graphics', false);
        
        pow = fastrms(sig_filt, 15);
        ch_rippPowRatio = mean(pow) ./ median(pow);
        [~, rippCh] = max(ch_rippPowRatio);
    end
    
    % load all data and average across channels
    fprintf('loading lfp data...\n')
    sig = double(bz_LoadBinary([basename, '.lfp'], 'duration', diff(recWin),...
        'frequency', fs, 'nchannels', nchans, 'start', recWin(1),...
        'channels', rippCh, 'downsample', 1));
    if length(rippCh) > 1
        sig = mean(sig, 2);
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prep signal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -------------------------------------------------------------------------
% ALT 1: load meg data and find epochs of high activity
% load emg data from basename.lfp
if isempty(emg) && ~isempty(emgCh)
    emg = double(bz_LoadBinary([basename, '.lfp'], 'duration', diff(recWin),...
        'frequency', fs, 'nchannels', nchans, 'start', recWin(1),...
        'channels', emgCh, 'downsample', 1));
end

% find epochs of high activity
mov_idx = zeros(1, length(sig));
if ~isempty(emg)
    fprintf('finding epochs of high activity...\n')   
    emg_rms = fastrms(emg, 15);
    mov_idx = emg_rms > prctile(emg_rms, 80);    
end

% ALT 2: use active wake from sleep states
ssfile = fullfile(basepath, [basename '.AccuSleep_states.mat']);
if exist(ssfile)    
    load(ssfile, 'ss')    
    [~, cfg_names, ~] = as_loadConfig([]);
    wake_stateIdx = find(strcmp(cfg_names, 'WAKE'));
    
    wake_inInt = InIntervals(ss.stateEpochs{wake_idx}, recWin);
    wake_epochs = ss.stateEpochs{wake_idx}(wake_inInt, :) * fs;  
    wake_sampleIdx = false(1, length(sig));
    for iwake = 1 : size(wake_epochs, 1)
        wake_sampleIdx(wake_epochs(iwake, 1) : wake_epochs(iwake, 2)) = true;
    end
end
 
fprintf('preparing signal...\n')

% filter lfp data in ripple band
sig_filt = filterLFP(sig, 'fs', fs, 'type', 'butter', 'dataOnly', true,...
    'order', 3, 'passband', passband, 'graphics', false);

% remove samples of high movement 
sig_filt(mov_idx) = nan;

% sqaure, moving average and correct shift
nss = sig_filt .^ 2;
[nss, z] = filter(win, 1, nss);
nss = [nss(shift + 1 : end, :); z(1 : shift, :)];

% standardize
nss = (nss - mean(nss, 'omitnan')) / std(nss, 'omitnan'); 

% debugging of mov_idx ----------------------------------------------------
debugNow = 1;
fh = figure; 
sb1 = subplot(2, 1, 1);
plot([1 : length(nss)] / 1250 / 60 / 60, nss);
hold on
scatter(find(nss > thr(1)) / 1250 / 60 / 60, 10 * ones(1, sum(nss > thr(1))), '.');
xlabel('Time [h]')
ylabel('NSS')
legend({'', 'nss > thr'})

sb2 = subplot(2, 1, 2);
plot([1 : length(nss)] / 1250 / 60 / 60, emg_rms)
hold on
scatter(find(mov_idx) / 1250 / 60 / 60, 10 * ones(1, sum(mov_idx)), '.');
xlabel('Time [h]')
ylabel('EMG RMS')
legend({'', 'emg > median'})

linkaxes([sb1, sb2], 'x')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% find ripples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% find epochs with power > low threshold. correct for durations
limDur = limDur / 1000 * fs;
epochs = binary2epochs('vec', nss > thr(1), 'minDur', limDur(1),...
    'maxDur', limDur(2), 'interDur', limDur(3));

% discard ripples with a peak power < high threshold
peakPowNorm = zeros(size(epochs, 1), 1);
for iepoch = 1 : size(epochs, 1)
    peakPowNorm(iepoch) = max(nss(epochs(iepoch, 1) : epochs(iepoch, 2)));
end
dicard_idx = peakPowNorm < thr(2);
epochs(dicard_idx, :) = [];
peakPowNorm(dicard_idx) = [];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% stats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% find negative peak position for each ripple
peakPos = zeros(size(epochs, 1), 1);
peakPow = zeros(size(epochs, 1), 1);
for iepoch = 1 : size(epochs, 1)
    [peakPow(iepoch), peakPos(iepoch)] =...
        min(sig_filt(epochs(iepoch, 1) : epochs(iepoch, 2)));
    peakPos(iepoch) = peakPos(iepoch) + epochs(iepoch, 1) - 1;
end

% convert idx to seconds
nepochs = size(epochs, 1);
peakPos = peakPos / fs;
epochs = epochs / fs;

% instantaneous phase and amplitude
h = hilbert(sig_filt);
sig_phase = angle(h);
sig_amp = abs(h);
sig_unwrapped = unwrap(sig_phase);

% instantaneous frequency
tstamps = [1 / fs : 1 / fs : length(sig) / fs];
tstamps = tstamps(:);
dt = diff(tstamps);
t_diff = tstamps(1 : end - 1) + dt / 2;
d0 = diff(medfilt1(sig_unwrapped, 12)) ./ dt;
d1 = interp1(t_diff, d0, tstamps(2 : end - 1, 1));
sig_freq = [d0(1); d1; d0(end)] / (2 * pi);

% arrange maps
ripp.maps.durWin = [-75 75] / 1000;
nbins = floor(fs * diff(ripp.maps.durWin) / 2) * 2 + 1; % must be odd
centerBin = ceil(nbins / 2);
[r, i] = Sync([tstamps sig_filt], peakPos, 'durations', ripp.maps.durWin);
ripp.maps.ripp = SyncMap(r, i, 'durations', ripp.maps.durWin,...
    'nbins', nbins, 'smooth', 0);
[f, i] = Sync([tstamps, sig_freq], peakPos, 'durations', ripp.maps.durWin);
ripp.maps.freq = SyncMap(f, i, 'durations', ripp.maps.durWin, 'nbins', nbins, 'smooth', 0);
[a, i] = Sync([tstamps sig_phase], peakPos, 'durations', ripp.maps.durWin);
ripp.maps.phase = SyncMap(a, i,'durations', ripp.maps.durWin, 'nbins', nbins, 'smooth', 0);
[p, i] = Sync([tstamps sig_amp], peakPos, 'durations', ripp.maps.durWin);
ripp.maps.amp = SyncMap(p, i,'durations', ripp.maps.durWin, 'nbins', nbins, 'smooth', 0);

% more stats
ripp.maxFreq = max(ripp.maps.freq, [], 2);
ripp.peakFreq = ripp.maps.freq(:, centerBin);
ripp.peakAmp = ripp.maps.amp(:, centerBin);
ripp.dur = epochs(:, 2) - epochs(:, 1);

% acg and correlations
[ripp.acg.data, ripp.acg.t] = CCG(peakPos,...
    ones(length(peakPos), 1), 'binSize', 0.01);
ripp.corr.amp_freq = corrcoef(ripp.peakAmp, ripp.peakFreq);
ripp.corr.dur_freq = corrcoef(ripp.dur, ripp.peakFreq);
ripp.corr.dur_amp = corrcoef(ripp.dur, ripp.peakAmp);

% rate
[ripp.rate.rate, ripp.rate.binedges, ripp.rate.tstamps] =...
    times2rate(peakPos, 'binsize', binsizeRate, 'winCalc', [0, Inf],...
    'c2r', true);

% relation to sleep states
ssfile = fullfile(basepath, [basename '.AccuSleep_states.mat']);
if exist(ssfile)    
    load(ssfile, 'ss')    
    [cfg_colors, ~, ~] = as_loadConfig([]);

    ripp.states.stateNames = ss.labelNames;
    nstates = length(ss.stateEpochs);
    sstates = [1 : 5];  % selected states
    
    for istate = sstates
        epochIdx = InIntervals(ss.stateEpochs{istate}, recWin);
        if ~isempty(ss.stateEpochs{istate})
            % rate in states
            [ripp.states.rate{istate}, ripp.states.binedges{istate},...
                ripp.states.tstamps{istate}] =...
                times2rate(peakPos, 'binsize', binsizeRate,...
                'winCalc', ss.stateEpochs{istate}(epochIdx, :), 'c2r', true);
            
            % idx of rippels in state
            ripp.states.idx{istate} =...
                InIntervals(peakPos, ss.stateEpochs{istate}(epochIdx, :));
        end
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graphics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if graphics
    fh = figure;
    durPlot = [-50 50] / 1000;
    x = durPlot(1) : diff(durPlot) / nepochs : durPlot(2);
    histBins = 200;
    
    % examples on raw and filtered data
    sb1 = subplot(4, 3, [1, 2]);    
    idx_recMargin = 10 * fs;     % [s]
    rippSelect = 500 : 550;
    rippCenter = round((rippSelect(end) - rippSelect(1)) / 2) + rippSelect(1);
    idx_rec = round([peakPos(525) * fs - idx_recMargin :...
        peakPos(525) * fs + idx_recMargin]);
    plot(idx_rec / fs, sig(idx_rec), 'k')
    hold on
    plot(idx_rec / fs, sig_filt(idx_rec), 'm')
    yLimit = ylim;
    plot([peakPos(rippSelect), peakPos(rippSelect)], yLimit, 'b')
    plot([epochs(rippSelect, 1), epochs(rippSelect, 1)], yLimit, 'g')
    plot([epochs(rippSelect, 2), epochs(rippSelect, 2)], yLimit, 'r')
    xlim([peakPos(rippCenter) - 0.5, peakPos(rippCenter) + 0.5])
    legend('Raw LFP', 'Filtered')
    xlabel('Time [s]')
    
    % examples of ripples (filtered) superimposed
    sb3 = subplot(4, 3, 3);
    ripp_idx = randperm(nepochs, 1000);
    plot(((1 : nbins)' - ceil(nbins / 2)) / nbins * diff(durPlot),...
        ripp.maps.ripp(ripp_idx, :)', 'k');
    xlabel('Time [s]')
    
    % rate
    sb4 = subplot(4, 3, [4, 5]);
    plot(ripp.rate.tstamps / 60 / 60, ripp.rate.rate, 'k')
    xlabel('Time [h]')
    ylabel('Ripple Rate [Hz]')
    if exist(ssfile)
        hold on
        for istate = sstates
            ph = plot(ripp.states.tstamps{istate} / 60 / 60,...
                ripp.states.rate{istate}, '.', 'MarkerSize', 5);
            ph.Color = cfg_colors{istate};
        end
        xlabel('Time [h]')
        ylabel('Ripple Rate [Hz]')
        legend(["Total", ripp.states.stateNames{sstates}]);
    end
    ylim([0 3])
    
    % percent rippels in state
    sb6 = subplot(4, 3, 6);
    if exist(ssfile)
        pie(sum(cell2nanmat(ripp.states.idx), 1, 'omitnan'), ones(1, length(sstates)))
        hold on
        ph = findobj(sb6, 'Type', 'Patch');
        set(ph, {'FaceColor'}, flipud(cfg_colors(sstates)'))
    end
      
    % frequency map
    sb7 = subplot(4, 3, 7);
    PlotColorMap(ripp.maps.freq, 1, 'bar','on', 'cutoffs', [100 250], 'x', x);
    ylabel('Ripple No.')
    subtitle('Frequency');   
    
    % amplitude map
    sb8 = subplot(4, 3, 8);
    PlotColorMap(ripp.maps.amp, 1, 'bar','on', 'x', x);
    ylabel('Ripple No.')
    subtitle('Amplitude');
    
    % ACG
    sb9 = subplot(4, 3, 9);
    plotCCG(ripp.acg.data, ripp.acg.t);
    xlabel('Time [ms]')
    ylabel('Rate')
    
    % distribution of peak frequency
    sb10 = subplot(4, 3, 10);
    h = histogram(ripp.peakFreq, histBins, 'Normalization', 'probability');
    h.FaceColor = 'k';
    h.EdgeColor = 'none';
    xlabel('Peak Frequency [Hz]')
    ylabel('Probability')
    
    % distribution of peak amplitude
    sb11 = subplot(4, 3, 11);
    h = histogram(ripp.peakAmp, histBins, 'Normalization', 'probability');
    h.FaceColor = 'k';
    h.EdgeColor = 'none';
    xlabel('Peak Amp')
    ylabel('Probability')
    
    % distribution of ripple duration
    sb12 = subplot(4, 3, 12);
    h = histogram(ripp.dur * 1000, histBins, 'Normalization', 'probability');
    h.FaceColor = 'k';
    h.EdgeColor = 'none';
    xlabel('Ripple Duration [ms]')
    ylabel('Probability')
    
    % save figure
    figpath = fullfile(basepath, 'graphics');
    mkdir(figpath)
    figname = fullfile(figpath, sprintf('%s_ripples', basename));
    export_fig(figname, '-tif', '-transparent', '-r300')   
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% finalize and save
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ripp.info.ch = ch;
ripp.info.limDur = limDur;
ripp.info.recWin = recWin;
ripp.info.runtime = datetime(now, 'ConvertFrom', 'datenum');
ripp.info.thr = thr;
ripp.epochs         = epochs + recWin(1);  
ripp.peakPos        = peakPos;
ripp.peakPow        = peakPow;
ripp.peakPowNorm    = peakPowNorm;

if saveVar      
    save([basepath, filesep, basename, '.ripp.mat'], 'ripp')
    
    % create ns files for visualization with neuroscope
    fs_dat = session.extracellular.sr;
    
    res = [ripp.epochs(:, 1); ripp.epochs(:, 2); ripp.peakPos] * fs_dat;
    [res, sort_idx] = sort(round(res));
    fid = fopen([basename, '.ripp.res.1'], 'w');
    fprintf(fid, '%d\n', res);
    rc = fclose(fid);
   
    clu = [ones(nepochs, 1); ones(nepochs, 1) * 2; ones(nepochs, 1) * 3];
    clu = clu(sort_idx);
    fid = fopen([basename, '.ripp.clu.1'], 'w');
    fprintf(fid, '%d\n', 3);
    fprintf(fid, '%d\n', clu);
    rc = fclose(fid);
end

end

% EOF