function fixSpkAndRes(varargin)

% processes neurosuite files after manual curation. answers two issues: (1)
% re-aligns individual waveforms according to their peak / trough
% (depending on orientation of the mean waveform). (2) enforces a dead time
% on spike times (res) that typically occurs when kilosort tries to find
% spikes that occur simultaneously. re-alignment occurs first because it
% changes spike times. alas recalculates pca. if backup is flagged
% then copies the original files to a separate directory.
% -------------------------------------------------------------------------
% since waveforms were detrended in ks2ns, the beginning and end of a spike
% are equal to zero and thus circhshift can be used to recenter the peak /
% trough.
% -------------------------------------------------------------------------
% one problem that persists is that if a waveform includes two spikes, the
% larger spike will always be centered even if the cluster originally
% referred to the smaller spike.
% -------------------------------------------------------------------------
%
% INPUT:
%   basepath    string. path to recording folder {pwd}.
%   spkgrp      array where each cell is the electrodes for a spike group.
%               if empty will be loaded from session info file (cell
%               explorer format)
%   nchans      numeric. number of channels in dat file {35}
%   grp         numeric. groups (tetrodes) to work on. refers to filename
%               and not order. e.g. grp = 3 will load clu.3
%   fs          numeric. sampling frequency [hz]{20000}
%   nsamps      numeric. length of waveform in spk file {32}. if empty will
%               be calculated according to fs as 1.6 ms
%   psamp       numeric. peak / trough sample {16}. if empty will be
%               set to half nsamps.
%   stdFactor   numeric. re-alignment will occur only if std @ peak is
%               greater than std @ begining * stdFactor {1.1}. if 0
%               then all clusters will undergo re-alignment.
%   graphics    logical. plot the before / after of each cluster {false}.
%   bkup        logical. create backup of files in basepath/ns/bkup {true}.
%   saveFiles   logical. save ns files after processing {true}.
%
% DEPENDENCIES
%   plotCCG
%   plotWaveform
%
% 22 jun 20 LH  yod

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tic;

p = inputParser;
addOptional(p, 'basepath', pwd);
addOptional(p, 'spkgrp', {}, @iscell);
addOptional(p, 'nchans', 35, @isnumeric);
addOptional(p, 'grp', [], @isnumeric);
addOptional(p, 'fs', 20000, @isnumeric);
addOptional(p, 'dt', 8, @isnumeric);
addOptional(p, 'nsamps', [], @isnumeric);
addOptional(p, 'psamp', [], @isnumeric);
addOptional(p, 'stdFactor', 0, @isnumeric);
addOptional(p, 'graphics', false, @islogical);
addOptional(p, 'bkup', true, @islogical);
addOptional(p, 'saveFiles', true, @islogical);

parse(p, varargin{:})
basepath    = p.Results.basepath;
spkgrp      = p.Results.spkgrp;
nchans      = p.Results.nchans;
grp         = p.Results.grp;
fs          = p.Results.fs;
dt          = p.Results.dt;
nsamps      = p.Results.nsamps;
psamp       = p.Results.psamp;
stdFactor   = p.Results.stdFactor;
graphics    = p.Results.graphics;
bkup        = p.Results.bkup;
saveFiles   = p.Results.saveFiles;

% try to load params from session info (cell explorer format)
cd(basepath)
[~, basename] = fileparts(basepath);
infoname = fullfile(basepath, [basename '.session.mat']);
if exist(infoname, 'file')
    load(infoname)
end
if isempty(spkgrp)
    spkgrp = session.extracellular.spikeGroups.channels;
end
ngrp = length(spkgrp);
if isempty(fs)
    fs = session.extracellular.sr;
end
if isempty(nsamps)
    nsamps = ceil(1.6 * 10^-3 * fs);        % 1.6 ms in samples
end
if isempty(psamp)
    psamp = nsamps / 2;
end
if isempty(grp)
    grp = 1 : ngrp;
end

sniplength = ceil(1.6 * 10^-3 * fs);
win = [-(floor(sniplength / 2) - 1) floor(sniplength / 2)];
precision = 'int16'; % for dat file. size of one data point in bytes
nbytes = class2bytes(precision);

% build regressor for detrending
s = 0 : sniplength - 1;
scaleS = s(end);
a = s./scaleS;
b = max(a, 0);
W = b(:);
W = [reshape(W, sniplength, []), ones(sniplength,1)];
[Q, R] = qr(W,0);

% for CCG
dur = 0.01;
binsize = 0.0001;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arrange files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clufiles = dir([basepath filesep '*.clu*']);
clunames = {clufiles.name};
resfiles = dir([basepath filesep '*.res*']);
resnames = {resfiles.name};
spkfiles = dir([basepath filesep '*.spk*']);
spknames = {spkfiles.name};
fetfiles = dir([basepath filesep '*.fet*']);
fetnames = {fetfiles.name};
if length(resfiles) ~= length(clufiles) ||...
        length(clufiles) ~= length(spkfiles) ||...
        length(spkfiles) ~= length(fetfiles)
    warning('different number of res / clu / spk / fet files')
end

% backup
if bkup
    bkpath = fullfile(basepath, 'kk', 'bkupFix');
    fprintf('\nSaving backup in %s\n', bkpath)
    mkdir(bkpath)
    for i = grp
        copyfile(fullfile(clufiles(i).folder, clunames{i}), bkpath)
        copyfile(fullfile(resfiles(i).folder, resnames{i}), bkpath)
        copyfile(fullfile(spkfiles(i).folder, spknames{i}), bkpath)
        copyfile(fullfile(fetfiles(i).folder, fetnames{i}), bkpath)
    end
end

% memory map to dat file
fraw = dir([basename '.dat']);
nsampsRaw = fraw.bytes / nbytes / nchans;
m = memmapfile(fraw.name, 'Format', {precision, [nchans, nsampsRaw] 'mapped'});
raw = m.Data;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% go over groups
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for i = grp
    grpchans = spkgrp{i};
    nchansGrp = length(spkgrp{i});
    
    % load data
    fprintf('Loading group %d / %d. ', i, ngrp)
    
    cluname = fullfile(clufiles(i).folder, clufiles(i).name);
    fid = fopen(cluname, 'r');
    nclu = fscanf(fid, '%d', 1);
    clu = fscanf(fid, '%f', Inf);
    fclose(fid);
    cluGrp = unique(clu);
    if length(cluGrp) ~= nclu
        warning('cluFile has the wrong number of clusters')
        nclu = length(cluGrp);
    end
    nspks = length(clu);
    
    resname = fullfile(resfiles(i).folder, resfiles(i).name);
    fid = fopen(resname, 'r');
    res = fscanf(fid, '%d', Inf);
    fclose(fid);
    
    spkname = fullfile(spkfiles(i).folder, spkfiles(i).name);
    fid = fopen(spkname, 'r');
    spk = fread(fid, Inf, 'int16');
    spk = reshape(spk, nchansGrp, nsamps, nspks);
    fclose(fid);
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % go over clusters
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    txt = '';
    for ii = 1 : nclu
        
        % skip noise / artifact clusters
        if cluGrp(ii) == 0 || cluGrp(ii) == 1
            continue
        end
        
        % print progress
        fprintf(repmat('\b', 1, length(txt)))
        txt = sprintf('Working on cluster %d / %d. \t', ii, nclu);
        fprintf('%s', txt)
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % go over spikes and recenter
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        cluIdx = find(clu == cluGrp(ii));
        nspksGrp = length(cluIdx);
        spkGrp = spk(:, :, cluIdx);
        spkMean = mean(spkGrp, 3);
        [~, ampMaxCh] = max(range(spkMean, 2));
        
        % re-align waveforms only if std at peak greater than at edges
        spkStd = std(spkGrp(ampMaxCh, :, :), [], 3);
        if spkStd(psamp) < mean(spkStd(1 : 5)) * stdFactor
            continue
        end
        
        % find wave polarity to decide if align to min or max
        if abs(min(spkMean(ampMaxCh, :))) > max(spkMean(ampMaxCh, :))
            spkPolarity = 'neg';
        else
            spkPolarity = 'pos';
        end
        
        % save original for plotting
        if graphics
            spkOrig = spkGrp;
            resOrig = res(cluIdx);
        end
        
        % go over each spike and align to min / max
        iShift = zeros(nspksGrp, 1);
        for iii = 1 : nspksGrp
            spkidx = res(cluIdx(iii));
            
            % fix special case where spike is at end / begining of recording
            if spkidx + win(1) < 1 || spkidx + win(2) > nsampsRaw
                warning('\nskipping stamp %d because waveform incomplete', ii)
                spk(:, :, ii) = [];
                spktimes{i}(ii) = [];
                nspks(i) = nspks(i) - 1;
                continue
            end
            
            % get waveform and remove best fit
            v = double(raw.mapped(grpchans, spkidx + win(1) :...
                spkidx + win(2)));
            spkGrp(:, :, iii) = [v' - W * (R \ Q' * v')]';

            % realign according to minimum
            %             [~, ia] = min(v, [], 2);
            %             peak = ia(ampMaxCh);
            %             ishift(iii) = peak - psamp;
            %             if ishift(iii) ~= 0
            %                 spktimes{i}(ii) = spktimes{i}(ii) + ishift;
            %                 v = double(raw.mapped(grpchans, spktimes{i}(ii) + win(1) :...
            %                     spktimes{i}(ii) + win(2)));
            %                 v = [v' - W * (R \ Q' * v')]';
            %             end
            %             spk(:, :, iii) = v;
            %             iShift(iii) = psamp - ia;
            %             spkGrp(:, :, iii) = circshift(spkGrp(:, :, iii), iShift(iii), 2);
        end
        spk(:, :, cluIdx) = spkGrp;
        % res(cluIdx) = res(cluIdx) + iShift;
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % enforce dead time on spike detection
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        resGrp = res(cluIdx);
        [resGrp, rmIdx, ~] = unique(resGrp);
        rmIdx = [setdiff(1 : nspksGrp, rmIdx)]';
        while min(diff(resGrp)) < dt
            ir = find(diff(resGrp) < dt);
            resGrp(ir) = [];
            rmIdx = [rmIdx; ir];
        end
        res(cluIdx(rmIdx)) = [];
        clu(cluIdx(rmIdx)) = [];
        spk(:, :, cluIdx(rmIdx)) = [];
        nspks = length(clu);
        
        % graphics
        if graphics
            figure
            txt2 = sprintf('Group %d Cluster %d', i, cluGrp(ii));
            suptitle(txt2)
            subplot(2, 2, 1)
            plotWaveform('avgwv', mean(spkOrig, 3),...
                'stdwv', std(spkOrig, [], 3), 'c', 'k',...
                'orient', 'vert', 'sbar', false)
            xticks([])
            yticks([])
            title('Before')
            subplot(2, 2, 2)
            plotWaveform('avgwv', mean(spkGrp(:, :, :), 3),...
                'stdwv', std(spkGrp(:, :, :), [], 3), 'c', 'k',...
                'orient', 'vert', 'sbar', false)
            xticks([])
            yticks([])
            title('After')
            subplot(2, 2, 3)
            [ccg, t] = CCG({resOrig / fs}, [], 'duration', dur, 'binSize', binsize);
            plotCCG('ccg', ccg(:, 1, 1), 't', t, 'basepath', basepath,...
                'saveFig', false, 'c', {'k'});
            subplot(2, 2, 4)
            cluIdx = clu == cluGrp(ii);
            [ccg, t] = CCG({res(cluIdx) / fs}, [], 'duration', dur, 'binSize', binsize);
            plotCCG('ccg', ccg(:, 1, 1), 't', t, 'basepath', basepath,...
                'saveFig', false, 'c', {'k'});
            drawnow;
        end
    end
    
    % recalculate PCA
    fprintf('Calculating PCA... \t')
    nFeatures = nchansGrp * 3 + nchansGrp + 1;
    fetMat = zeros(nspks, nFeatures);
    enrgIdx = nchansGrp * 3;
    if ~isempty(spk)
        for ii = 1 : nchansGrp
            [~, pcFeat] = pca(permute(spk(ii, :, :), [3, 2, 1]));
            chEnrgy = sum(abs(permute(spk(ii, :, :), [3, 2, 1])), 2);
            fetMat(:, ii * 3 - 2 : ii * 3) = (pcFeat(:, 1 : 3));
            fetMat(:, enrgIdx + ii) = (chEnrgy);
        end
    end
    fetMat(:, end) = res;
    fet = int32(fetMat');
    
    % save files
    if saveFiles
        fprintf('Saving files... \t')
        fetname = fullfile(fetfiles(i).folder, fetnames{i});
        fid = fopen(fetname, 'w');
        formatstring = '%d';
        for ii = 2 : nFeatures
            formatstring = [formatstring, '\t%d'];
        end
        formatstring = [formatstring, '\n'];
        fprintf(fid, '%d\n', nFeatures);
        fprintf(fid, formatstring, fet);
        rc = fclose(fid);
        
        fid = fopen(spkname, 'w');
        fwrite(fid, spk(:), 'int16');
        rc = fclose(fid);
        
        fid = fopen(cluname, 'w');
        fprintf(fid, '%d\n', nclu);
        fprintf(fid, '%d\n', clu);
        rc = fclose(fid);
        
        fid = fopen(resname, 'w');
        fprintf(fid, '%d\n', res);
        rc = fclose(fid);
        fprintf('done\n')
    end
end

fprintf('that took %.2f minutes\n', toc / 60)

end

% EOF