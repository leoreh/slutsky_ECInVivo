function frFit = mea_frFit(fr, t, varargin)
% MEA_FRFIT Fits double-exponential recovery model to firing rate data.
%
%   frFit = MEA_FRFIT(fr, t) fits a recovery model to firing rate data. The
%   function supports matrix input (Units x Time) and applies denoising
%   before fitting.
%
%   INPUTS:
%       fr          - (matrix) Firing rate matrix [Units x Time].
%       t           - (vector) Time vector [1 x Time]. Zero aligned to perturbation.
%
%   OPTIONAL (Key-Value Pairs):
%       FilterLen   - (double) Frame length for denoising filter. {60}
%       flgSave     - (logical) Whether to save results. {false}
%       flgPlot     - (logical) Whether to plot results. {false}
%       basepath    - (char) Base path for saving. {pwd}
%       baseMdls    - (cell) Models to fit {'gomp', 'rich', 'exp2'}.
%
%   OUTPUTS:
%       frFit       - (struct) Structure containing fit results:
%                       .frTrough   - (vector) FR at recovery onset [Hz].
%                       .idxTrough  - (vector) Index of recovery onset.
%                       .mdlName    - (cell) Name of best model.
%                       .rsquare    - (vector) R-squared of best fit.
%                       .pFit       - (matrix) Fitted parameters.
%                       .frMdl      - (matrix) Fitted curves.
%                       .frBsl      - (vector) Baseline FR [Hz].
%                       .frSs       - (vector) Steady-state FR [Hz].
%                       .goodFit    - (logical) Quality flag.
%
%   See also: MEA_FRPREP, FR_DENOISE, LSQCURVEFIT

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'fr', @isnumeric);
addRequired(p, 't', @isnumeric);
addParameter(p, 'FilterLen', 60, @isnumeric);
addParameter(p, 'flgSave', false, @islogical);
addParameter(p, 'flgPlot', false, @islogical);
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'baseMdls', {'gomp', 'rich', 'exp2'}, @iscell);

parse(p, fr, t, varargin{:});
FilterLen = p.Results.FilterLen;
flgSave = p.Results.flgSave;
flgPlot = p.Results.flgPlot;
basepath = p.Results.basepath;
baseMdls = p.Results.baseMdls;


%% ========================================================================
%  PRE-PROCESSING
%  ========================================================================

% Ensure Time Vector Orientation
if iscolumn(t), t = t'; end

% Detect Perturbation Index (t=0)
idxPert = find(t >= -1e-9, 1, 'first');
if isempty(idxPert)
    error('Time vector must contain 0 (perturbation onset).');
end

% Denoise Firing Rates
if ~isempty(FilterLen)
    frSm = fr_denoise(fr, 'frameLen', FilterLen, 'flgPlot', false);
else
    frSm = fr;
end

% Initialize Output Structures
nUnits = size(fr, 1);
nTime = size(fr, 2);

frFit.frTrough = nan(nUnits, 1);
frFit.idxTrough = nan(nUnits, 1);
frFit.mdlName = cell(nUnits, 1);
frFit.pFit = nan(nUnits, 10); % Allow space for max params (overshoot model ~8 params)
frFit.rsquare = nan(nUnits, 1);
frFit.frMdl = nan(nUnits, nTime);
frFit.frBsl = nan(nUnits, 1);
frFit.bslFit = nan(nUnits, 2);
frFit.frSs = nan(nUnits, 1);
frFit.mdlFits = cell(nUnits, 1);
frFit.goodFit = false(nUnits, 1);
frFit.fitQlty = repmat(struct('fitR2', false, 'bslStab', false, ...
    'rcvKin', false, 'pertResp', false, 'bslRate', false), nUnits, 1);
frFit.overshootTime = nan(nUnits, 1);
frFit.overShootFr = nan(nUnits, 1);


%% ========================================================================
%  FIT LOOP
%  ========================================================================

for iUnit = 1:nUnits

    % Get Data
    frUnit = frSm(iUnit, :);
    if sum(frUnit > 0) < 10 || all(isnan(frUnit))
        continue;
    end

    % ---------------------------------------------------------------------
    % INITIAL ESTIMATES
    % ---------------------------------------------------------------------

    % Time indices for fitting (relative to start)
    tIdx = (1:nTime)';

    % Trough: Min in 20 min window after perturbation
    troughWin = idxPert : min(nTime, idxPert + 20);
    [frMinVal, idxMin] = min(frUnit(troughWin));
    idxMin = max([idxMin, 2]); % Ensure at least 1 bin after pert
    idxTrough = idxPert + idxMin - 1;

    % Post-perturbation data
    tPost = tIdx(idxTrough:end) - idxTrough;
    frPost = frUnit(idxTrough:end)';

    if isempty(frPost)
        continue
    end

    % Steady State: Mean of last 20%
    frSsEst = mean(frPost(round(0.8 * end):end), 'omitnan');
    frSsEst = max([frSsEst, 1e-4]);
    frTroughEst = max([frMinVal, 1e-5]);

    % Recovery Kinetics Guess (Time to 50%)
    rcvTarget = frTroughEst + 0.5 * (frSsEst - frTroughEst);
    rcvIdx = find(frPost >= rcvTarget, 1, 'first');
    if ~isempty(rcvIdx)
        tHalf = max([1, tPost(rcvIdx)]);
        kRcv = log(2) / tHalf;
    else
        kRcv = (frPost(end) - frTroughEst) / max(tPost(end), 1);
    end

    % Sanity Check
    if frTroughEst / frSsEst > 2000
        continue;
    end

    % ---------------------------------------------------------------------
    % PEAK DETECTION (OVERSHOOT)
    % ---------------------------------------------------------------------
    minProm = 0.2 * abs(frSsEst - frTroughEst);
    [peakFr, peakLoc] = findpeaks(frPost, tPost, ...
        'NPeaks', 1, 'SortStr', 'descend', ...
        'MinPeakHeight', frSsEst, ...
        'MinPeakProminence', minProm, ...
        'MinPeakWidth', round(0.05 * length(tPost)), ...
        'MinPeakDistance', round(0.05 * length(tPost)));

    if isempty(peakLoc), peakLoc = 0; end
    if isempty(peakFr), peakFr = 0; end

    % Overshoot params
    if peakLoc > 0
        kOver = 1 / peakLoc;
        kFall = 1 / (max(tPost) - peakLoc);
        overshootAmp = peakFr - frSsEst;
        aOver = overshootAmp * kOver * exp(1);
    else
        kOver = 1/60; kFall = 1/60; aOver = 0;
    end

    % ---------------------------------------------------------------------
    % MODEL PREPARATION
    % ---------------------------------------------------------------------
    mdls = prepare_models(baseMdls, frSsEst, frTroughEst, kRcv, max(frUnit), ...
        max(tPost), peakLoc, peakFr, kOver, kFall, aOver);

    % ---------------------------------------------------------------------
    % FIT & SELECT
    % ---------------------------------------------------------------------
    mdlFitRes = prob_fit_models(frPost, tPost, mdls);

    if all([mdlFitRes.exitflag] <= 0)
        continue;
    end

    [~, bestIdx] = min([mdlFitRes.BIC]);
    bestMdl = mdlFitRes(bestIdx);

    % ---------------------------------------------------------------------
    % BASELINE FIT
    % ---------------------------------------------------------------------
    mrgnBins = 5;
    bslWin = 1:max(1, idxPert - mrgnBins);
    [bslBeta, ~] = robustfit(tIdx(bslWin), frUnit(bslWin));
    bslCurve = bslBeta(1) + bslBeta(2) * tIdx(1:(idxPert-2));

    % Perturbation Drop (Linear Interp)
    tPert = tIdx(idxPert-1:(idxTrough-1));
    frTroughFinal = bestMdl.pFit(3); % Parameter 3 is always trough in base models
    pertCurve = linspace(bslCurve(end), frTroughFinal, length(tPert))';

    % Recovery Curve
    rcvCurve = bestMdl.rcvCurve;

    % Full Curve
    frMdlFull = [bslCurve; pertCurve; rcvCurve];

    % If lengths don't match due to index rounding, trunc or pad end
    if length(frMdlFull) > nTime
        frMdlFull = frMdlFull(1:nTime);
    elseif length(frMdlFull) < nTime
        frMdlFull(end+1:nTime) = frMdlFull(end);
    end

    % ---------------------------------------------------------------------
    % QUALITY CHECKS
    % ---------------------------------------------------------------------
    qlty = check_quality(bestMdl, frMdlFull, frUnit, idxPert, bslBeta, mean(bslCurve));

    % ---------------------------------------------------------------------
    % STORE RESULTS
    % ---------------------------------------------------------------------
    frFit.frTrough(iUnit) = frTroughFinal;
    frFit.idxTrough(iUnit) = idxTrough;
    frFit.mdlName{iUnit} = bestMdl.name;
    frFit.pFit(iUnit, 1:length(bestMdl.pFit)) = bestMdl.pFit;
    frFit.rsquare(iUnit) = bestMdl.rsquare;
    frFit.frMdl(iUnit, :) = frMdlFull';
    frFit.frBsl(iUnit) = mean(bslCurve);
    frFit.bslFit(iUnit, :) = bslBeta';
    frFit.frSs(iUnit) = bestMdl.pFit(1);
    frFit.mdlFits{iUnit} = mdlFitRes;
    frFit.goodFit(iUnit) = qlty.isGood;
    frFit.fitQlty(iUnit) = qlty.details;

    if peakLoc > 0
        frFit.overshootTime(iUnit) = peakLoc / 60; 
        frFit.overShootFr(iUnit) = peakFr;
    end

end

%% ========================================================================
%  SAVING
%  ========================================================================

if flgSave
    [~, name] = fileparts(basepath);
    save(fullfile(basepath, [name, '.frFit.mat']), 'frFit', '-v7.3');
end


%% ========================================================================
%  PLOTTING
%  ========================================================================

if flgPlot
    
    % Select random units (prefer good fits)
    uGoodIdx = find(frFit.goodFit);
    uPlot = uGoodIdx(randperm(length(uGoodIdx), 5));

    % Plot
    for iPlot = 1:length(uPlot)
        idx = uPlot(iPlot);
        plot_frFit(t / 3600, frSm(idx, :), frFit.mdlFits{idx}, idxPert, frFit.idxTrough(idx));
    end
end

end


%% ========================================================================
%  HELPER: PREPARE MODELS
%  ========================================================================
function mdls = prepare_models(baseMdls, frSs, frTrough, kRcv, maxFr, maxT, ...
    peakTime, peakFr, kOver, kFall, aOver)

mdls = struct('name', {}, 'func', {}, 'p0', {}, 'lb', {}, 'ub', {});

cnt = 0;
for iMdl = 1:length(baseMdls)
    curr = baseMdls{iMdl};
    cnt = cnt + 1;
    switch lower(curr)
        case 'gomp'
            mdls(cnt).name = "gomp";
            mdls(cnt).func = @(p, t) p(1) .* exp(log(max(p(3),eps) ./ p(1)) .* exp(-p(2) * t));
            mdls(cnt).p0 = [frSs, kRcv, frTrough];
            mdls(cnt).lb = [eps, 1e-6, eps];
            mdls(cnt).ub = [3*maxFr, 1, maxFr];
        case 'rich'
            mdls(cnt).name = "rich";
            mdls(cnt).func = @(p, t) p(1) ./ (1 + ((p(1)./max(p(3),eps)).^p(4) - 1) .* exp(-p(2)*t)).^(1./p(4));
            mdls(cnt).p0 = [frSs, kRcv, frTrough, 1];
            mdls(cnt).lb = [eps, 1e-6, eps, 1e-3];
            mdls(cnt).ub = [3*maxFr, 1, maxFr, 100];
        case 'exp2'
            % Note: This is peak model
            mdls(cnt).name = "exp2";
            mdls(cnt).func = @(p, t) ...
                (t <= p(4)) .* (p(3) + (p(5)-p(3)) .* exp(p(2) * (t - p(4)))) + ...
                (t > p(4)) .* (p(1) + (p(5)-p(1)) .* exp(-p(6) * (t - p(4))));
            mdls(cnt).p0 = [frSs, kOver, frTrough, peakTime, peakFr, kFall];
            mdls(cnt).lb = [eps, 1e-3, eps, eps, eps, 1e-3];
            mdls(cnt).ub = [3*maxFr, 20, maxFr, maxT, 3*maxFr, 20];
        case 'exp1'
            mdls(cnt).name = "exp1";
            mdls(cnt).func = @(p, t) p(1) - (p(1) - p(3)) .* exp(-p(2) * t);
            mdls(cnt).p0 = [frSs, kRcv, frTrough];
            mdls(cnt).lb = [eps, 1e-6, eps];
            mdls(cnt).ub = [3*maxFr, 1, maxFr];
    end
end

% Add Peak models if peak detected
if peakTime > 0
    nBase = length(mdls);
    mdls = [mdls, mdls]; % Duplicate

    for iMdl = nBase+1:length(mdls)
        % Skip exp2 for peak addition (result would be exp2+PK which is redundant or complex)
        if contains(mdls(iMdl).name, "exp2"), continue; end

        mdls(iMdl).name = mdls(iMdl).name + "+PK";
        baseFunc = mdls(iMdl).func;
        nP = length(mdls(iMdl).p0);

        mdls(iMdl).func = @(p, t) baseFunc(p(1:nP), t) + ...
            p(nP+1) * t .* exp(-p(nP+2) * t);

        mdls(iMdl).p0 = [mdls(iMdl).p0, aOver, kOver];
        mdls(iMdl).lb = [mdls(iMdl).lb, 0, 1e-6];
        mdls(iMdl).ub = [mdls(iMdl).ub, 3*maxFr, 1];
    end

    % Clean up exp2 duplicates/conflicts
    idxExp2PK = find(strcmpi([mdls.name], "exp2+PK"));
    mdls(idxExp2PK) = [];

else
    % Remove exp2 if no peak
    idxExp2 = find(strcmpi([mdls.name], "exp2"));
    mdls(idxExp2) = [];
end
end


%% ========================================================================
%  HELPER: FIT MODELS
%  ========================================================================
function res = prob_fit_models(fr, t, mdls)

opts = optimoptions('lsqcurvefit', 'Display', 'off', 'TolFun', 1e-6,...
    'MaxIter', 1000, 'FunctionTolerance', 1e-6);

res = struct('pFit', [], 'resnorm', [], 'exitflag', [], 'rsquare', [], ...
    'AIC', [], 'BIC', [], 'rcvCurve', [], 'name', []);

for iMdl = 1:length(mdls)
    mdl = mdls(iMdl);
    try
        [pFit, resnorm, ~, exitflag] = lsqcurvefit(mdl.func, mdl.p0, t, fr, mdl.lb, mdl.ub, opts);
    catch
        pFit = mdl.p0; resnorm = inf; exitflag = -1;
    end

    if exitflag > 0
        frFitCurve = mdl.func(pFit, t);
        ssTot = sum((fr - mean(fr)).^2);
        if ssTot > 0, r2 = 1 - (resnorm/ssTot); else, r2=1; end

        n = length(fr); k = length(pFit);
        if resnorm > 0
            aic = 2*k + n*log(resnorm/n);
            bic = k*log(n) + n*log(resnorm/n);
            if contains(mdl.name, "exp2"), bic = bic + 14*k*log(n); end
        else
            aic = -inf; bic = -inf;
        end
    else
        r2 = NaN; aic=inf; bic=inf; frFitCurve = nan(size(t));
    end

    res(iMdl).pFit = pFit;
    res(iMdl).resnorm = resnorm;
    res(iMdl).exitflag = exitflag;
    res(iMdl).rsquare = r2;
    res(iMdl).AIC = aic;
    res(iMdl).BIC = bic;
    res(iMdl).rcvCurve = frFitCurve;
    res(iMdl).name = mdl.name;
end
end


%% ========================================================================
%  HELPER: QUALITY CHECK
%  ========================================================================
function q = check_quality(mdl, frMdl, frUnit, idxPert, bslBeta, frBsl)

q.details.fitR2 = mdl.rsquare >= 0.05;

bslDrift = abs(bslBeta(2)) / frBsl * (idxPert-1);
q.details.bslStab = bslDrift <= 1.5;

kRcv = mdl.pFit(2);
q.details.rcvKin = (1/kRcv) >= 1;

frTrough = mdl.pFit(3);
pertDepth = log2(frBsl / (frTrough + 0.001));
q.details.pertResp = pertDepth >= log2(1/0.8);

q.details.bslRate = frBsl >= 1e-6;

flds = fieldnames(q.details);
q.isGood = true;
for i=1:length(flds)
    q.isGood = q.isGood && q.details.(flds{i});
end

if isnan(mdl.rsquare), q.isGood = false; end
end


%% ========================================================================
%  HELPER: PLOT
%  ========================================================================
function plot_frFit(t, fr, fitRes, idxPert, idxTrough)
% plot_frFit Helper function to plot firing rate fit results

% Create figure with proper sizing
[hFig, ~] = plot_axSize('szOnly', false, 'axShape', 'wide', 'axHeight', 300);
hold on;

% Plot raw data
plot(t, fr, 'Color', [0.5 0.5 0.5], 'LineWidth', 0.5, 'HandleVisibility', 'off');

% Get successful models and sort by BIC
if isempty(fitRes)
    close(hFig); return;
end

exitFlags = [fitRes.exitflag];
if all(exitFlags <= 0)
    close(hFig); return;
end

mdlsGood = find(exitFlags > 0);
[~, sortIdx] = sort([fitRes(mdlsGood).BIC]);
mdlsSrtd = mdlsGood(sortIdx);

% Plot each successful model fit for recovery period (sorted by BIC)
clrMdls = bone(length(sortIdx)) * 0.6;

% Time vector for trough to end
tTrough = t(idxTrough:end);
if isempty(tTrough), return; end
% NOTE: The fit was done on tPost = tIdx(idxTrough:end) - idxTrough;
% fitRes.rcvCurve contains the fitted values for the tPost window.
% So we plot (t(idxTrough:end), rcvCurve)

for iMdl = 1:length(mdlsSrtd)
    mdlIdx = mdlsSrtd(iMdl);
    rcvCurvePlot = fitRes(mdlIdx).rcvCurve;

    % Check length
    if length(rcvCurvePlot) ~= length(tTrough)
        % This might happen if 't' passed here differs from 't' used in fit?
        % Should be consistent if passed correctly.
        continue
    end

    modelName = fitRes(mdlIdx).name;
    bicValue = round(fitRes(mdlIdx).BIC);

    % Capitalize
    if strlength(modelName) > 0
        modelName = char(modelName);
        modelName = [upper(modelName(1)), modelName(2:end)];
    end

    displayName = sprintf('%s (BIC: %d)', modelName, bicValue);

    hPlt = plot(tTrough, rcvCurvePlot, '--', 'Color', [clrMdls(iMdl, :), 0.8], ...
        'LineWidth', 2, 'DisplayName', displayName, 'HandleVisibility', 'off');

    if iMdl == 1
        hPlt.HandleVisibility = 'on';
        hPlt.Color = [0, 0, 0, 1];
        hPlt.LineWidth = 2.5;
        hPlt.LineStyle = '-';
    end
end

% Mark perturbation
cfg = mcu_cfg;
cfg.clr.bac
clrPert = [0.5, 0, 0.5, 0.5];
xline(t(idxPert), '--', 'Color', clrPert, 'LineWidth', 2, 'HandleVisibility', 'off');

% Formatting
xlim tight
xlabel('Time [s]');
ylabel('Firing Rate (Hz)');
legend('show', 'Location', 'northeast');
plot_axSize('hFig', hFig, 'szOnly', false, 'axShape', 'wide', 'axHeight', 300);

end