function rcv = mea_frRecovery(t, frMat, varargin)
% MEA_FRRECOVERY Calculates firing rate recovery metrics.
%
%   rcv = MEA_FRRECOVERY(T, FRMAT) calculates recovery metrics for firing
%   rate data aligned to a perturbation at t=0.
%
%   INPUTS:
%       t           - (vector) Time vector in seconds. Perturbation at t=0.
%       frMat       - (matrix) Firing rate matrix (units x time).
%
%   OPTIONAL (Key-Value Pairs):
%       uGood       - (logical) Vector of good units. {all true}
%       flgSave     - (logical) Whether to save the output struct. {false}
%       basepath    - (char) Base path for saving files. {pwd}
%       binSize     - (double) Bin size in seconds. {60}
%
%   OUTPUTS:
%       rcv         - (struct) Structure containing recovery metrics:
%                       .frBsl      - Baseline firing rate [Hz].
%                       .frTrough   - Trough firing rate [Hz].
%                       .frSs       - Steady-state firing rate [Hz].
%                       .pertDepth  - Log2 ratio of Baseline to Trough.
%                       .rcvErr     - Recovery error (abs log2 fold change).
%                       .rcvGain    - Recovery gain (log2 fold change).
%                       .rcvTime    - Time to detection of recovery [s].
%                       .rcvSlope   - Initial recovery slope [Hz/min].
%                       .normSlope  - Normalized slope (% range / min).
%                       .spkDfct    - Spike deficit metric.
%                       .uRcv       - Logical indicating successful recovery.
%                       .uPert      - Logical indicating significant perturbation.
%
%   See also: MEA_FRPREP, MEA_FRR

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 't', @isnumeric);
addRequired(p, 'frMat', @isnumeric);
addParameter(p, 'idxTrough', [], @isnumeric);
addParameter(p, 'uGood', [], @(x) islogical(x) || isnumeric(x));
addParameter(p, 'flgSave', false, @islogical);
addParameter(p, 'basepath', pwd, @ischar);

addParameter(p, 'binSize', 60, @isnumeric);
addParameter(p, 'flgPlot', false, @islogical);

parse(p, t, frMat, varargin{:});
idxTrough = p.Results.idxTrough;
uGood = p.Results.uGood;
flgSave = p.Results.flgSave;
basepath = p.Results.basepath;
binSize = p.Results.binSize;
flgPlot = p.Results.flgPlot;

% Infer defaults
nUnits = size(frMat, 1);
if isempty(uGood)
    uGood = true(nUnits, 1);
end
uGood = logical(uGood);

% Ensure time is a row vector
if iscolumn(t)
    t = t';
end


%% ========================================================================
%  INITIALIZATION
%  ========================================================================

% Find perturbation index (t=0)
idxPert = find(t >= -1e-9, 1, 'first');

% Initialize output vectors
bslTime = nan(nUnits, 1);
rcvTime = nan(nUnits, 1);
bslIdx = nan(nUnits, 1); % Store indices for plotting
rcvIdx = nan(nUnits, 1); % Store indices for plotting
rcvSlope = nan(nUnits, 1);
normSlope = nan(nUnits, 1);
spkDfct = nan(nUnits, 1);


%% ========================================================================
%  CALCULATE METRICS
%  ========================================================================

% Rates
% -------------------------------------------------------------------------

% Constants for numerical stability
% Hardcode c based on 1 spike in an hour
c(1) = 1 / 3600;
c(2) = c(1);

% Define Windows
winMarg = round(5 * 60 / binSize);
winDur = round(60 * 60 / binSize);

% Baseline: 1 hour window ending 5 min before perturbation
bslEnd = idxPert - winMarg;
bslStart = bslEnd - winDur;
bslWin = max(1, bslStart) : max(1, bslEnd);
frBsl = mean(frMat(:, bslWin), 2, 'omitnan');

% Steady State: 1 hour window ending 5 min before end
ssEnd = length(t) - winMarg;
ssStart = ssEnd - winDur;
ssWin = max(idxPert, ssStart) : min(length(t), ssEnd);
frSs = mean(frMat(:, ssWin), 2, 'omitnan');

% (troughWin definition moved to Calculation section)
% Trough: 10 min surrounding the recovery onset
winHalf = round(5 * 60 / binSize);
winStart = max(1, idxTrough - winHalf);
winEnd = min(length(t), idxTrough + winHalf);
troughWin = winStart : winEnd;
frTrough = mean(frMat(:, troughWin), 2, 'omitnan');

% Recovery Metrics (Ratios)
% -------------------------------------------------------------------------

% Cap FR values used in ratios
frBslC = max([frBsl, repmat(c(2), nUnits, 1)], [], 2);
frTroughC = max([frTrough, repmat(c(1), nUnits, 1)], [], 2);
frSsC = max([frSs, repmat(c(2), nUnits, 1)], [], 2);

% Perturbation Depth
pertDepth = log2(frBslC ./ frTroughC);

% Recovery Fidelity
rcvErr = abs(log2(frSsC ./ frBslC));
rcvDiff = abs(frSsC - frBslC);

% Recovery Gain and Work
rcvGain = log2(frSsC ./ frTroughC);
rcvGain(rcvGain < 0) = 0; % Cap at 0
rcvWork = rcvGain ./ pertDepth;


% Success Determination
% -------------------------------------------------------------------------
thrPert = 1;
thrRcv = 0.67;
uPert = pertDepth >= thrPert;
uRcv = uPert & (frSs >= frTrough + thrRcv * (frBsl - frTrough));
uRcv(~uGood) = false; % Only good units


% Kinetics
% -------------------------------------------------------------------------
tPost = t(idxPert:end); % Post-perturbation time vector

for iUnit = 1:nUnits
    if ~uGood(iUnit)
        continue;
    end

    % SPIKE DEFICIT
    % AUC Expected vs Observed
    if ~isnan(frBsl(iUnit))
        aucExp = trapz(tPost, ones(size(tPost)) * frBsl(iUnit));
        aucObs = trapz(tPost, frMat(iUnit, idxPert:end));
        spkDfct(iUnit) = log2(aucExp / (aucObs + 1));
    end

    % RECOVERY TIME
    % Start looking from the trough
    rcvCurve = frMat(iUnit, idxTrough:end);

    % Baseline target
    bslTrgt = frTrough(iUnit) + thrRcv * (frBsl(iUnit) - frTrough(iUnit));
    bslPnt = find(rcvCurve >= bslTrgt, 1, 'first');
    if ~isempty(bslPnt)
        absIdx = idxTrough + bslPnt - 1;
        bslIdx(iUnit) = absIdx;
        bslTime(iUnit) = t(absIdx) - t(idxPert);
    else
        bslIdx(iUnit) = length(t);
        bslTime(iUnit) = t(end) - t(idxPert);
    end

    % Steady-state target
    rcvRange = frSs(iUnit) - frTrough(iUnit);
    rcvTrgt = frTrough(iUnit) + thrRcv * rcvRange;
    rcvPnt = find(rcvCurve >= rcvTrgt, 1, 'first');
    if ~isempty(rcvPnt)
        absIdx = idxTrough + rcvPnt - 1;
        rcvIdx(iUnit) = absIdx;
        rcvTime(iUnit) = t(absIdx) - t(idxPert);
    else
        rcvIdx(iUnit) = length(t);
        rcvTime(iUnit) = t(end) - t(idxPert);
    end

    % SLOPE
    if ~isempty(rcvCurve) && length(rcvCurve) > 1
        rcvSlope(iUnit) = (max(diff(rcvCurve)) / binSize) * 60; % Hz/min
        if rcvRange ~= 0
            normSlope(iUnit) = (rcvSlope(iUnit) / rcvRange) * 100;
        end
    end
end


%% ========================================================================
%  OUTPUT STRUCT
%  ========================================================================

rcv.frBsl = frBsl;
rcv.frTrough = frTrough;
rcv.frSs = frSs;
rcv.pertDepth = pertDepth;
rcv.rcvErr = rcvErr;
rcv.rcvGain = rcvGain;
rcv.rcvWork = rcvWork;
rcv.rcvDiff = rcvDiff;
rcv.bslTime = bslTime;
rcv.rcvTime = rcvTime;
rcv.rcvSlope = rcvSlope;
rcv.normSlope = normSlope;
rcv.spkDfct = spkDfct;
rcv.uRcv = uRcv;
rcv.uPert = uPert;
rcv.idxTrough = idxTrough;
rcv.info.binSize = binSize;
rcv.info.tPert = 0;

if flgSave
    [~, basename] = fileparts(basepath);
    save(fullfile(basepath, [basename, '.frRcv.mat']), 'rcv', '-v7.3');
end

%% ========================================================================
%  PLOTTING
%  ========================================================================
if flgPlot

    % Select n random good units
    goodIdx = find(uGood);
    nPlot = min(6, length(goodIdx));

    if nPlot > 0
        % Use current random stream to shuffle, but don't reseed if not needed
        % rng('shuffle'); % Optional: user might want reproducibility
        shuffledIdx = goodIdx(randperm(length(goodIdx)));
        plotIdx = shuffledIdx(1:nPlot);
        plotIdx = [32, 44, 45, 38, 26, 12];

        figure('Position', [100, 100, 1200, 800], 'Name', 'MEA Recovery Metrics');
        nRows = ceil(nPlot/2);

        % Convert time to Hours for plotting
        tHr = t / 3600;

        for i = 1:nPlot
            uIdx = plotIdx(i);
            subplot(nRows, 2, i);
            hold on;

            % FR TRACE
            plot(tHr, frMat(uIdx, :), 'Color', [0.7 0.7 0.7], 'LineWidth', 1, ...
                'DisplayName', 'Raw FR');

            % FR BASELINE
            plot(tHr(bslWin), repmat(frBsl(uIdx), size(bslWin)), ...
                'Color', [0 0.4470 0.7410], 'LineWidth', 2, 'DisplayName', 'Baseline');

            % FR TROUGH
            plot(tHr(troughWin), repmat(frTrough(uIdx), size(troughWin)), ...
                'Color', [0.8500 0.3250 0.0980], 'LineWidth', 2, 'DisplayName', 'Trough');

            % FR STEADY STATE
            plot(tHr(ssWin), repmat(frSs(uIdx), size(ssWin)), ...
                'Color', [0.4660 0.6740 0.1880], 'LineWidth', 2, 'DisplayName', 'Steady State');


            % PERTURBATION DEPTH
            plot([tHr(idxTrough), tHr(idxTrough)], [frTrough(uIdx), frBsl(uIdx)], ...
                '--', 'Color', [0.8500 0.3250 0.0980], 'LineWidth', 2, ...
                'DisplayName', 'Pert. Depth');

            % RECOVERY GAIN
            idxSSCenter = round(mean(ssWin));
            plot([tHr(idxSSCenter), tHr(idxSSCenter)], [frTrough(uIdx), frSs(uIdx)], ...
                '--', 'Color', [0.4660 0.6740 0.1880], 'LineWidth', 2, ...
                'DisplayName', 'Rcv. Gain');

            % RECOVERY TIME
            if ~isnan(rcvIdx(uIdx))
                % use stored index for plotting x coordinate to be exact
                tRcvPlot = tHr(rcvIdx(uIdx));

                % rcvTime (metric) for display
                tRcvValHr = rcvTime(uIdx) / 3600;

                plot(tRcvPlot, frMat(uIdx, rcvIdx(uIdx)), 'p', 'MarkerSize', 10, ...
                    'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'g', ...
                    'DisplayName', sprintf('RcvTime: %.2f hr', tRcvValHr));
            end

            % BASELINE TIME
            if ~isnan(bslIdx(uIdx))
                % use stored index for plotting x coordinate to be exact
                tRcvPlot = tHr(bslIdx(uIdx));

                % rcvTime (metric) for display
                tBslValHr = bslTime(uIdx) / 3600;

                plot(tRcvPlot, frMat(uIdx, bslIdx(uIdx)), 'p', 'MarkerSize', 10, ...
                    'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'b', ...
                    'DisplayName', sprintf('BslTime: %.2f hr', tBslValHr));
            end

            % SPIKE DEFICIT
            % Deficit is calculated from idxPert to end
            idxPost = idxPert:length(t);
            if ~isempty(idxPost)
                tPostHr = tHr(idxPost);
                frObs = frMat(uIdx, idxPost);
                % Expected is Baseline
                frExp = ones(size(frObs)) * frBsl(uIdx);

                % Fill area between Baseline and Observed
                xFill = [tPostHr, fliplr(tPostHr)];
                yFill = [frExp, fliplr(frObs)];
                fill(xFill, yFill, [0.5 0.5 0.5], 'FaceAlpha', 0.1, 'EdgeColor', 'none', ...
                    'DisplayName', sprintf('SpkDfct: %.2f', spkDfct(uIdx)));
            end

            % 6. Add Text Annotations
            % Perturbation Depth -> Next to vertical line
            text(tHr(idxTrough), mean([frTrough(uIdx), frBsl(uIdx)]), ...
                sprintf(' %.2f', pertDepth(uIdx)), ...
                'VerticalAlignment', 'middle', 'HorizontalAlignment', 'left', ...
                'FontSize', 8, 'Color', [0.8500 0.3250 0.0980], 'FontWeight', 'bold');

            % Recovery Gain -> Next to vertical line
            text(tHr(idxSSCenter), mean([frTrough(uIdx), frSs(uIdx)]), ...
                sprintf(' %.2f', rcvGain(uIdx)), ...
                'VerticalAlignment', 'middle', 'HorizontalAlignment', 'right', ...
                'FontSize', 8, 'Color', [0.4660 0.6740 0.1880], 'FontWeight', 'bold');

            % 7. Formatting
            xlabel('Time (Hr)');
            ylabel('Rate (Hz)');
            title(sprintf('Unit %d', uIdx));
            grid on;
            axis tight;
            xline(0, '-', 'Pert.', 'LabelVerticalAlignment', 'bottom', 'HandleVisibility', 'off');

            if i == 1
                legend('Location', 'best', 'NumColumns', 2, 'FontSize', 7);
            end
        end
    end
end

end
