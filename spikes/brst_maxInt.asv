function brst = brst_maxInt(spktimes, varargin)
% BRST_MAXINT Detects bursts using the Max Interval method.
%
%   brst = BRST_MAXINT(SPKTIMES, ...) implements the Max Interval burst
%   detection algorithm, defined by fixed thresholds for inter-spike
%   intervals (ISIs) and burst properties.
%
%   INPUTS:
%       spktimes    - (cell) Spike times per unit (e.g., {unit1, unit2}).
%                     Times should be in seconds.
%       varargin    - (param/value) Optional parameters:
%                     'maxISI_start' : (num) Max ISI to start burst {0.17s}
%                     'maxISI_end'   : (num) Max ISI within burst {0.3s}
%                     'minIBI'       : (num) Min Inter-Burst Interval {0.2s}
%                     'minDur'       : (num) Min burst duration {0.01s}
%                     'minSpks'      : (num) Min spikes in burst {3}
%                     'flgPlot'      : (log) Plot raster with bursts {false}
%                     'basepath'     : (char) Recording path {pwd}
%                     'flgSave'      : (log) Save to file {true}
%                     'flgForce'     : (log) Analyze even if exists {false}
%
%   OUTPUTS:
%       brst        - (struct) Burst statistics and event data.
%                     Fields: detect, nspks, brstDur, freq, bspks, ibi, all.
%

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addParameter(p, 'basepath', pwd, @ischar);
addParameter(p, 'maxISI_start', 0.17, @isnumeric);
addParameter(p, 'maxISI_end', 0.3, @isnumeric);
addParameter(p, 'minIBI', 0.2, @isnumeric);
addParameter(p, 'minDur', 0.01, @isnumeric);
addParameter(p, 'minSpks', 3, @isnumeric);
addParameter(p, 'flgPlot', false, @islogical);
addParameter(p, 'flgSave', true, @islogical);
addParameter(p, 'flgForce', false, @islogical);

parse(p, varargin{:});
basepath     = p.Results.basepath;
maxISI_start = p.Results.maxISI_start;
maxISI_end   = p.Results.maxISI_end;
minIBI       = p.Results.minIBI;
minDur       = p.Results.minDur;
minSpks      = p.Results.minSpks;
flgPlot      = p.Results.flgPlot;
flgSave      = p.Results.flgSave;
flgForce     = p.Results.flgForce;


%% ========================================================================
%  PREPARATIONS
%  ========================================================================

% Load if exists
[~, basename] = fileparts(basepath);
brstfile = fullfile(basepath, [basename, '.mi_brst.mat']);

if exist(brstfile, 'file') && ~flgForce && ~flgPlot
    load(brstfile, 'brst');
    return;
end

nunits = length(spktimes);

% Initialize output structure
brst.info.runtime   = datetime("now");
brst.info.algorithm = 'MaxInterval';
brst.info.input     = p.Results;

brst.detect         = zeros(1, nunits);
brst.nspks          = nan(1, nunits);
brst.brstDur        = nan(1, nunits);
brst.freq           = nan(1, nunits);
brst.bspks          = zeros(1, nunits);
brst.ibi            = nan(1, nunits);
brst.all            = cell(1, nunits);

% For plotting
spktimes_bursts = cell(1, nunits);


%% ========================================================================
%  RUN DETECTION
%  ========================================================================

for iunit = 1 : nunits

    st = spktimes{iunit};
    if isempty(st) || length(st) < minSpks
        continue;
    end

    % Ensure column vector
    st = st(:);
    all_isis = diff(st);
    nspikes = length(st);

    % ---------------------------------------------------------------------
    % Phase 1: Core Burst Detection
    % ---------------------------------------------------------------------

    raw_bursts_idx = [];
    inBurst = false;
    currentBurstStartIdx = -1;

    k = 1;
    while k < nspikes
        if ~inBurst
            % Start criteria: Strict inequality
            if all_isis(k) < maxISI_start
                inBurst = true;
                currentBurstStartIdx = k;
                k = k + 1;
            else
                k = k + 1;
            end
        else
            % Continuation criteria: Inclusive inequality
            if all_isis(k) <= maxISI_end
                k = k + 1;
            else
                % End of burst
                currentBurstEndIdx = k;
                raw_bursts_idx = [raw_bursts_idx; currentBurstStartIdx, currentBurstEndIdx]; %#ok<AGROW>
                inBurst = false;
                k = k + 1;
            end
        end
    end

    % Close last burst if active
    if inBurst
        raw_bursts_idx = [raw_bursts_idx; currentBurstStartIdx, nspikes]; %#ok<AGROW>
    end

    if isempty(raw_bursts_idx)
        continue;
    end

    % ---------------------------------------------------------------------
    % Phase 2: Merge Bursts
    % ---------------------------------------------------------------------

    merged_bursts_idx = [];
    if size(raw_bursts_idx, 1) > 0
        curr_start = raw_bursts_idx(1, 1);
        curr_end   = raw_bursts_idx(1, 2);

        for b = 2:size(raw_bursts_idx, 1)
            next_start = raw_bursts_idx(b, 1);
            next_end   = raw_bursts_idx(b, 2);

            % IBI: Time between end of previous and start of next
            t_end   = st(curr_end);
            t_start = st(next_start);
            ibi     = t_start - t_end;

            if ibi < minIBI
                % Merge
                curr_end = next_end;
            else
                % Commit & Start New
                merged_bursts_idx = [merged_bursts_idx; curr_start, curr_end]; %#ok<AGROW>
                curr_start = next_start;
                curr_end   = next_end;
            end
        end
        merged_bursts_idx = [merged_bursts_idx; curr_start, curr_end]; %#ok<AGROW>
    end

    % ---------------------------------------------------------------------
    % Phase 3: Filter (Duration & nSpikes)
    % ---------------------------------------------------------------------

    final_bursts_idx = [];
    for b = 1:size(merged_bursts_idx, 1)
        s_idx = merged_bursts_idx(b, 1);
        e_idx = merged_bursts_idx(b, 2);

        n_spks = e_idx - s_idx + 1;
        dur    = st(e_idx) - st(s_idx);

        if n_spks >= minSpks && dur >= minDur
            final_bursts_idx = [final_bursts_idx; s_idx, e_idx]; %#ok<AGROW>
        end
    end

    if isempty(final_bursts_idx)
        continue;
    end

    % ---------------------------------------------------------------------
    % Collect Statistics
    % ---------------------------------------------------------------------

    nb = size(final_bursts_idx, 1);

    b_struct.times = zeros(nb, 2);
    b_struct.nspks = zeros(nb, 1);
    b_struct.dur   = zeros(nb, 1);
    b_struct.freq  = zeros(nb, 1);
    b_struct.ibi   = nan(nb, 1);

    % For IBI calc
    fl_times = zeros(nb, 2);

    % For plotting
    curr_unit_burst_spks = [];

    for b = 1:nb
        s_idx = final_bursts_idx(b, 1);
        e_idx = final_bursts_idx(b, 2);

        b_struct.times(b, :) = [st(s_idx), st(e_idx)];
        b_struct.nspks(b)    = e_idx - s_idx + 1;
        b_struct.dur(b)      = st(e_idx) - st(s_idx);
        b_struct.freq(b)     = b_struct.nspks(b) / b_struct.dur(b);

        fl_times(b, :) = [st(s_idx), st(e_idx)];

        if flgPlot
            curr_unit_burst_spks = [curr_unit_burst_spks; st(s_idx:e_idx)]; %#ok<AGROW>
        end
    end

    if nb > 1
        b_struct.ibi(2:end) = fl_times(2:end, 1) - fl_times(1:end-1, 2);
    end

    total_spikes_in_bursts = sum(b_struct.nspks);

    brst.detect(iunit)  = nb;
    brst.nspks(iunit)   = mean(b_struct.nspks);
    brst.brstDur(iunit) = mean(b_struct.dur);
    brst.freq(iunit)    = mean(b_struct.freq);
    brst.bspks(iunit)   = total_spikes_in_bursts / length(st);
    brst.ibi(iunit)     = mean(b_struct.ibi, 'omitnan');

    brst.all{iunit} = b_struct;

    if flgPlot
        spktimes_bursts{iunit} = curr_unit_burst_spks;
    end
end


%% ========================================================================
%  PLOTTING
%  ========================================================================

if flgPlot
    
    [hFig, hAx] = plot_axSize('szOnly', false, 'flgFullscreen', true, ...
        'flgPos', true);
    winPlot = [0, 60];
    lnHeight = 0.8;
    lnWidth = 0.8;

    % Plot all spikes in gray
    clr = [0.8 0.8 0.8]; % Light gray
    [hAx, hPlt] = plot_raster(spktimes, 'PlotType', 'vertline', ...
        'lineHeight', lnHeight, ...
        'lineWidth', lnWidth, ...
        'hAx', hAx, ...
        'clr', clr, ...
        'xLim', winPlot);
    hold(hAx, 'on');

    % Plot burst spikes in color (Red)
    clr = [0.85 0.33 0.1]; 
    [hAx, hPlt] = plot_raster(spktimes_bursts, 'PlotType', 'vertline', ...
        'lineHeight', 0.8, ...
        'lineWidth', lnWidth, ...
        'hAx', hAx, ...
        'clr', clr, ...
        'xLim', winPlot);

    title(hAx, 'Max Interval Burst Detection');
    xlabel('Time (s)')
    ylabel('Unit No.')

end


%% ========================================================================
%  SAVE
%  ========================================================================

if flgSave
    save(brstfile, 'brst');
end

end

%% ========================================================================
%  NOTE: ALGORITHM
%  ========================================================================
%  The Max Interval algorithm identifies bursts based on Inter-Spike Intervals
%  (ISIs) using a four-step process. This implementation follows the
%  standard described by Cotterill et al. (2016) and the NeuroExplorer
%  manual.
%
%  1. CORE DETECTION:
%       Find "cores" of potential bursts. A core must begin with an ISI
%       strictly less than 'maxISI_start'.
%
%  2. EXTENSION:
%       Extend the core to subsequent spikes as long as each ISIs remains
%       less than or equal to 'maxISI_end'. The burst ends when an ISI
%       exceeds this threshold.
%
%  3. MERGING:
%       If the interval between the end of one burst and the start of the
%       next (the Inter-Burst Interval, IBI) is less than 'minIBI', the two
%       bursts are merged into a single event.
%
%  4. FILTERING:
%       Discard any candidate bursts that do not meet the minimum duration
%       ('minDur') or minimum spike count ('minSpks') criteria.
%  ========================================================================


%% ========================================================================
%  NOTE: REFERENCES
%  ========================================================================
%  - Cotterill, E., et al. (2016). A comparison of computational methods
%    for detecting bursts in neuronal spike trains and their application to
%    human stem cell-derived neuronal networks. J. Neurophysiol.
%  - NeuroExplorer Manual, section 2.24.
%  ========================================================================
