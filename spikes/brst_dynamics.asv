function dyn = brst_dynamics(brst, spktimes, varargin)
% BRST_DYNAMICS Computes time-varying burst dynamics (Population Ready).
%
%   dyn = BRST_DYNAMICS(BRST, SPKTIMES, ...) converts discrete burst events
%   (from brst_maxInt) into continuous time-series using density estimation
%   (for rates) and interpolation with adaptive masking (for properties).
%
%   INPUTS:
%       brst        - (struct) Output from brst_maxInt.m
%       spktimes    - (cell) Spike times per unit.
%       varargin    - (param/value) Optional parameters:
%                     'binSize'   : (num) Time bin size {1} (s)
%                     'kernelSD'  : (num) Gaussian kernel sigma {5} (s)
%                     'smoothWin' : (num) Smoothing window {10} (events)
%                     'ibiPct'    : (num) Percentile for masking gap {99}
%                     'flgPlot'   : (log) Plot dynamics {true}
%
%   OUTPUTS:
%       dyn         - (struct) Dynamics structure.
%                     .time     : (1 x nTime) Time vector.
%                     .rate     : (nTime x nUnits) Burst rate (Hz).
%                     .bfrac    : (nTime x nUnits) Burst fraction.
%                     .dur      : (nTime x nUnits) Duration (s).
%                     .nspks    : (nTime x nUnits) Spikes per burst.
%                     .freq     : (nTime x nUnits) Intra-burst freq (Hz).
%                     .ibi      : (nTime x nUnits) Inter-burst interval (s).
%
%   NOTE:
%   Properties (.dur, .nspks, etc) are interpolated to the global time
%   grid. Periods of silence exceeding the 'ibiPct' percentile of a unit's
%   IBI distribution are masked as NaN to distinguish "undefined" states
%   from zero values.
%

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'brst', @isstruct);
addRequired(p, 'spktimes', @iscell);
addParameter(p, 'binSize', 1, @isnumeric);
addParameter(p, 'kernelSD', 5, @isnumeric);
addParameter(p, 'smoothWin', 10, @isnumeric);
addParameter(p, 'ibiPct', 95, @isnumeric);
addParameter(p, 'flgPlot', true, @islogical);

parse(p, brst, spktimes, varargin{:});
binSize   = p.Results.binSize;
kernelSD  = p.Results.kernelSD;
smoothWin = p.Results.smoothWin;
ibiPct    = p.Results.ibiPct;
flgPlot   = p.Results.flgPlot;


%% ========================================================================
%  INITIALIZE
%  ========================================================================

nUnits = length(brst.all);

% Determine global time range
maxTime = 0;
for iUnit = 1:nUnits
    if ~isempty(spktimes{iUnit})
        maxTime = max(maxTime, max(spktimes{iUnit}));
    end
end

% Time vector
t = 0 : binSize : ceil(maxTime);
nTime = length(t);

% Initialize Matrices
dyn.time  = t;
dyn.rate  = zeros(nTime, nUnits);
dyn.bfrac = zeros(nTime, nUnits);
dyn.dur   = nan(nTime, nUnits);
dyn.nspks = nan(nTime, nUnits);
dyn.freq  = nan(nTime, nUnits);
dyn.ibi   = nan(nTime, nUnits);


%% ========================================================================
%  COMPUTE DYNAMICS
%  ========================================================================

% Create Gaussian Kernel
kRange = -3*kernelSD : binSize : 3*kernelSD;
kernel = normpdf(kRange, 0, kernelSD);
kernel = kernel / sum(kernel);

for iUnit = 1:nUnits

    st = spktimes{iUnit};
    b_struct = brst.all{iUnit};

    if isempty(st) || isempty(b_struct) || isempty(b_struct.times)
        continue;
    end

    % ---------------------------------------------------------------------
    % 1. Density Estimation (Continuous)
    % ---------------------------------------------------------------------

    % Burst Rate
    onsets = b_struct.times(:, 1);
    bCounts = histcounts(onsets, [t, inf]);
    dyn.rate(:, iUnit) = conv(bCounts, kernel, 'same') / binSize;

    % Burst Fraction
    % Identify burst spikes
    isBurstSpike = false(size(st));
    for b = 1:size(b_struct.times, 1)
        isBurstSpike = isBurstSpike | ...
            (st >= b_struct.times(b, 1) & st <= b_struct.times(b, 2));
    end
    st_burst = st(isBurstSpike);

    allCounts = histcounts(st, [t, inf]);
    densAll = conv(allCounts, kernel, 'same') / binSize;
    brstCounts = histcounts(st_burst, [t, inf]);
    densBrst = conv(brstCounts, kernel, 'same') / binSize;

    frac = zeros(size(densAll));
    mask = densAll > 1e-6;
    frac(mask) = densBrst(mask) ./ densAll(mask);
    dyn.bfrac(:, iUnit) = frac;


    % ---------------------------------------------------------------------
    % 2. Property Tracking (Interpolated & Masked)
    % ---------------------------------------------------------------------

    % A. Calculate Mask Threshold (Adaptive)
    % Use percentile of unit's own IBI distribution
    unit_ibis = b_struct.ibi(~isnan(b_struct.ibi));
    if isempty(unit_ibis)
        maskThresh = 60; % Fallback if only 1 burst
    else
        maskThresh = prctile(unit_ibis, ibiPct);
    end

    % Ensure threshold isn't too small (min 2*binSize) to catch adjacent bins
    maskThresh = max(maskThresh, 2 * binSize);


    % Apply to all props
    tTimes = b_struct.times(:, 1);

    % Handle single-burst case (cannot interpolate 1 point)
    if length(tTimes) < 2
        % If only 1 burst, we can't interpolate slope.
        % Assign value to nearest bins within threshold.

        % Fix for minimal data:
        if length(tTimes) == 1
            % valid bins near the single burst
            isNear = abs(t - tTimes) <= maskThresh;

            dyn.dur(isNear, iUnit)   = b_struct.dur;
            dyn.nspks(isNear, iUnit) = b_struct.nspks;
            dyn.freq(isNear, iUnit)  = b_struct.freq;
            % IBI undefined for 1 burst
            continue;
        end
    end

    dyn.dur(:, iUnit)   = proc_prop(b_struct.dur, tTimes, t, smoothWin, maskThresh);
    dyn.nspks(:, iUnit) = proc_prop(b_struct.nspks, tTimes, t, smoothWin, maskThresh);
    dyn.freq(:, iUnit)  = proc_prop(b_struct.freq, tTimes, t, smoothWin, maskThresh);
    dyn.ibi(:, iUnit)   = proc_prop(b_struct.ibi, tTimes, t, smoothWin, maskThresh);

end


%% ========================================================================
%  PLOTTING
%  ========================================================================

if flgPlot
    figure('Color', 'w', 'Name', 'Burst Dynamics (Pop)');

    % Rate
    subplot(3, 1, 1);
    plot(dyn.time, mean(dyn.rate, 2), 'k', 'LineWidth', 1.5);
    title('Population Mean Burst Rate');
    ylabel('Hz'); xlim([0 maxTime]);

    % Duration (nanmean handles the gaps automatically!)
    subplot(3, 1, 2);
    plot(dyn.time, mean(dyn.dur, 2, 'omitnan'), 'r', 'LineWidth', 1.5);
    title('Population Mean Duration (Masked)');
    ylabel('Seconds'); xlim([0 maxTime]);

    % Freq
    subplot(3, 1, 3);
    plot(dyn.time, mean(dyn.freq, 2, 'omitnan'), 'b', 'LineWidth', 1.5);
    title('Population Mean Intra-Burst Freq (Masked)');
    ylabel('Hz'); xlim([0 maxTime]);
    xlabel('Time (s)');
end

end % EOF


% -------------------------------------------------------------------------
% NESTED FUNCTIONS (Helper)
% -------------------------------------------------------------------------

function vec = proc_prop(rawVal, timePoints, tVec, smoothWin, maskThresh)
% Processes a property vector: Smooth -> Interpolate -> Mask

if length(rawVal) < smoothWin
    % Not enough points to smooth well, just use mean or raw
    smVal = rawVal;
else
    smVal = movmedian(rawVal, smoothWin, 'omitnan');
end

% Interpolate to global time grid
% 'linear' provides smooth transitions between events
% 'extrap' with NaN prevents wild guesses outside range
vec = interp1(timePoints, smVal, tVec, 'linear', NaN);

% Identify Gaps (Masking)
% Manual Gap Filling approach:

% 1. Gap before first burst
vec(tVec < timePoints(1) - maskThresh) = NaN;

% 2. Gap after last burst
vec(tVec > timePoints(end) + maskThresh) = NaN;

% 3. Interior Gaps
% Find intervals in timePoints where diff > maskThresh
gaps = find(diff(timePoints) > maskThresh);
for g = 1:length(gaps)
    idx1 = gaps(g);
    idx2 = gaps(g) + 1;
    t_start = timePoints(idx1) + maskThresh; % Start of gap
    t_end   = timePoints(idx2) - maskThresh; % End of gap

    if t_end > t_start
        vec(tVec > t_start & tVec < t_end) = NaN;
    end
end

% Transpose to column
vec = vec(:);
end


%% ========================================================================
%  NOTE: THE NECESSITY OF INTERPOLATION FOR POPULATION ANALYSIS
%  ========================================================================
%  This function uses interpolation to transform asynchronous unit data
%  into a synchronized matrix format suitable for genotype comparisons.
%  Because Unit A might burst at t=10s and Unit B at t=15s, simply
%  averaging their properties without a shared temporal grid is impossible.
%  Interpolation projects the property value of a specific burst onto the
%  global time vector T. This creates a continuous "estimate" of what the
%  burst duration would be if a burst occurred at that exact moment, based
%  on the nearest real observations.
%  ========================================================================

%% ========================================================================
%  NOTE: DISTINGUISHING ZERO FROM UNDEFINED STATES
%  ========================================================================
%  If we do not mask our interpolated data, a unit that bursts at the start
%  of a recording and then remains silent for the remainder will appear to
%  have a constant, "flat" duration across the entire experiment. This is
%  biologically misleading because the property (duration) only exists
%  during the event itself. While a burst rate of zero is a valid
%  measurement of inactivity, a burst duration of zero is a physical
%  impossibility in this detection framework (as the algorithm requires
%  minimum spikes and duration). Therefore, periods of silence are treated
%  as NaN (undefined) rather than zero.
%  ========================================================================

%% ========================================================================
%  NOTE: DEFINING THE MASKING WINDOW NON-ARBITRARILY
%  ========================================================================
%  To avoid arbitrary thresholds (e.g., "2 minutes silence"), we determine
%  the masking window based on the statistical behavior of the Inter-Burst
%  Interval (IBI). The function calculates the 95th (or user-specified)
%  percentile of the IBI for each unit. If the time elapsed since the last
%  detected burst exceeds this calculated "Expected IBI," the property is
%  masked as NaN. This ensures that the population average is only
%  calculated from units that are actively participating in the network's
%  bursting state at that specific time.
%  ========================================================================

%% ========================================================================
%  NOTE: BEHAVIOR OF MOVING MEDIANS AND MISSING DATA
%  ========================================================================
%  Applying a movmedian across the entire length of the recording is only
%  possible if you have a value for every time bin, which effectively
%  forces you to assume a value (like zero) for bins without bursts. This
%  is incorrect for structural metrics like brstDur or nspks. By performing
%  the movmedian on the event index first—meaning we smooth across the last
%  N bursts regardless of when they happened—we preserve the internal
%  structural integrity of the burst properties. The interpolation and
%  subsequent masking then allow us to align these "active state" values
%  across the population while correctly identifying periods where the unit
%  has dropped out of the bursting state.
%  ========================================================================
