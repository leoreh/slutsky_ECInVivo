function cc = fr_corr(spkmat, varargin)
% FR_CORR Computes pairwise correlations of single-unit FR trajectories.
%
%   cc = FR_CORR(spkmat) calculates the Pearson correlation coefficients between
%   all pairs of single-unit FR trajectories. It employs a shuffling
%   procedure to determine a significance threshold (noise floor) and
%   computes metrics based on both valid (significant) and raw correlations.
%
%   METHODOLOGY:
%   1.  Omit silent neurons.
%   2.  Z-score each unit (temporally).
%   3.  Compute raw covariance matrix (Pearson correlation).
%   4.  Estimate noise floor via circular shuffling (shift-predictor):
%       - Each unit's spike train is circularly shifted by a random amount.
%       - Correlations are re-computed on shifted data.
%       - This preserves auto-correlation but destroys cross-correlation.
%   5.  Define threshold = mean(Noise) + K * std(Noise).
%   6.  Identify "significant" correlations as those where |raw| > threshold.
%   7.  Compute average correlation from these significant pairs.
%
%   INPUTS:
%       spkmat      - (matrix) Activity Matrix (Neurons x Time).
%       varargin    - (param/value) Optional parameters:
%                     'nShuffles'     : (int) Number of shuffles for noise est {10}
%                     'thresholdVal'  : (num) SD multiplier for threshold {2}
%                     'flgPlot'       : (log) Plot correlation matrix {false}
%
%   OUTPUTS:
%       cc          - (struct) Result structure:
%                     .mcc      : Mean correlation of significant pairs.
%                     .mccRaw   : Mean correlation of all pairs (diag removed).
%                     .cc       : Raw correlation matrix (diag removed).
%                     .ccSig    : significant correlation matrix (others 0).
%                     .mask     : Logical mask of significant pairs.
%                     .noise    : Noise statistics (mean, std, limit).
%                     .params   : Input parameters.
%
%   See also DIM_CALC, FR_NETWORK

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'spkmat', @isnumeric);
addParameter(p, 'nShuffles', 10, @isnumeric);
addParameter(p, 'thresholdVal', 2, @isnumeric);
addParameter(p, 'flgPlot', false, @islogical);

parse(p, spkmat, varargin{:});
nShuffles    = p.Results.nShuffles;
thresholdVal = p.Results.thresholdVal;
flgPlot      = p.Results.flgPlot;


%% ========================================================================
%  PRE-PROCESSING
%  ========================================================================

% Initialize Output
cc.mcc    = NaN;
cc.mccRaw = NaN;
cc.cc     = [];
cc.ccSig  = [];
cc.mask   = [];
cc.noise  = struct('mean', NaN, 'std', NaN, 'limit', NaN);
cc.params = p.Results;

% Remove silent neurons
nUnitsRaw = size(spkmat, 1);
mY = mean(spkmat, 2);
validIdx = mY > 0;
nUnits = sum(validIdx);

if nUnits < 2
    cc.cc = nan(nUnitsRaw);
    return;
end

% Z-score only valid units
% Normalizing allows using cov() to get Pearson correlation directly
spkz = zscore(spkmat(validIdx, :), 0, 2);


%% ========================================================================
%  RAW CORRELATIONS
%  ========================================================================

% cov expects observations in rows, variables in cols.
% Z is Neurons x Time. We want Neuron-Neuron corr.
% So we treat Time as observations (rows) and Neurons as variables (cols).
r = cov(spkz');

% Remove diagonal (auto-correlations)
r = r - diag(diag(r));

% Raw Mean Correlation (average of all off-diagonal elements)
% Since matrix is symmetric and 0 on diag, sum(all)/(N^2-N) is mean.
valOffDiag = r(eye(nUnits) == 0);
cc.mccRaw = mean(valOffDiag);


%% ========================================================================
%  NOISE ESTIMATION
%  ========================================================================

valsShuffle = [];

for iShuff = 1:nShuffles
    Z_shuff = zeros(size(spkz));
    nTime = size(spkz, 2);

    % Circular shift each neuron independently
    for iU = 1:nUnits
        shift = randi(nTime);
        Z_shuff(iU, :) = circshift(spkz(iU, :), shift, 2);
    end

    % Compute shuffle correlations
    ccShuff = cov(Z_shuff');
    ccShuff = ccShuff - diag(diag(ccShuff));

    % Collect off-diagonal values
    valsShuffle = [valsShuffle; ccShuff(eye(nUnits) == 0)]; %#ok<AGROW>
end

% Noise Statistics
noiseMean = mean(valsShuffle);          % Should be zero
noiseStd  = std(valsShuffle);
limit = noiseMean + noiseStd * thresholdVal;

cc.noise.mean  = noiseMean;
cc.noise.std   = noiseStd;
cc.noise.limit = limit;

%% ========================================================================
%  CALC: SIGNIFICANT CORRELATIONS
%  ========================================================================

% Identify significant pairs
% Using absolute value for thresholding (strong positive OR negative corr)
maskValid = abs(r) > limit;

% Apply mask (keep sign of original correlation)
ccSigValid = r;
ccSigValid(~maskValid) = 0;

% Compute Mean of significant correlations
valsSig = r(maskValid);

if isempty(valsSig)
    cc.mcc = 0;
else
    cc.mcc = mean(valsSig);
end

% Mean Functional Connectivity per Unit
funcon = sum(abs(ccSigValid), 2) ./ (nUnits - 1);

%% ========================================================================
%  EXPAND
%  ========================================================================

% Reconstruct full matrices (keeping NaNs for silent units)
cc.cc = nan(nUnitsRaw);
cc.cc(validIdx, validIdx) = r;

cc.ccSig = nan(nUnitsRaw);
cc.ccSig(validIdx, validIdx) = ccSigValid;

cc.mask = false(nUnitsRaw);
cc.mask(validIdx, validIdx) = maskValid;

cc.funcon = nan(nUnitsRaw, 1);
cc.funcon(validIdx) = funcon;

%% ========================================================================
%  PLOT
%  ========================================================================

if flgPlot
    figure('Color', 'w', 'Position', [100 100 1200 400]);

    % 1. Raw Matrix
    subplot(1, 3, 1);
    imagesc(cc.cc);
    colorbar; axis square;
    title(['Raw (mcc: ' num2str(cc.mccRaw, '%.3f') ')']);
    xlabel('Neuron ID'); ylabel('Neuron ID');

    % 2. Histogram of Values vs Noise
    subplot(1, 3, 2);
    hold on;
    histogram(valsShuffle, 50, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'DisplayName', 'Noise');
    histogram(valOffDiag, 50, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'DisplayName', 'Data');
    xline(limit, 'r--', 'Limit');
    xline(-limit, 'r--', 'Limit');
    legend('Location', 'best');
    title(['Threshold: ' num2str(thresholdVal) ' \sigma']);
    axis square;

    % 3. Significant Matrix
    subplot(1, 3, 3);
    imagesc(cc.ccSig);
    colorbar; axis square;
    title(['Significant (mcc: ' num2str(cc.mcc, '%.3f') ')']);
    xlabel('Neuron ID'); ylabel('Neuron ID');

    sgtitle('Pairwise Correlation Analysis');
end

end     % EOF



