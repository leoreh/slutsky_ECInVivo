function results = spk2ca_sweep()
% SPK2CA_SWEEP Performs parameter sweep (Kd, n, Vmax) on real MEA data.
%
%   results = SPK2CA_SWEEP(BASEPATHS) loads spiking data from the given
%   basepaths and iterates through a range of Hill coefficients (n),
%   dissociation constants (Kd), and Vmax values. For each combination,
%   it calculates the Steady-State to Baseline ratio of mitochondrial calcium.
%
%   The goal is to find parameters that minimize the log-ratio (drift)
%   between baseline and steady-state periods, optimizing for 'recovery'
%   accuracy.
%
%   INPUTS:
%       basepaths   - (cell) List of recording directories.
%
%   OUTPUTS:
%       results     - (struct) Sweep results.
%                     .tbl      : (table) Unit-wise results.
%                     .sweep_Kd : (vec) Tested Kd values.
%                     .sweep_n  : (vec) Tested n values.
%                     .sweep_V  : (cell) Tested Vmax values.
%                     .errMat   : (Kd x n x Vmax) Population error matrix.
%                     .sigMat   : (nUnits x Kd x n x Vmax x nBins) Binned signals.
%
%   See also: SPK2CA, SPK2CA_SIM

%% ========================================================================
%  LOAD AND PREPARE DATA
%  ========================================================================

cfg = mcu_cfg;
basepaths = mcu_basepaths('mea_bac');
vars = {'mea', 'fr', 'frRcv'};
v = basepaths2vars('basepaths', basepaths, 'vars', vars, 'flgPrnt', false);
nFiles = length(basepaths);

% TABLE
varMap = struct();
varMap.uGood = 'fr.uGood';
varMap.uRcv = 'rcv.uRcv';
varMap.uPert = 'rcv.uPert';
varMap.spktimes = 'mea.spktimes';
varMap.frt = 'fr.fr';
tagFiles.Name = get_mname(basepaths, 0);
tagFiles.Group = repmat(cfg.lbl.grp(1), 1, nFiles);
tagFiles.Group(contains(tagFiles.Name, 'KO')) = cfg.lbl.grp(2);
tbl = v2tbl('v', v, 'varMap', varMap, 'tagFiles', tagFiles, ...
    'uOffset', 0);
tbl.UnitID = categorical(tbl.UnitID);
tbl(~tbl.uGood, :) = [];
tbl(~tbl.uPert, :) = [];

% Limit spktimes to experiment
winExp = [0, 9 * 60]  * 60;
spktimes = cellfun(@(x) x(x >= winExp(1) & x <= winExp(2)), ...
    tbl.spktimes, 'UniformOutput', false);

%% ========================================================================
%  TIME VECTORS
%  ========================================================================

% 1 ms resolution
dt = 0.001;
maxTime = max(cellfun(@(x) max([0; x(:)]), tbl.spktimes));
tVec = 0:dt:maxTime;

% 1 min resolution (for signal storage)
binSize  = 60;
chunks = n2chunks('n', maxTime, 'chunksize', binSize, 'lastChunk', 'exclude');
edges = [chunks(:,1)-1, chunks(:,2)];
edges = unique(edges(:))';
tBins = edges(1:end-1) + diff(edges)/2;
nBins = length(tBins);

% For plotting/comparison logic (FR traces)
xVec = v(1).fr.t / 3600;

%% ========================================================================
%  PARAMETER SWEEP
%  ========================================================================

% Parameter Spaces
Kd = [0.1, 1, 4, 10, 20];
n  = [2.7, 6];
Vmax = {1e-7, 1e-5, 1e-3, []}; % Empty means auto-estimated

nKd = length(Kd);
nN  = length(n);
nVmax = length(Vmax);
nUnits = size(tbl, 1);

% Constants
isiGain  = 0;
tauC     = 0.1;
tauM     = 20;

% Windows (Indices for Steady State / Baseline calculation)
idxZero = find(xVec >= 0, 1);
winBsl = [1, idxZero - 8];
winSs = [length(xVec) - winBsl(2), length(xVec) - 1];
winCalc = [winBsl; winSs] * 60 * 1000; % Convert to ms for indexing M vector

% Pre-allocate
% resMat is (nUnits x 2 x nKd x nN x nVmax). Dimension 2: 1=Baseline, 2=SteadyState
% sigMat is (nUnits x nKd x nN x nVmax x nBins)
resMat = zeros(nUnits, 2, nKd, nN, nVmax);
sigMat = zeros(nUnits, nKd, nN, nVmax, nBins);

% Initialize parpool
if isempty(gcp('nocreate'))
    parpool('local', 8);
end
dq = parallel.pool.DataQueue;
afterEach(dq, @(msg) fprintf('%s', msg));
fprintf('Starting Sweep [%d Units x %d Params]...\n', nUnits, nKd*nN*nVmax);

parfor iUnit = 1:nUnits

    % Cytosolic Calcium
    st = spktimes{iUnit};
    C = spk2cyto(st, 't', tVec, 'dt', dt, 'tauC', tauC, 'isiGain', isiGain);

    % Prepare bin indices for this unit (same for all params)
    binIdx = discretize(tVec, edges);
    valid = ~isnan(binIdx);
    bi = binIdx(valid);

    tmpRes = zeros(2, nKd, nN, nVmax);
    tmpSig = zeros(nKd, nN, nVmax, nBins);

    for iKd = 1 : nKd
        for iN = 1 : nN
            for iV = 1 : nVmax

                % Mito Integration
                M = cyto2mito(C, 'n', n(iN), 'Kd', Kd(iKd), ...
                    'dt', dt, 'tauM', tauM, 'Vmax', Vmax{iV});

                % Binning (Mean per minute)
                Mt = accumarray(bi(:), M(valid), [nBins, 1], @mean);
                tmpSig(iKd, iN, iV, :) = binnedM;

                % Mean in windows (for error calculation)
                tmpRes(1, iKd, iN, iV) = mean(M(winCalc(1, 1) : winCalc(1, 2)), 'omitnan');
                tmpRes(2, iKd, iN, iV) = mean(M(winCalc(2, 1) : winCalc(2, 2)), 'omitnan');

            end
        end
    end
    resMat(iUnit, :, :, :, :) = tmpRes;
    sigMat(iUnit, :, :, :, :) = tmpSig;
    send(dq, sprintf('Unit %d / %d processed.\n', iUnit, nUnits));
end


%% ========================================================================
%  ERROR
%  ========================================================================

% 1. FIRING RATE REFERENCE
% Calculate FR Log Ratio as the benchmark for homeostatic accuracy
frBsl = mean(tbl.frt(:, winBsl(1) : winBsl(2)), 2, 'omitnan');
frSs  = mean(tbl.frt(:, winSs(1) : winSs(2)), 2, 'omitnan');

% Dynamic offset for FR (1% of median baseline)
offFr = median(frBsl(frBsl > 0)) * 0.01;
logFr = abs(log((frSs + offFr) ./ (frBsl + offFr)));

% 2. MITOCHONDRIAL SWEEP ANALYSIS
errMat = zeros(nKd, nN, nVmax);
riiMat = zeros(nKd, nN, nVmax); % Recovery Improvement Index

for iKd = 1:nKd
    for iN = 1:nN
        for iV = 1:nVmax
            % Extract data: (nUnits x 2)
            currDat = resMat(:, :, iKd, iN, iV);
            mBsl = currDat(:, 1);
            mSs  = currDat(:, 2);

            % Define dynamic offset (1% of median baseline for this param set)
            offMito = median(mBsl(mBsl > 0), 'omitnan') * 0.01;
            if isnan(offMito) || offMito == 0, offMito = eps; end

            % SNR Mask
            uValid = mBsl > (offMito * 10);

            if sum(uValid) < (nUnits * 0.1)
                errMat(iKd, iN, iV) = NaN;
                continue;
            end

            % Log Ratio for Mito
            logMito = abs(log((mSs + offMito) ./ (mBsl + offMito)));

            % Recovery Improvement Index (RII)
            rii = logFr(uValid) - logMito(uValid);

            % Store Median Absolute Error
            errMat(iKd, iN, iV) = median(logMito(uValid), 'omitnan');
            riiMat(iKd, iN, iV) = median(rii, 'omitnan');
        end
    end
end



%% ========================================================================
%  INTERACTIVE GUI prep
%  ========================================================================

% Flatten results into table columns for GUI
for iKd = 1 : nKd
    for iN = 1 : nN
        for iV = 1 : nVmax

            currV = Vmax{iV};
            if isempty(currV)
                strV = 'Auto';
            else
                strV = sprintf('%g', currV);
                strV = strrep(strV, '.', 'p');
                strV = strrep(strV, '-', 'n'); % Handle scientific notation e.g. 1e-4
            end

            suffix = sprintf('_K%g_n%g_V%s', Kd(iKd), n(iN), strV);
            suffix = strrep(suffix, '.', 'p');

            tbl.(['mBsl' suffix]) = resMat(:, 1, iKd, iN, iV);
            tbl.(['mSs' suffix])  = resMat(:, 2, iKd, iN, iV);
        end
    end
end

% Combine with tblu from mea_spk2ca (assuming it exists in workspace or re-derived)
% Since tbl is derived from 'v' here and verified against original code, we proceed with tbl.

% Remove units with low mito (using the most permissive check across params)
% This is just for visualization/cleanliness
clipIdx = find(squeeze(any(any(any(any(resMat < 1e-20, 2), 3), 4), 5)));
tblPlot = tbl;
tblPlot(clipIdx, :) = [];

% Note: not calling local gui/plot functions automatically to keep it clean.
% tblGUI_scatHist(tblPlot);


%% ========================================================================
%  HEATMAP: PARAMETER SWEEP RESULTS
%  ========================================================================

figure('Name', 'Parameter Sweep Results', 'Color', 'w', 'NumberTitle', 'off');

% Create tabs if multiple Vmax, or just subplots
tgroup = uitabgroup(gcf);

for iV = 1 : nVmax
    currV = Vmax{iV};
    if isempty(currV)
        tabTitle = 'Vmax: Auto';
    else
        tabTitle = sprintf('Vmax: %g', currV);
    end

    tab = uitab(tgroup, 'Title', tabTitle);
    ax = axes('Parent', tab);

    % Plot Heatmap (Transpose for n-rows, Kd-cols)
    % errMat is (Kd x n x Vmax), so take page iV and transpose
    valMat = riiMat(:, :, iV)';

    imagesc(ax, Kd, n, valMat);
    hCbar = colorbar(ax);
    hCbar.Label.String = 'RII (Pos = Better)';
    colormap(ax, 'parula');
    axis(ax, 'xy');

    % Aesthetics
    title(ax, ['Recovery Improvement Index - ' tabTitle]);
    xlabel(ax, 'Dissociation Constant (Kd)');
    ylabel(ax, 'Hill Coefficient (n)');
    set(ax, 'XTick', Kd, 'YTick', n);
    set(ax, 'FontSize', 12, 'LineWidth', 1.2);

    % Overlay Values
    minVal = min(valMat(:), [], 'omitnan');
    maxVal = max(valMat(:), [], 'omitnan');
    if isempty(minVal), minVal = 0; end
    if isempty(maxVal), maxVal = 1; end
    rangeVal = maxVal - minVal;

    for iN_idx = 1:nN
        for iKd_idx = 1:nKd
            val = valMat(iN_idx, iKd_idx);
            if isnan(val), continue; end

            % Contrast Logic
            if val < (minVal + rangeVal * 0.5)
                txtColor = 'w';
            else
                txtColor = 'k';
            end

            text(ax, Kd(iKd_idx), n(iN_idx), sprintf('%.2f', val), ...
                'HorizontalAlignment', 'center', ...
                'Color', txtColor, 'FontWeight', 'bold');
        end
    end
end

%% ========================================================================
%  OUTPUT PACKAGING
%  ========================================================================

results.tbl      = tbl;
results.sweep_Kd = Kd;
results.sweep_n  = n;
results.sweep_V  = Vmax;
results.errMat   = errMat;
results.riiMat   = riiMat;
results.sigMat   = sigMat;
results.tBins    = tBins;

end % EOF

