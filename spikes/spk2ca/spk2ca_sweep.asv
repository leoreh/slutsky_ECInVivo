function spk2ca_sweep()
% SPK2CA_SWEEP Performs parameter sweep (Kd, n) on real MEA data.
%
%   results = SPK2CA_SWEEP(BASEPATHS) loads spiking data from the given
%   basepaths and iterates through a range of Hill coefficients (n) and
%   dissociation constants (Kd). For each combination, it calculates the
%   Steady-State to Baseline ratio of mitochondrial calcium.
%
%   The goal is to find parameters that minimize the log-ratio (drift)
%   between baseline and steady-state periods, optimizing for 'recovery'
%   accuracy.
%
%   INPUTS:
%       basepaths   - (cell) List of recording directories.
%
%   OUTPUTS:
%       results     - (struct) Sweep results.
%                     .tbl      : (table) Unit-wise results.
%                     .sweep_Kd : (vec) Tested Kd values.
%                     .sweep_n  : (vec) Tested n values.
%                     .errMat   : (n x Kd) Population error matrix.
%
%   See also: SPK2CA, SPK2CA_SIM

%% ========================================================================
%  LOAD AND PREPARE DATA
%  ========================================================================

cfg = mcu_cfg;
basepaths = mcu_basepaths('mea_bac');
vars = {'mea', 'fr', 'frRcv'};
v = basepaths2vars('basepaths', basepaths, 'vars', vars, 'flgPrnt', false);
nFiles = length(basepaths);

% TABLE
varMap = struct();
varMap.uGood = 'fr.uGood';
varMap.uRcv = 'rcv.uRcv';
varMap.uPert = 'rcv.uPert';
varMap.spktimes = 'mea.spktimes';
varMap.frt = 'fr.fr';
tagFiles.Name = get_mname(basepaths, 0);
tagFiles.Group = repmat(cfg.lbl.grp(1), 1, nFiles);
tagFiles.Group(contains(tagFiles.Name, 'KO')) = cfg.lbl.grp(2);
tbl = v2tbl('v', v, 'varMap', varMap, 'tagFiles', tagFiles, ...
    'uOffset', 0);
tbl.UnitID = categorical(tbl.UnitID);
tbl(~tbl.uGood, :) = [];
% tbl(~tbl.uPert, :) = [];

% Limit spktimes to experiment
winExp = [0, 9 * 60]  * 60;
spktimes = cellfun(@(x) x(x >= winExp(1) & x <= winExp(2)), ...
    tbl.spktimes, 'UniformOutput', false);

%% ========================================================================
%  TIME VECTORS
%  ========================================================================

% 1 ms resolution
dt = 0.001;
maxTime = max(cellfun(@(x) max([0; x(:)]), tbl.spktimes));
tVec = 0:dt:maxTime;

% 1 s resolution
binSize  = 1;
chunks = n2chunks('n', maxTime, 'chunksize', binSize, 'lastChunk', 'exclude');
edges = [chunks(:,1)-1, chunks(:,2)];
edges = unique(edges(:))';
tBins = edges(1:end-1) + diff(edges)/2;
nBins = length(tBins);
binIdx = discretize(tVec, edges);
valid = ~isnan(binIdx);
binIdx = binIdx(valid);

% 1 min resolution
% Here, FR traces are not aligned perfectly to perturbation.
xVec = v(1).fr.t / 3600;


%% ========================================================================
%  PARAMETER SWEEP
%  ========================================================================

% Parameter Spaces
Kd = [1, 3, 5, 10, 20];
n  = [2, 4, 8];

nKd = length(Kd);
nN  = length(n);
nUnits = size(tbl, 1);

% Constants
isiGain  = 0;
tauC     = 0.1;
tauM     = 20;

% Windows (Indices)
idxZero = find(xVec >= 0, 1);
winBsl = [1, idxZero - 8];
winSs = [length(xVec) - winBsl(2), length(xVec) - 1];
winCalc = [winBsl; winSs] * 60 * 1000;

% Pre-allocate
% resMat is (nUnits x 2 x nKd x nN). Dimension 2: 1=Baseline, 2=SteadyState
resMat = zeros(nUnits, 2, nKd, nN);

% Initialize parpool
if isempty(gcp('nocreate'))
    parpool('local', 8);
end
dq = parallel.pool.DataQueue;
afterEach(dq, @(msg) fprintf('%s', msg));
fprintf('Starting Sweep [%d Units x %d Params]...\n', nUnits, nKd*nN);

parfor iUnit = 1:nUnits

    % Cytosolic Calcium
    st = spktimes{iUnit};
    C = spk2cyto(st, 't', tVec, 'dt', dt, 'tauC', tauC, 'isiGain', isiGain);

    tmpRes = zeros(2, nKd, nN);
    for iKd = 1 : nKd
        for iN = 1 : nN

            % Mito Integration
            M = cyto2mito(C, 'n', n(iN), 'Kd', Kd(iKd), ...
                'dt', dt, 'tauM', tauM, 'flgVmax', true);

            % Mean in windows
            tmpRes(1, iKd, iN) = mean(M(winCalc(1, 1) : winCalc(1, 2)), 'omitnan');
            tmpRes(2, iKd, iN) = mean(M(winCalc(2, 1) : winCalc(2, 2)), 'omitnan');
        end
    end
    resMat(iUnit, :, :, :) = tmpRes;
    send(dq, sprintf('Unit %d / %d processed.\n', iUnit, nUnits));
end


%% ========================================================================
%  ERROR
%  ========================================================================

% MITO

% Add floor to prevent log(0)
minVal = min(resMat(resMat > 0));
offset = minVal / 2;

% Extract matrices
mBsl = squeeze(resMat(:, 1, :, :)); % nUnits x nKd x nN
mSs  = squeeze(resMat(:, 2, :, :)); % nUnits x nKd x nN

% Log Ratio
logRatio = abs(log((mSs + offset) ./ (mBsl + offset)));

% Mean Error across Population
errMat = squeeze(median(logRatio, 1, 'omitnan')); % Kd x N

% FIRING RATE
frBsl = mean(tbl.frt(:, winBsl(1) : winBsl(2)), 2, 'omitnan');
frSs = mean(tbl.frt(:, winSs(1) : winSs(2)), 2, 'omitnan');

minVal = min(frSs(frSs > 0));
offset = minVal / 2;

logFr = abs(log((frSs + offset) ./ (frBsl + offset)));
errFr = median(logFr, 1, 'omitnan');



%% ========================================================================
%  INTERACTIVE GUI
%  ========================================================================

% Flatten results into table columns for GUI
for iKd = 1 : nKd
    for iN = 1 : nN
        % Create standard variable names
        suffix = sprintf('_K%g_n%g', Kd(iKd), n(iN));
        suffix = strrep(suffix, '.', 'p'); % Safety for decimals

        tbl.(['mBsl' suffix]) = resMat(:, 1, iKd, iN);
        tbl.(['mSs' suffix])  = resMat(:, 2, iKd, iN);
    end
end

sum(squeeze(any(any(any(resMat < 1e-10, 2), 3), 4)))

% Combine with tblu from mea_spk2ca
tbl = outerjoin(tbl, tblu, 'MergeKeys', true);

spk2ca_gui(tbl, Kd, n)



end % EOF  
