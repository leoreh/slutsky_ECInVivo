function M = cyto2mito(C, varargin)
% MITO2CYTO Calculates mitochondrial calcium accumulation from cytosolic calcium.
%
%   M = MITO2CYTO(C) calculates the mitochondrial matrix calcium (M) given
%   cytosolic calcium concentration (C). It first computes the influx (J)
%   using the Hill equation and then integrates it using either a linear
%   filter or Michaelis-Menten efflux kinetics.
%
%   INPUTS:
%       C           - (vec) Cytosolic Calcium Concentration.
%       varargin    - (param/value) Optional parameters:
%                     'Kd'      : (num) Dissociation constant for MCU.
%                     'n'       : (num) Hill coefficient for MCU.
%                     'dt'      : (num) Time step (s).
%                     'tauM'    : (num) Matrix decay time constant (s).
%                     'Vmax'    : (num) Max Efflux Rate (Conc/step).
%                     'Mmax'    : (num) Max mitochondrial capacity (Conc).
%                     'Km'      : (num) Efflux Affinity (Conc).
%                     'flgVmax' : (log) Use Michaelis-Menten Efflux.
%                                 If false, uses linear decay (tauM).
%
%   OUTPUTS:
%       M           - (vec) Mitochondrial Matrix Calcium Concentration.
%
%   See also: SPK2CA, SPK2CA_SIM

%% ========================================================================
%  ARGUMENTS
%  ========================================================================

p = inputParser;
addRequired(p, 'C', @isnumeric);
addParameter(p, 'Kd', 10, @isnumeric);
addParameter(p, 'n', 4, @isnumeric);
addParameter(p, 'dt', 0.001, @isnumeric);
addParameter(p, 'tauM', 20, @isnumeric);
addParameter(p, 'Vmax', [], @isnumeric);
addParameter(p, 'Mmax', [], @isnumeric);
addParameter(p, 'Km', [], @isnumeric);
addParameter(p, 'flgVmax', true, @islogical);

parse(p, C, varargin{:});
par = p.Results;

%% ========================================================================
%  COMPUTE INFLUX (J)
%  ========================================================================

% Hill Equation
% J = C^n / (C^n + Kd^n)
Cn = C .^ par.n;
Kn = par.Kd ^ par.n;
J  = Cn ./ (Cn + Kn);

%% ========================================================================
%  INTEGRATION PARAMS
%  ========================================================================

% Derived Constants
alphaM = exp(-par.dt / par.tauM);
gainIn = (1 - alphaM);      % Scales J to be physically compatible

% Calculate Vmax if not provided
Vmax = par.Vmax;
if isempty(Vmax)
    Vmax = Vmax_calc(J, gainIn);
end

% Set Km to half Vmax
if isempty(par.Km)
    par.Km = Vmax / 2;
end

% Set maximum capacity to the concentration where the Michaelis-Menten
% efflux reaches 95% of Vmax
Mmax = par.Mmax;
if isempty(Mmax)
    Mmax = par.Km * 19;
end


%% ========================================================================
%  COMPUTE MATRIX CALCIUM (M)
%  ========================================================================

if ~par.flgVmax
    % --- Linear Filter Mode ---
    % M(t) = alpha * M(t-1) + (1-alpha) * J(t)
    % This is the standard 'Leaky Integrator'
    M = filter(gainIn, [1, -alphaM], J);

else

    % --- Michaelis-Menten Efflux Mode ---
    nBins = length(J);
    M = zeros(size(J), 'like', J);
    M(1) = 0; % Initialize State

    for t = 2:nBins
        % Influx (Scaled by electrochemical gradient)
        In = J(t) * gainIn * (1 - M(t-1) / Mmax);

        % Efflux (Saturating)
        prevM = M(t-1);
        Out = (Vmax * prevM) / (par.Km + prevM);

        % Update State
        M(t) = prevM + In - Out;

        % Biological Boundary
        M(t) = max(0, min(M(t), Mmax));
    end
end

end     % EOF


%% ========================================================================
%  HELPER: VMAX_CALC
%  ========================================================================
function Vmax = Vmax_calc(J, gainIn)
% VMAX_CALC Calculates Vmax based on influx within a fixed window
% (baseline, hardcoded).
%
%   Vmax = Vmax_calc(J, gainIn, dt)
%
%   INPUTS:
%       J       - (vec) Influx trace.
%       gainIn  - (num) Influx gain factor.
%
%   OUTPUTS:
%       Vmax    - (num) Calculated Vmax.

win = [60000, 4000000];

% Ensure we don't exceed vector bounds
if length(J) < win(2)
    win(2) = length(J);
end

% Calculate median influx in the window
val    = mean(J(win(1):win(2)));
influx = val * gainIn;

% Return Vmax as 3 times the influx
Vmax = 3 * influx;

end
