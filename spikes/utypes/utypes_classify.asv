function unitType = utypes_classify(varargin)

% UTYPES_CLASSIFY classifies neuronal units into putative pyramidal cells (pPYR)
% and putative interneurons (pINT) using a two-step approach:
% 1. Initial classification using trough-to-peak (tp) threshold
% 2. Optional refinement using GMM clustering starting from the threshold-based
%    classification
%
% METHODOLOGY:
% Method 1 (altClassify = 1): Uses simple threshold-based classification on tp
% Method 2 (altClassify = 2): Uses GMM clustering initialized with threshold-based
%                            classification results
%
% INPUT (Optional Key-Value Pairs):
%   basepaths    (cell array) Full paths to recording folders. If empty,
%                uses current directory.
%   altClassify  (numeric) Classification method to use:
%                1 - Threshold-based classification using tp
%                2 - GMM-based classification using multiple metrics, initialized
%                    with threshold-based results
%                {1}
%   flgSave      (logical) Flag to save classification results
%                {false}
%   v            (struct) Data structure containing metrics. If empty,
%                data will be loaded from basepaths. {[]}
%
% OUTPUT:
%   unitType     (vector) Vector of unit classifications where:
%                1 = putative pyramidal cell (pPYR)
%                2 = putative interneuron (pINT)
%
% DEPENDENCIES:
%   basepaths2vars, catfields
%
% HISTORY:
%   LH - Aug 2024
%   Based in part on Oghazian et al., Front. Biomedical Tech., 2021

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments using inputParser
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
p = inputParser;
addOptional(p, 'basepaths', @(x) iscell(x));
addOptional(p, 'altClassify', 1, @(x) ismember(x, [1, 2, 3]));
addOptional(p, 'flgSave', false, @islogical);
addOptional(p, 'v', []);

parse(p, varargin{:});
basepaths = p.Results.basepaths;
altClassify = p.Results.altClassify;
flgSave = p.Results.flgSave;
v = p.Results.v;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% preparations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% load vars and concatenate metrics
if isempty(v)
    vars = {'swv_metrics', 'st_metrics', 'fr', 'units'};
    v = basepaths2vars('basepaths', basepaths, 'vars', vars);
end

% concatenate metrics across recordings
swv = catfields([v.swv], 2);  % waveform metrics
st = catfields([v.st], 1);    % spike train metrics
fr = catfields([v.fr], 1);    % firing rate metrics

% get number of units
nUnits = length(swv.tp);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% initial classification using threshold
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Identify non-inverted spikes
idxGood = ~swv.inverted;
nGood = sum(idxGood);

% For non-inverted spikes, perform classification using trough-to-peak
% pPYR: tp >= 0.4, pINT: tp < 0.4
unitType = zeros(nGood, 1);
pyrIdx = swv.tp(idxGood) >= 0.7;
unitType(pyrIdx) = 1;       % pPYR
unitType(~pyrIdx) = 2;      % pINT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% refine classification if requested
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Refine classification using GMM with threshold results as starting point
switch altClassify
    case 2
        % Prepare feature matrix for GMM
        mfr = fr.mfr(idxGood);
        brst = log10(st.royer(idxGood) + eps);
        brst = st.lidor(idxGood);
        fet = [swv.tp(idxGood)', brst, mfr];

        % Get refined classification using GMM
        unitType = gm2units(fet, unitType);

    case 3
        % Prepare feature matrix for GMM
        tailSlope = (swv.tailSlope(idxGood)');
        tailSlope = asinh(tailSlope);
        fet = [swv.tpRatio(idxGood)', swv.asym(idxGood)',...
            swv.hpk(idxGood)', swv.tpSlope(idxGood)', swv.tp(idxGood)'];
        fet = [swv.asym(idxGood)',...
            swv.hpk(idxGood)', swv.tp(idxGood)'];
        % % fet = zscore(fet);

        % Get refined classification using GMM
        unitType = gm2units(fet, unitType);
end

% Create clean matrix for units struct
clean = false(2, nUnits);
clean(1, idxGood) = unitType == 1;  % pPYR
clean(2, idxGood) = unitType == 2;  % pINT

% Update unitType to span all units
unitType = zeros(nUnits, 1);
unitType(clean(1, :)) = 1;
unitType(clean(2, :)) = 2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% save updated unit struct
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if flgSave
    startIdx = 1;
    for iPath = 1 : length(basepaths)
        basepath = basepaths{iPath};
        [~, basename] = fileparts(basepath);
        uFile = fullfile(basepath, [basename, '.units.mat']);

        % Get number of units for this recording
        units = v(iPath).units;
        nUnits = size(units.clean, 2);
        uIdx = startIdx : startIdx + nUnits - 1;
        startIdx = uIdx(end) + 1;

        % Add new classification field
        fieldName = sprintf('clean%d', altClassify);
        units.(fieldName) = false(2, nUnits);
        units.(fieldName)(:, :) = clean(:, uIdx);

        % Place altClassify3 as default
        if altClassify == 3
            units.clean = clean(:, uIdx);
        end

        % Save updated units structure
        save(uFile, 'units');
    end
end

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HELPER FUNCTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function typeOut = gm2units(fet, typeIn)
% GM2UNITS Refines unit classification using Gaussian Mixture Model
%
% This helper function performs GMM clustering to refine the initial unit
% classification. It uses the initial classification as a starting point
% for the GMM to improve convergence and interpretability.
%
% INPUT:
%   fet      (matrix) Feature matrix for GMM [nUnits x nFeatures]
%   typeIn   (vector) Initial classification [nUnits x 1]
%                     1 = putative pyramidal cell (pPYR)
%                     2 = putative interneuron (pINT)
%
% OUTPUT:
%   typeOut  (vector) Refined classification [nUnits x 1]

% Learn the cluster shapes (Means and Covariances) from the data, using
% 'typeIn' as starting point
gm = fitgmdist(fet, 2, 'RegularizationValue', 0.0537, 'Start', typeIn,...
    'CovarianceType', 'diagonal');

% Assign clusters to pPYR and pINT based on the initial classification
clusterLabels = cluster(gm, fet);
pyrCounts = zeros(1, 2);
for iUnit = 1:2
    pyrCounts(iUnit) = sum(clusterLabels == iUnit & typeIn == 1);
end
[~, pyrIdx] = max(pyrCounts);
intIdx = 3 - pyrIdx;

% Apply Bayesian Priors and Reconstruct the GMM. This shifts the decision
% boundary without distorting the cluster shapes.
priors = zeros(1, 2);
pyrProbability = 0.8;
prior(pyrIdx) = pyrProbability;
prior(intIdx) = 1 - pyrProbability;
gm = gmdistribution(gm.mu, gm.Sigma, priors);

% Final Classification.
% Cluster assignment is now: Maximize (Likelihood * FixedPrior)
clusterLabels = cluster(gm, fet);

% Map internal GMM components back to output format (1=pPYR, 2=pINT)
typeOut = ones(size(typeIn));          % Initialize all as pPYR
typeOut(clusterLabels ~= pyrIdx) = 2;  % Set non-pPYR cluster to pINT

end

% EOF



%% ========================================================================
%  NOTE: BAYESIAN PRIORS & POPULATION RATIO ENFORCEMENT
%  ========================================================================
%  The classification utilizes a Gaussian Mixture Model (GMM) with
%  informed Bayesian Priors to address potential sampling biases in
%  neuronal recordings.
%
%  1. The Bayesian Framework:
%     Standard GMM classification assigns units to clusters by maximizing
%     the Posterior Probability: P(Type|Waveform). According to Bayes'
%     Theorem, this is proportional to:
%         P(Waveform|Type)  * P(Type)
%         [Likelihood]         [Prior]
%
%  2. Likelihood (The Shape):
%     P(Waveform|Type) represents how well a unit's metrics fit the
%     geometric cluster (mean and variance) of that cell type. This constitutes
%     the "objective" fit of the data to the cluster distribution.
%
%  3. The Prior (The Population Count):
%     P(Type) represents the expected abundance of that cell type in the
%     population. In standard unsupervised clustering, this is estimated
%     directly from the recording data. However, electrophysiological
%     recordings often suffer from sampling bias (e.g., under-sampling
%     small interneurons), leading to incorrect data-driven priors.
%
%  4. Informed Priors vs. Forcing:
%     By fixing the Prior (e.g., setting pINT = 0.2), we do not "force"
%     dissimilar units into the interneuron cluster. We merely adjust the
%     decision boundary. A unit with a distinct Interneuron waveform will
%     still be classified as such because its Likelihood term is high.
%     However, for "ambiguous" units lying between clusters, the fixed Prior
%     shifts the classification probability toward the more common cell type
%     (Pyramidal). This reduces False Positives for the rarer class and
%     aligns the results with established histological ratios (e.g., ~80/20
%     Pyramidal/Interneuron split).
% 
%  5. In the mouse CA1 hippocampus, the actual biological ratio is
%     approximately 85% to 90% Pyramidal. Still, a prior of 80% pPYR units
%     is conservative, given
%  ========================================================================