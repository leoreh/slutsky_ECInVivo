function fetTbl = utypes_features(varargin)

% UTYPES_FEATURES calculates and visualizes various waveform features and their
% relationships for neuronal units. It computes metrics like AUC, p-values,
% and covariances between features, and generates visualization plots.
%
% INPUT (Optional Key-Value Pairs):
%   basepaths    (cell array) Full paths to recording folders. If empty,
%                uses current directory.
%   flgPlot      (logical) Flag to generate visualization plots
%                {true}
%
% OUTPUT:
%   fetTbl       (table) Table containing data for each unit:
%                - UnitID: Unique unit identifier
%                - Feature columns...
%
% DEPENDENCIES:
%   basepaths2vars, v2tbl, tbl_transform
%
% HISTORY:
%   LH - Aug 2024
%   Refactored Dec 2025 to use v2tbl and tbl_transform

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% arguments using inputParser
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
p = inputParser;
addOptional(p, 'basepaths', {}, @(x) iscell(x));
addOptional(p, 'flgPlot', true, @islogical);
addOptional(p, 'v', struct(), @isstruct);

parse(p, varargin{:});
basepaths = p.Results.basepaths;
flgPlot = p.Results.flgPlot;
v = p.Results.v;

%% ========================================================================
%  CREAT TABLE
%  ========================================================================

% load state vars and concatenate metrics
if isempty(fieldnames(v))
    if isempty(basepaths)
        error('Either basepaths or v must be provided.');
    end
    vars = {'swv_metrics', 'st_metrics', 'fr', 'units'};
    v = basepaths2vars('basepaths', basepaths, 'vars', vars);
end

% Get mouse names for table
tagFiles = struct();
if ~isempty(basepaths)
    tagFiles.Name = get_mname(basepaths);
elseif isfield(v, 'name')
    warning('Basepaths not provided; Mouse names might be missing in table.');
end

% Define variable map for v2tbl
% Spike times features
varMap = struct();
varMap.mfr = 'fr.mfr';
varMap.royer = 'st.royer';
varMap.royer2 = 'st.royer2';
varMap.lidor = 'st.lidor';
varMap.mizuseki = 'st.mizuseki';

% Waveform features
varMap.tp = 'swv.tp';
varMap.inverted = 'swv.inverted';
varMap.tpAmp = 'swv.tpAmp';
varMap.tpRatio = 'swv.tpRatio';
varMap.tpSlope = 'swv.tpSlope';
varMap.spkw = 'swv.spkw';
varMap.asym = 'swv.asym';
varMap.hpk = 'swv.hpk';
varMap.tailSlope = 'swv.tailSlope';
varMap.tailAmp = 'swv.tailAmp';
% varMap.imin = 'swv.imin';
% varMap.peakDuration = 'swv.peakDuration';

% Create table using v2tbl
fetTbl = v2tbl('v', v, 'varMap', varMap, 'tagFiles', tagFiles);

%% ========================================================================
%  PRELIMINARY CLASSIFICATION
%  ========================================================================


% Identify non-inverted spikes
idxGood = fetTbl.inverted == 0 & ~isnan(fetTbl.tp);
if sum(idxGood) == 0
    warning('No good units found (non-inverted).');
    return;
end

% For non-inverted spikes, perform classification using trough-to-peak
% pPYR: tp >= 0.4, pINT: tp < 0.4
unitType = zeros(height(fetTbl), 1);
unitType(idxGood & (fetTbl.tp >= 0.4)) = 1;  % pPYR
unitType(idxGood & (fetTbl.tp < 0.4)) = 2;   % pINT

% Create a categorical variable for plotting
fetTbl.UnitType = categorical(unitType, [0 1 2], {'Other', 'pPYR', 'pINT'});


%% ========================================================================
%  TRANSFORM SKEWED FEATURES
%  ========================================================================

% Define features to plot (numeric columns excluding tags)
pltFlds = fetTbl.Properties.VariableNames;
excludedFields = {'UnitID', 'inverted', 'Name', 'Group', 'UnitType'};
numericIdx = varfun(@isnumeric, fetTbl, 'OutputFormat', 'uniform');
pltFlds = pltFlds(numericIdx & ~ismember(pltFlds, excludedFields));

% Apply transformations (log-transform skewed data)
% Note: Using varsInc to limit transformation to features only
fetTbl = tbl_transform(fetTbl, 'flgLog', true, 'varsInc', pltFlds);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calculate metrics and plot
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if flgPlot
    % Plot histograms of waveform metrics
    figure('Name', 'Waveform Metrics Distributions', 'Position', [100 100 1200 800]);

    nFields = length(pltFlds);
    nCols = 4;
    nRows = ceil(nFields / nCols);

    tiledlayout(nRows, nCols, 'TileSpacing', 'tight', 'Padding', 'tight');

    for iFld = 1:nFields
        nexttile;
        fieldName = pltFlds{iFld};
        data = fetTbl.(fieldName)(idxGood);

        % Simple classification based metrics
        pyrData = data(unitType(idxGood) == 1);
        intData = data(unitType(idxGood) == 2);

        % Calculate ROC/AUC for pPYR vs pINT separation power of this feature
        % (Just as a metric of how different they are)
        [~,~,~,auc] = perfcurve(unitType(idxGood), data, 1);
        if ~isempty(pyrData) && ~isempty(intData)
            pVal = ranksum(pyrData, intData);
        else
            pVal = NaN;
        end

        histogram(data, 30, 'Normalization', 'probability');
        title(sprintf('%s\nAUC=%.3f, p=%.2e', fieldName, auc, pVal), 'Interpreter', 'none');
        grid on;
    end


    % Define variables to include 
    
    % Waveform features
    varsInc = {'tp', 'tpAmp', 'tpRatio', 'tpSlope', 'spkw', 'asym',...
        'hpk', 'tailSlope', 'tailAmp'};
    plot_corrHist(fetTbl(idxGood, :), 'varsInc', varsInc, 'grpIdx', 'UnitType', ...
        'clrGrp', [0 0 1 0.5; 1 0 0 0.5]); 

    % Spiking Features
    varsInc = {'mfr', 'royer', 'royer2', 'lidor', 'mizuseki'};
    plot_corrHist(fetTbl(idxGood, :), 'varsInc', varsInc, 'grpIdx', 'UnitType', ...
        'clrGrp', [0 0 1 0.5; 1 0 0 0.5]); 
    
    % Selected
    varsRow = {'tp', 'asym', 'hpk', 'tpAmp'};
    varsCol = {'mfr', 'royer', 'royer2', 'lidor'};
    plot_corrHist(fetTbl(idxGood, :), 'varsRow', varsRow, 'varsCol', varsCol,...
        'grpIdx', 'UnitType', 'clrGrp', [0 0 1 0.5; 1 0 0 0.5]); 

end

end

% EOF

%% ========================================================================
%  NOTE: FEATURE VALIDATION VIA AUC
%  ========================================================================
%  We use the Area Under the ROC Curve (AUC) to validate whether the
%  waveform-based classification predicts other physiological properties.
%
%  1. Ground Truth:
%     The classification labels (Pyramidal vs. Interneuron) are defined
%     solely by the Trough-to-Peak (TP) waveform duration.
%
%  2. Interpretation of AUC:
%     The AUC quantifies how well *other* metrics (e.g., Firing Rate)
%     align with these waveform labels.
%     - AUC ≈ 1.0 or 0.0: Strong Correlation. The feature is an effective
%       predictor. (Note: Values < 0.5 simply indicate an inverse
%       relationship, e.g., Higher Rate = Lower Probability of Pyramidal).
%     - AUC ≈ 0.5: Random Chance. The feature provides no discriminative
%       information for this classification.
%  ========================================================================

%% ========================================================================
%  NOTE: FEATURE SELECTION & REDUNDANCY ELIMINATION
%  ========================================================================
%  Feature selection is critical for Gaussian Mixture Model (GMM) performance.
%  GMMs rely on the Mahalanobis distance, which requires inverting the
%  covariance matrix. Highly correlated features (multicollinearity) cause
%  this matrix to become singular or unstable, leading to poor clustering.
%
%  1. Redundancy Criteria:
%     We assess redundancy using Spearman's Rank Correlation. Features with
%     |rho| > 0.85 are considered redundant.
%     - Visual Confirmation: Redundant pairs manifest as tight diagonal
%       lines in pairwise scatter plots.
%     - Independence: Effective feature pairs appear as "clouds" or
%       orthogonal distributions (rho < 0.3), providing unique information
%       to the classifier.
%
%  2. Selection Strategy (The "Survivor" Rule):
%     When a redundant pair is identified, we retain the feature that is:
%     - More Robust: Less sensitive to noise (e.g., Prefer 'FullWidth' over
%       'TailSlope').
%     - More Gaussian: Exhibits a distribution closer to Normality (or
%       Log-Normality), fitting the GMM assumptions better.
%     - Biologically Interpretable: Prioritize metrics with direct
%       physiologial correlates (e.g., Repolarization Time).
%  ========================================================================