function frFit = mea_frFit(frVec, pertOnset, varargin)
% MEAFRFIT Fits double-exponential recovery model to firing rate data.
%
% SUMMARY:
% This function fits a double-exponential model to capture firing rate
% recovery dynamics after a perturbation. The model captures three phases:
%   1. Baseline period: Robust linear fit to pre-perturbation data
%   2. Perturbation period: Linear decline from baseline to trough
%   3. Recovery period: Double-exponential model with primary recovery
%      and optional overshoot components
%
% INPUT (Required):
%   frVec      - Vector of firing rate values [Hz] for a single unit.
%   pertOnset   - Index of perturbation onset.
%
% INPUT (Name-Value):
%   flgPlot     - Flag to plot results {false}.
%   binSize     - Bin size for time constant calculations [s] (default: 30 s).
%
% OUTPUT:
%   frFit       - Structure containing fit results:
%     .frTrough       - Firing rate at recovery onset (trough) [Hz].
%     .recovOnset     - Index of recovery onset based on best fitted curve.
%     .model      - Name of the best-fitting model ('expo', 'gomp', 'rich').
%     .pFit           - Fitted parameters for the best model.
%     .rsquare        - R-squared goodness of fit for the best model.
%     .exitflag       - Exit flag of the best-fitting model.
%     .overshootTime  - Time to peak overshoot [s] (if applicable).
%     .overShootFr    - Peak overshoot firing rate [Hz] (if applicable).
%     .fitCurve       - Complete fitted curve [baseline; perturbation; recovery].
%     .frBsl          - Baseline firing rate from robust linear fit [Hz].
%     .bslFit         - Robust linear fit parameters [intercept, slope].
%     .frRecov           - Steady-state firing rate from best model [Hz].
%     .mdlFits        - Detailed results for each model fit.
%     .gof            - Goodness-of-fit stats (AIC, BIC) for each model.
%     .goodFit        - Flag indicating whether the unit is considered good for fitting.
%
% DEPENDENCIES:
%   Optimization Toolbox (for lsqcurvefit)
%   Statistics and Machine Learning Toolbox (for robustfit)
%
% HISTORY:
%   Sep 2024 - Extracted from mea_frRecovery.m as standalone function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ARGUMENT PARSING & INITIALIZATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p = inputParser;
addRequired(p, 'frVec', @isnumeric);
addRequired(p, 'pertOnset', @(x) isnumeric(x) && isscalar(x));
addParameter(p, 'flgPlot', false, @islogical);
addParameter(p, 'binSize', 30, @(x) isnumeric(x) && isscalar(x) && x > 0);

parse(p, frVec, pertOnset, varargin{:});
binSize = p.Results.binSize;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INITIALIZE OUTPUT STRUCTURE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

frFit = struct('frTrough', NaN, 'recovOnset', NaN, 'model', '', 'pFit', [], ...
    'rsquare', NaN, 'exitflag', 0, 'fitCurve', [], 'frBsl', NaN, 'bslFit', NaN, ...
    'frRecov', NaN, 'mdlFits', [], 'gof', struct('AIC', [], 'BIC', []),...
    'goodFit', false, 'pertDepth', [], 'recovChange', NaN, 'recovError', NaN, ...
    'qualityChecks', struct());

% Hard limit on number of bins with spikes
if sum(frVec > 0) < 10
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GUESS INITIAL PARAMETERS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Convert indices to relative time
tIdx = (1:length(frVec))';

% Initial guess for recovery onset using continuous derivative method
recovOnset = length(frVec);
dfr = diff(frVec);
dfrPost = dfr(pertOnset:end);
runsUp = conv(dfrPost > 0, ones(1, 5), 'valid');
longUp = find(runsUp >= 5, 1, 'first');

if ~isempty(longUp)
    recovOnset = pertOnset + longUp - 1;
else
    % Fallback: first non-negative derivative
    recovDelay = find(dfrPost >= 0, 1, 'first');
    recovOnset = pertOnset + recovDelay - 1;
end

% Override recovOnset
recovOnset = pertOnset + 5;

% Convert to relative time for fitting
tPost = tIdx(recovOnset:end) - recovOnset;
frPost = frVec(recovOnset:end);

% Recovery firing rate: Mean of last 10% of data
frRecov = mean(frPost(round(0.9 * length(frPost)):end), 'omitnan');
frTrough = frVec(recovOnset);

% Recovery kinetics: Based on time to 50% recovery, or last bin if no clear recovery
recovFr = frTrough + 0.5 * (frRecov - frTrough);
recovIdx = find(frPost >= recovFr, 1, 'first');
if ~isempty(recovIdx)
    % Clear recovery: use time to 50% recovery
    tHalf = tPost(recovIdx);
    kRecov = log(2) / tHalf;
else
    % No clear recovery: use rate from last bin. This will be slow if the
    % unit hasn't recovered.
    lastBinFr = frPost(end);
    kRecov = (lastBinFr - frTrough) / tPost(end);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FIND PEAKS OF RECOVERY FOR OVERSHOOT MODELING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Use findpeaks to detect nPeaks significant peaks. Require 10% prominence
minProminence = 0.2 * abs(frRecov - frTrough); 

[peakFr, peakTimes] = findpeaks(frPost, tPost, ...
    'NPeaks', 1, ...
    'SortStr', 'descend', ...
    'MinPeakHeight', frRecov, ...
    'MinPeakProminence', minProminence, ...
    'MinPeakWidth', round(0.05 * length(tPost)), ...
    'MinPeakDistance', round(0.05 * length(tPost)));

nPeaks = length(peakFr);
pkParams = struct('aOver', {}, 'kOver', {});
for iPeak = 1:nPeaks
    % Approximate overshoot amplitude relative to recovered FR
    overshootAmp = peakFr(iPeak) - frRecov;
    
    % Calculate initial parameters for the overshoot term A*t*exp(-k*t)
    % Peak of this term is at t = 1/k, value is A/(k*exp(1))
    if peakTimes(iPeak) > 0
        kOver = 1 / peakTimes(iPeak);
        aOver = overshootAmp * kOver * exp(1);
    else
        kOver = 1/1800; % Default: characteristic time of 30 min
        aOver = 0;
    end
    pkParams(iPeak).aOver = aOver;
    pkParams(iPeak).kOver = kOver;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL PREPARATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Create model struct array for base models
mdls = struct('name', {}, 'func', {}, 'p0', {}, 'lb', {}, 'ub', {});

% Model 1: Gompertz (base)
mdls(1).name = "gompertz";
mdls(1).func = @(p, tData) p(1) .* exp(log(max(p(3),eps) ./ p(1)) .* exp(-p(2) * tData));
mdls(1).p0 = [frRecov, kRecov, frTrough];
mdls(1).lb = [eps, 1e-6, 0];
mdls(1).ub = [3*max(frVec), 1, max(frVec)];

% Model 2: Richards (base)
mdls(2).name = "richards";
mdls(2).func = @(p, tData) p(1) ./ (1 + ((p(1)./max(p(3),eps)).^p(4) - 1) .* exp(-p(2)*tData)).^(1./p(4));
mdls(2).p0 = [frRecov, kRecov, frTrough, 1];
mdls(2).lb = [eps, 1e-6, 0, 1e-3];
mdls(2).ub = [3*max(frVec), 1, max(frVec), 100];

% Model 3: Exponential (base)
% mdls(3).name = "expo";
% mdls(3).func = @(p, tData) p(1) - (p(1) - p(3)) .* exp(-p(2) * tData);
% mdls(3).p0 = [frRecov, kRecov, frTrough];
% mdls(3).lb = [eps, 1e-6, 0];
% mdls(3).ub = [3*max(frVec), 1, max(frVec)];

% If peaks were detected, create augmented models with overshoot terms
if nPeaks > 0
    mdls = [mdls, mdls];
    for iMdl = length(mdls) / 2 + 1 : length(mdls)
        
        % Create new model with overshoot
        mdls(iMdl).name = mdls(iMdl).name + "_pks";
        
        % Store the base model function and number of parameters
        baseFunc = mdls(iMdl).func;
        numBaseParams = length(mdls(iMdl).p0);
        
        % Create simple overshoot model with 1 peak
        mdls(iMdl).func = @(p, tData) baseFunc(p(1:numBaseParams), tData) + ...
            p(numBaseParams + 1) * tData .* exp(-p(numBaseParams + 2) * tData);
        
        % Append parameters for overshoot terms
        mdls(iMdl).p0 = [mdls(iMdl).p0, pkParams(1).aOver, pkParams(1).kOver];
        mdls(iMdl).lb = [mdls(iMdl).lb, 0, 1e-6];
        mdls(iMdl).ub = [mdls(iMdl).ub, 3*max(frVec), 1];
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PERFORM MODEL FITS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nModels = length(mdls);

% Fit each model using the helper function
for iMdl = 1:nModels
    mdlFit(iMdl) = fit_mdl(frPost, tPost, mdls(iMdl));
end
frFit.mdlFits = catfields(mdlFit, 1, true);

% Check if any fit was successful
if all(frFit.mdlFits.exitflag <= 0)
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL SELECTION & GOODNESS-OF-FIT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[~, bestIdx] = min(frFit.mdlFits.BIC);
frFit.model = mdls(bestIdx).name;
frFit.pFit = frFit.mdlFits.pFit(bestIdx, :);
frFit.rsquare = frFit.mdlFits.rsquare(bestIdx);
frFit.exitflag = frFit.mdlFits.exitflag(bestIdx);

% Update frTrough and frRecov based on the best model's fit
frFit.frTrough = frFit.pFit(3);
frFit.frRecov = frFit.pFit(1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CALCULATE BASELINE WITH ROBUST LINEAR FIT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define baseline window (pre-perturbation onset) with margin
mrgnBins = 10;
bslWin = 1:max(1, pertOnset - mrgnBins);

% Fit robust linear regression to baseline period
[bslFit, ~] = robustfit(tIdx(bslWin), frVec(bslWin));

% Generate baseline curve using the linear fit
bslCurve = bslFit(1) + bslFit(2) * tIdx(1:(pertOnset-1));

% Use fitted line for calculating baseline FR
frFit.frBsl = mean(bslCurve);
frFit.bslFit = bslFit;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERATE COMPLETE FITTED CURVE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Perturbation period: exponential decay
frTrough = max([frFit.frTrough, eps]);
tPert = tIdx(pertOnset:(recovOnset-1));
pertCurve = linspace(bslCurve(end), frTrough, length(tPert))';

% Recovery period: fitted model
recovCurve = frFit.mdlFits.recovCurve(bestIdx, :);

% Extend recovery curve to full data length if needed
if length(recovCurve) < (length(frVec) - recovOnset + 1)
    recovCurve = mdls(bestIdx).func(frFit.pFit, tIdx(recovOnset:end) - recovOnset);
end

% Combine segments
frFit.fitCurve = [bslCurve; pertCurve; recovCurve'];

% Calculate recovery onset based on the best fitted curve
% Find the minimum of the fitted curve (trough)
% recovCurve = frFit.fitCurve(pertOnset:end);
% [~, minIdx] = min(recovCurve);
% frFit.recovOnset = pertOnset + minIdx - 1;
frFit.recovOnset = recovOnset;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IDENTIFY BAD UNITS BASED ON FIT QUALITY AND STABILITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section implements quality control to identify units unsuitable for recovery analysis.
% The criteria ensure reliable and interpretable results by checking fit quality, baseline
% stability, perturbation response, recovery kinetics, and minimum recovery rates.

% Initialize quality flags
qualityChecks = struct();

% FIT QUALITY
% R-squared threshold ensures the model explains a meaningful portion of variance
thrRsquare = 0.1;
qualityChecks.fitQuality = frFit.rsquare >= thrRsquare;
qualityChecks.fitQuality(isnan(frFit.rsquare)) = false; % Mark NaN R-squares as bad

% BASELINE STABILITY   
% Baseline slope should be minimal to ensure stable pre-perturbation activity
% Threshold: 1 Hz/min (equivalent to ~45 degrees slope)
thrBslSlope = 1; % Hz/min
if ~isempty(frFit.bslFit) && length(frFit.bslFit) >= 2
    baselineSlope = abs(frFit.bslFit(2)) * 60; % Convert to Hz/min
    qualityChecks.baselineStability = baselineSlope <= thrBslSlope;
else
    qualityChecks.baselineStability = false;
end

% RECOVERY KINETICS
% Recovery time constant should be physiologically plausible
% Too fast (< 1 bin) suggests unreliable fitting or noise
kRecov = frFit.pFit(2);
tauRecov = 1 / kRecov; % Recovery time constant in bins
tauRecovSec = tauRecov * binSize; % Convert to seconds
minTau = 1; 
qualityChecks.recoveryKinetics = tauRecovSec >= minTau;

% RECOVERY FAILURE
thrRecov = -3; % log2(0.12) for minimum ~12% recovery
frFit.recovChange = log2(frFit.frRecov / frFit.frBsl);
frFit.recovError = abs(frFit.recovChange);
qualityChecks.recoveryFailed = frFit.recovChange >= thrRecov;

% PERTURBATION RESPONSE
% Units should show meaningful perturbation effects (>20% reduction from baseline)
thrPert = -0.3; % log2(0.8) for ~20% reduction threshold
frFit.pertDepth = log2(frFit.frTrough / frFit.frBsl);
qualityChecks.perturbationResponse = frFit.pertDepth <= thrPert;


% BASELINE AND RECOVERY RATE
% Units should have sufficient activity for reliable analysis
thrFr = 0.001; % Hz
qualityChecks.baselineRate = frFit.frBsl >= thrFr;
qualityChecks.recoveryRate = frFit.frRecov >= thrFr;

% COMBINE 
qualityFields = fieldnames(qualityChecks);
frFit.goodFit = true;
for iFld = 1:length(qualityFields)
    frFit.goodFit = frFit.goodFit && qualityChecks.(qualityFields{iFld});
end

% Store detailed quality information for debugging
frFit.qualityChecks = qualityChecks;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT RESULTS (OPTIONAL)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if p.Results.flgPlot
    figure;
    hold on;
    
    % Plot raw data relative to trough
    plot(tIdx, frVec, 'k', 'DisplayName', 'Data', 'MarkerSize', 8);

    % --- Plot each successful model fit ---
    modelDisplayNames = cell(1, nModels);
    for iMdl = 1:nModels
        % Capitalize first letter of model name
        modelName = mdls(iMdl).name;
        modelDisplayNames{iMdl} = [upper(modelName(1)), modelName(2:end)];
    end
    colors = lines(nModels);
    tRecovIdx = tIdx(recovOnset:end);

    for iMdl = 1:nModels
        if frFit.mdlFits.exitflag(iMdl) > 0
            recovCurvePlot = frFit.mdlFits.recovCurve(iMdl, :);
            plot(tRecovIdx, recovCurvePlot, 'Color', colors(iMdl, :), 'LineWidth', 1.5, 'DisplayName', modelDisplayNames{iMdl});
        end
    end

    % --- Formatting ---
    % Highlight the best fit line
    if ~isempty(frFit.model)
        bestModelIdx = find(strcmp(frFit.mdlFits.name, frFit.model));
        h_all = findobj(gca, 'Type', 'line');
        h_best = findobj(h_all, 'DisplayName', modelDisplayNames{bestModelIdx});
        if ~isempty(h_best)
            set(h_best, 'LineWidth', 3);
            uistack(h_best, 'top');
        end
        plotTitle = sprintf('Best Fit: %s (BIC: %.2f)', ...
            frFit.model, frFit.mdlFits.BIC(bestModelIdx));
        title(plotTitle);
    else
        title('Firing Rate Recovery Fits');
    end
    
    xlabel('Time from trough (bins)');
    ylabel('Firing Rate (Hz)');
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HELPER FUNCTION: FIT_MDL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function mdlFit = fit_mdl(fr, t, mdl)
% FIT_MDL Helper function to fit a model to firing rate data
%
% INPUT:
%   fr      - Firing rate data vector
%   t       - Time vector
%   mdl     - Model struct containing model function, initial parameters, and bounds
%
% OUTPUT:
%   mdlFit  - Structure containing fit results:
%     .pFit       - Fitted parameters
%     .resnorm    - Residual norm
%     .exitflag   - Exit flag from optimization
%     .rsquare    - R-squared goodness of fit
%     .AIC        - Akaike Information Criterion
%     .BIC        - Bayesian Information Criterion
%     .recovCurve - Recovery curve from fitted model

% Hardcoded optimization options
opts = optimoptions('lsqcurvefit', 'Display', 'off', 'TolFun', 1e-6,...
    'MaxIter', 1000, 'FunctionTolerance', 1e-6);

% Perform the fit
[pFit, resnorm, ~, exitflag] = lsqcurvefit(mdl.func, mdl.p0, t, fr(:), mdl.lb, mdl.ub, opts);

% Calculate R-squared if fit was successful
if exitflag > 0
    % Calculate fitted values
    frFit = mdl.func(pFit, t);
    
    % Calculate R-squared
    ssTot = sum((fr - mean(fr)).^2);
    if ssTot > 0
        rsquare = 1 - (resnorm / ssTot);
    else
        rsquare = 1; % If total variance is 0, and resnorm is 0, R2 is 1
    end
    
    % Calculate AIC and BIC
    nData = length(fr);
    k = length(pFit); % Number of parameters
    if resnorm > 0
        AIC = 2*k + nData * log(resnorm / nData);
        BIC = k * log(nData) + nData * log(resnorm / nData);
    else % resnorm is 0, perfect fit
        AIC = -inf;
        BIC = -inf;
    end
    
    % Create recovery curve
    recovCurve = frFit;
else
    rsquare = NaN;
    AIC = inf;
    BIC = inf;
    recovCurve = nan(size(t));
end

% Create output structure
mdlFit = struct('pFit', pFit, 'resnorm', resnorm, 'exitflag', exitflag,...
    'rsquare', rsquare, 'AIC', AIC, 'BIC', BIC, 'recovCurve', recovCurve');

% Transfer all fields from input model struct
fields = fieldnames(mdl);
for iFld = 1:length(fields)
    mdlFit.(fields{iFld}) = mdl.(fields{iFld});
end

end

