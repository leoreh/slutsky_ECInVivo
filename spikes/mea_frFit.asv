function frFit = mea_frFit(frVec, pertOnset, varargin)
% MEAFRFIT Fits double-exponential recovery model to firing rate data.
%
% SUMMARY:
% This function fits a double-exponential model to capture firing rate
% recovery dynamics after a perturbation. The model captures three phases:
%   1. Baseline period: Robust linear fit to pre-perturbation data
%   2. Perturbation period: Linear decline from baseline to trough
%   3. Recovery period: Double-exponential model with primary recovery
%      and optional overshoot components
%
% INPUT (Required):
%   frVec      - Vector of firing rate values [Hz] for a single unit.
%   pertOnset   - Index of perturbation onset.
%
% INPUT (Name-Value):
%   flgPlot     - Flag to plot results {false}.
%   binSize     - Bin size for time constant calculations [s] (default: 30 s).
%
% OUTPUT:
%   frFit       - Structure containing fit results:
%     .frTrough       - Firing rate at recovery onset (trough) [Hz].
%     .recovOnset     - Index of recovery onset based on best fitted curve.
%     .model      - Name of the best-fitting model ('expo', 'gomp', 'rich').
%     .pFit           - Fitted parameters for the best model.
%     .rsquare        - R-squared goodness of fit for the best model.
%     .exitflag       - Exit flag of the best-fitting model.
%     .overshootTime  - Time to peak overshoot [s] (if applicable).
%     .overShootFr    - Peak overshoot firing rate [Hz] (if applicable).
%     .fitCurve       - Complete fitted curve [baseline; perturbation; recovery].
%     .frBsl          - Baseline firing rate from robust linear fit [Hz].
%     .bslFit         - Robust linear fit parameters [intercept, slope].
%     .frRecov           - Steady-state firing rate from best model [Hz].
%     .mdlFits        - Detailed results for each model fit.
%     .gof            - Goodness-of-fit stats (AIC, BIC) for each model.
%     .goodFit        - Flag indicating whether the unit is considered good for fitting.
%
% DEPENDENCIES:
%   Optimization Toolbox (for lsqcurvefit)
%   Statistics and Machine Learning Toolbox (for robustfit)
%
% HISTORY:
%   Sep 2024 - Extracted from mea_frRecovery.m as standalone function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ARGUMENT PARSING & INITIALIZATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p = inputParser;
addRequired(p, 'frVec', @isnumeric);
addRequired(p, 'pertOnset', @(x) isnumeric(x) && isscalar(x));
addParameter(p, 'flgPlot', false, @islogical);
addParameter(p, 'binSize', 30, @(x) isnumeric(x) && isscalar(x) && x > 0);

parse(p, frVec, pertOnset, varargin{:});
binSize = p.Results.binSize;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INITIALIZE OUTPUT STRUCTURE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

frFit = struct('frTrough', NaN, 'recovOnset', NaN, 'model', '', 'pFit', [], ...
    'rsquare', NaN, 'exitflag', 0, 'fitCurve', [], 'frBsl', NaN, 'bslFit', NaN, ...
    'frRecov', NaN, 'mdlFits', [], 'gof', struct('AIC', [], 'BIC', []), 'goodFit', false);

% Hard limit on number of bins with spikes
if sum(frVec > 0) < 10
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL FITTING PREPARATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Convert indices to relative time
tIdx = (1:length(frVec))';

% Initial guess for recovery onset using continuous derivative method
recovOnset = length(frVec);
dfr = diff(frVec);
dfrPost = dfr(pertOnset:end);
runsUp = conv(dfrPost > 0, ones(1, 5), 'valid');
longUp = find(runsUp >= 5, 1, 'first');

if ~isempty(longUp)
    recovOnset = pertOnset + longUp - 1;
else
    % Fallback: first non-negative derivative
    recovDelay = find(dfrPost >= 0, 1, 'first');
    recovOnset = pertOnset + recovDelay - 1;
end

% Override recovOnset
recovOnset = pertOnset + 5;

% Convert to relative time for fitting
tPost = tIdx(recovOnset:end) - recovOnset;
frPost = frVec(recovOnset:end);

% Recovery firing rate: Mean of last 10% of data
frRecov = mean(frPost(round(0.9 * length(frPost)):end), 'omitnan');
frTrough = frVec(recovOnset);

% Recovery kinetics: Based on time to 50% recovery, or last bin if no clear recovery
recovFr = frTrough + 0.5 * (frRecov - frTrough);
recovIdx = find(frPost >= recovFr, 1, 'first');
if ~isempty(recovIdx)
    % Clear recovery: use time to 50% recovery
    tHalf = tPost(recovIdx);
    kRecov = log(2) / tHalf;
else
    % No clear recovery: use rate from last bin. This will be slow if the
    % unit hasn't recovered.
    lastBinFr = frPost(end);
    kRecov = (lastBinFr - frTrough) / tPost(end);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FIND PEAKS OF RECOVERY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% REPLACE WITH FINDPEAKS

% Overshoot amplitude: Based on max post-pert FR
[maxFr, maxIdx] = max(frPost);
if maxFr > frRecov
    aOver = (maxFr - frRecov) / (tPost(maxIdx) * exp(-1));
else
    aOver = 0;
end

% Overshoot rate: Based on time to peak
if aOver > 1e-6
    kOver = 1 / tPost(maxIdx);
else
    kOver = 1/1800;  % Default: characteristic time of 30 min
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL PARAMETER PREPARATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Create model struct array
mdls = struct('name', {}, 'func', {}, 'p0', {}, 'lb', {}, 'ub', {});

% Model 1: Exponential
mdls(1).name = "expo";
mdls(1).func = @(p, tData) p(1) - (p(1) - p(3)) .* exp(-p(2) * tData) + ...
    p(4) * tData .* exp(-p(5) * tData);
mdls(1).p0 = [frRecov, kRecov, frTrough, aOver, kOver];
mdls(1).lb = [eps, 1e-6, 0, 0, 1e-6];
mdls(1).ub = [3*max(frVec), 1, max(frVec), 3*max(frVec), 1];

% Model 2: Gompertz
mdls(2).name = "gompertz";
mdls(2).func = @(p, tData) p(1) .* exp(log(max(p(3),eps) ./ p(1)) .* exp(-p(2) * tData));
mdls(2).p0 = [frRecov, kRecov, frTrough];
mdls(2).lb = [eps, 1e-6, 0];
mdls(2).ub = [3*max(frVec), 1, max(frVec)];

% Model 3: Richards
mdls(3).name = "richards";
mdls(3).func = @(p, tData) p(1) ./ (1 + ((p(1)./max(p(3),eps)).^p(4) - 1) .* exp(-p(2)*tData)).^(1./p(4));
mdls(3).p0 = [frRecov, kRecov, frTrough, 1];
mdls(3).lb = [eps, 1e-6, 0, 1e-3];
mdls(3).ub = [3*max(frVec), 1, max(frVec), 100];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PERFORM MODEL FITS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nModels = length(mdls);

% Fit each model using the helper function
for iMdl = 1:nModels
    mdlFit(iMdl) = fit_mdl(frPost, tPost, mdls(iMdl));
end
frFit.mdlFits = catfields(mdlFit, 1, true);

% Check if any fit was successful
if all(frFit.mdlFits.exitflag <= 0)
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL SELECTION & GOODNESS-OF-FIT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[~, bestIdx] = min(frFit.mdlFits.BIC);
frFit.model = mdls(bestIdx).name;
frFit.pFit = frFit.mdlFits.pFit(bestIdx, :);
frFit.rsquare = frFit.mdlFits.rsquare(bestIdx);
frFit.exitflag = frFit.mdlFits.exitflag(bestIdx);

% Update frTrough and frRecov based on the best model's fit
frFit.frTrough = frFit.pFit(3);
frFit.frRecov = frFit.pFit(1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CALCULATE BASELINE WITH ROBUST LINEAR FIT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define baseline window (pre-perturbation onset) with margin
mrgnBins = 10;
bslWin = 1:max(1, pertOnset - mrgnBins);

% Fit robust linear regression to baseline period
[bslFit, ~] = robustfit(tIdx(bslWin), frVec(bslWin));

% Generate baseline curve using the linear fit
bslCurve = bslFit(1) + bslFit(2) * tIdx(1:(pertOnset-1));

% Use fitted line for calculating baseline FR
frFit.frBsl = mean(bslCurve);
frFit.bslFit = bslFit;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERATE COMPLETE FITTED CURVE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Perturbation period: exponential decay
frTrough = max([frFit.frTrough, eps]);
tPert = tIdx(pertOnset:(recovOnset-1));
pertCurve = linspace(bslCurve(end), frTrough, length(tPert))';

% Recovery period: fitted model
recovCurve = frFit.mdlFits.recovCurve(bestIdx, :);

% Extend recovery curve to full data length if needed
if length(recovCurve) < (length(frVec) - recovOnset + 1)
    % Need to extend the recovery curve to cover the full remaining time
    tFullRecov = tIdx(recovOnset:end) - recovOnset; % Full recovery time vector
    recovCurve = mdls(bestIdx).func(frFit.pFit, tFullRecov);
end

% Combine segments
frFit.fitCurve = [bslCurve; pertCurve; recovCurve];

% Calculate recovery onset based on the best fitted curve
% Find the minimum of the fitted curve (trough)
if ~isempty(frFit.fitCurve) && length(frFit.fitCurve) > pertOnset
    recovCurve = frFit.fitCurve(pertOnset:end);
    [~, minIdx] = min(recovCurve);
    frFit.recovOnset = pertOnset + minIdx - 1;
else
    % Fallback to initial guess if fitCurve is not available
    frFit.recovOnset = recovOnset;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IDENTIFY BAD UNITS BASED ON FIT QUALITY AND STABILITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section implements quality control to identify units unsuitable for recovery analysis.
% The criteria ensure reliable and interpretable results by checking fit quality, baseline
% stability, perturbation response, recovery kinetics, and minimum recovery rates.

% Initialize quality flags
qualityChecks = struct();

% FIT QUALITY
% R-squared threshold ensures the model explains a meaningful portion of variance
thrRsquare = 0.1;
qualityChecks.fitQuality = frFit.rsquare >= thrRsquare;
qualityChecks.fitQuality(isnan(frFit.rsquare)) = false; % Mark NaN R-squares as bad

% BASELINE STABILITY   
% Baseline slope should be minimal to ensure stable pre-perturbation activity
% Threshold: 1 Hz/min (equivalent to ~45 degrees slope)
thrBslSlope = 1; % Hz/min
if ~isempty(frFit.bslFit) && length(frFit.bslFit) >= 2
    baselineSlope = abs(frFit.bslFit(2)) * 60; % Convert to Hz/min
    qualityChecks.baselineStability = baselineSlope <= thrBslSlope;
else
    qualityChecks.baselineStability = false;
end

% RECOVERY KINETICS
% Recovery time constant should be physiologically plausible
% Too fast (< 1 bin) suggests unreliable fitting or noise
kRecov = frFit.pFit(2);
tauRecov = 1 / kRecov; % Recovery time constant in bins
tauRecovSec = tauRecov * binSize; % Convert to seconds
minTau = 1; 
qualityChecks.recoveryKinetics = tauRecovSec >= minTau;

% RECOVERY STRENGTH
recovThr = 1; % log2(0.8) for ~20% reduction threshold
frFit.recovChange = log2(frFit.frRecov / frFit.frBsl);
frFit.recovError = abs(recovChange);
qualityChecks.recoveryFailed = frFit.recovChange < minTau;

% PERTURBATION RESPONSE
% Units should show meaningful perturbation effects (>20% reduction from baseline)
thrPert = -0.3; % log2(0.8) for ~20% reduction threshold
if frFit.frBsl > 0
    frFit.pertDepth = log2(frFit.frTrough / frFit.frBsl);
    qualityChecks.perturbationResponse = frFit.pertDepth <= thrPert;
else
    qualityChecks.perturbationResponse = false;
end

% BASELINE AND RECOVERY RATE
% Units should have sufficient baseline activity for reliable analysis
thrFr = 0.001; % Hz
qualityChecks.baselineRate = frFit.frBsl >= thrFr;
qualityChecks.recoveryRate = frFit.frRecov >= thrFr;

% COMBINE 
qualityFields = fieldnames(qualityChecks);
allChecks = true;
for iFld = 1:length(qualityFields)
    frFit.goodFit = allChecks && qualityChecks.(qualityFields{iFld});
end

% Store detailed quality information for debugging
frFit.qualityChecks = qualityChecks;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLOT RESULTS (OPTIONAL)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if p.Results.flgPlot
    figure;
    hold on;
    
    % Plot raw data relative to trough
    plot(tIdx, frVec, 'k', 'DisplayName', 'Data', 'MarkerSize', 8);

    % --- Plot each successful model fit ---
    modelDisplayNames = cell(1, nModels);
    for iMdl = 1:nModels
        modelDisplayNames{iMdl} = upperFirst(mdls(iMdl).name);
    end
    colors = {'#D95319', '#77AC30', '#0072BD'}; % R, G, B
    
    for iMdl = 1:nModels
        if frFit.mdlFits.exitflag(iMdl) > 0
            recovCurvePlot = frFit.mdlFits.recovCurve(iMdl, :);
            fitCurvePlot = [bslCurve; pertCurve; recovCurvePlot];
            plot(tIdx, fitCurvePlot, 'Color', colors{iMdl}, 'LineWidth', 1.5, 'DisplayName', modelDisplayNames{iMdl});
        end
    end

    % --- Formatting ---
    % Highlight the best fit line
    if ~isempty(frFit.model)
        bestModelIdx = find(strcmp(mdls.name, frFit.model));
        h_all = findobj(gca, 'Type', 'line');
        h_best = findobj(h_all, 'DisplayName', modelDisplayNames{bestModelIdx});
        if ~isempty(h_best)
            set(h_best, 'LineWidth', 3);
            uistack(h_best, 'top');
        end
        plotTitle = sprintf('Best Fit: %s (BIC: %.2f)', ...
            frFit.model, frFit.gof.BIC(bestModelIdx));
        title(plotTitle);
    else
        title('Firing Rate Recovery Fits');
    end
    
    xlabel('Time from trough (bins)');
    ylabel('Firing Rate (Hz)');
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HELPER FUNCTION: FIT_MDL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function mdlFit = fit_mdl(fr, t, mdl)
% FIT_MDL Helper function to fit a model to firing rate data
%
% INPUT:
%   fr      - Firing rate data vector
%   t       - Time vector
%   mdl     - Model struct containing model function, initial parameters, and bounds
%
% OUTPUT:
%   mdlFit  - Structure containing fit results:
%     .pFit       - Fitted parameters
%     .resnorm    - Residual norm
%     .exitflag   - Exit flag from optimization
%     .rsquare    - R-squared goodness of fit
%     .AIC        - Akaike Information Criterion
%     .BIC        - Bayesian Information Criterion
%     .recovCurve - Recovery curve from fitted model

% Hardcoded optimization options
opts = optimoptions('lsqcurvefit', 'Display', 'off', 'TolFun', 1e-6,...
    'MaxIter', 1000, 'FunctionTolerance', 1e-6);

% Perform the fit
[pFit, resnorm, ~, exitflag] = lsqcurvefit(mdl.func, mdl.p0, t, fr(:), mdl.lb, mdl.ub, opts);

% Calculate R-squared if fit was successful
if exitflag > 0
    % Calculate fitted values
    frFit = mdl.func(pFit, t);
    
    % Calculate R-squared
    ssTot = sum((fr - mean(fr)).^2);
    if ssTot > 0
        rsquare = 1 - (resnorm / ssTot);
    else
        rsquare = 1; % If total variance is 0, and resnorm is 0, R2 is 1
    end
    
    % Calculate AIC and BIC
    nData = length(fr);
    k = length(pFit); % Number of parameters
    if resnorm > 0
        AIC = 2*k + nData * log(resnorm / nData);
        BIC = k * log(nData) + nData * log(resnorm / nData);
    else % resnorm is 0, perfect fit
        AIC = -inf;
        BIC = -inf;
    end
    
    % Create recovery curve
    recovCurve = frFit;
else
    rsquare = NaN;
    AIC = inf;
    BIC = inf;
    recovCurve = nan(size(t));
end

% Create output structure
mdlFit = struct('pFit', pFit, 'resnorm', resnorm, 'exitflag', exitflag, 'rsquare', rsquare, 'AIC', AIC, 'BIC', BIC, 'recovCurve', recovCurve);

% Transfer all fields from input model struct
fields = fieldnames(mdl);
for iFld = 1:length(fields)
    mdlFit.(fields{iFld}) = mdl.(fields{iFld});
end

end

function str = upperFirst(str)
% UPPERFIRST Capitalizes the first letter of a string
str(1) = upper(str(1));
end 